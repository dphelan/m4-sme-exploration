// generated by tools/gen_mem_benchmarks.py, do not edit!
#include <assert.h>
#include <stdlib.h>
#include "bench.h"

// Allocation granularity, must be large enough to align with 4x multivector load/store
#define SIZE_ALIGNMENT (64*4)

// Benchmark parameters
typedef struct {
  char*  src;
  char*  dst;
  size_t size;
  size_t n_iterations;
  double total_size;
} benchmark_data_t;

// Benchmark functions

static double load_za_vector_x1_ilp1(const void* args) {
  // LDR (ZA vector)
  //
  // Bytes per instruction: 64, bytes per loop iteration: 64 (ILP=1)
  const benchmark_data_t* data = args;

  //printf("starting load_za_vector_x1_ilp1\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x12, #0                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  2:                                                        \n"
    "    ldr za[w12, 0], [x1, 0, MUL VL]                         \n"
    "                                                            \n"
    "    add x1, x1, #64                                         \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 2b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [end] "r" (data->src + data->size)
    : "x0", "x1", "x12"
  );

  //printf("done load_za_vector_x1_ilp1\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double load_za_vector_x1_ilp2(const void* args) {
  // LDR (ZA vector)
  //
  // Bytes per instruction: 64, bytes per loop iteration: 128 (ILP=2)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 128);

  //printf("starting load_za_vector_x1_ilp2\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x12, #0                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  2:                                                        \n"
    "    ldr za[w12, 0], [x1, 0, MUL VL]                         \n"
    "    ldr za[w12, 1], [x1, 1, MUL VL]                         \n"
    "                                                            \n"
    "    add x1, x1, #128                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    ldr za[w12, 0], [x1, 0, MUL VL]                         \n"
    "    add x1, x1, #64                                         \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1", "x12"
  );

  //printf("done load_za_vector_x1_ilp2\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double load_za_vector_x1_ilp3(const void* args) {
  // LDR (ZA vector)
  //
  // Bytes per instruction: 64, bytes per loop iteration: 192 (ILP=3)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 192);

  //printf("starting load_za_vector_x1_ilp3\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x12, #0                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  2:                                                        \n"
    "    ldr za[w12, 0], [x1, 0, MUL VL]                         \n"
    "    ldr za[w12, 1], [x1, 1, MUL VL]                         \n"
    "    ldr za[w12, 2], [x1, 2, MUL VL]                         \n"
    "                                                            \n"
    "    add x1, x1, #192                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    ldr za[w12, 0], [x1, 0, MUL VL]                         \n"
    "    add x1, x1, #64                                         \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1", "x12"
  );

  //printf("done load_za_vector_x1_ilp3\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double load_za_vector_x1_ilp4(const void* args) {
  // LDR (ZA vector)
  //
  // Bytes per instruction: 64, bytes per loop iteration: 256 (ILP=4)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 256);

  //printf("starting load_za_vector_x1_ilp4\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x12, #0                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  2:                                                        \n"
    "    ldr za[w12, 0], [x1, 0, MUL VL]                         \n"
    "    ldr za[w12, 1], [x1, 1, MUL VL]                         \n"
    "    ldr za[w12, 2], [x1, 2, MUL VL]                         \n"
    "    ldr za[w12, 3], [x1, 3, MUL VL]                         \n"
    "                                                            \n"
    "    add x1, x1, #256                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    ldr za[w12, 0], [x1, 0, MUL VL]                         \n"
    "    add x1, x1, #64                                         \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1", "x12"
  );

  //printf("done load_za_vector_x1_ilp4\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double load_za_vector_x1_ilp5(const void* args) {
  // LDR (ZA vector)
  //
  // Bytes per instruction: 64, bytes per loop iteration: 320 (ILP=5)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 320);

  //printf("starting load_za_vector_x1_ilp5\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x12, #0                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  2:                                                        \n"
    "    ldr za[w12, 0], [x1, 0, MUL VL]                         \n"
    "    ldr za[w12, 1], [x1, 1, MUL VL]                         \n"
    "    ldr za[w12, 2], [x1, 2, MUL VL]                         \n"
    "    ldr za[w12, 3], [x1, 3, MUL VL]                         \n"
    "    ldr za[w12, 4], [x1, 4, MUL VL]                         \n"
    "                                                            \n"
    "    add x1, x1, #320                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    ldr za[w12, 0], [x1, 0, MUL VL]                         \n"
    "    add x1, x1, #64                                         \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1", "x12"
  );

  //printf("done load_za_vector_x1_ilp5\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double load_za_vector_x1_ilp6(const void* args) {
  // LDR (ZA vector)
  //
  // Bytes per instruction: 64, bytes per loop iteration: 384 (ILP=6)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 384);

  //printf("starting load_za_vector_x1_ilp6\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x12, #0                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  2:                                                        \n"
    "    ldr za[w12, 0], [x1, 0, MUL VL]                         \n"
    "    ldr za[w12, 1], [x1, 1, MUL VL]                         \n"
    "    ldr za[w12, 2], [x1, 2, MUL VL]                         \n"
    "    ldr za[w12, 3], [x1, 3, MUL VL]                         \n"
    "    ldr za[w12, 4], [x1, 4, MUL VL]                         \n"
    "    ldr za[w12, 5], [x1, 5, MUL VL]                         \n"
    "                                                            \n"
    "    add x1, x1, #384                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    ldr za[w12, 0], [x1, 0, MUL VL]                         \n"
    "    add x1, x1, #64                                         \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1", "x12"
  );

  //printf("done load_za_vector_x1_ilp6\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double load_za_vector_x1_ilp7(const void* args) {
  // LDR (ZA vector)
  //
  // Bytes per instruction: 64, bytes per loop iteration: 448 (ILP=7)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 448);

  //printf("starting load_za_vector_x1_ilp7\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x12, #0                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  2:                                                        \n"
    "    ldr za[w12, 0], [x1, 0, MUL VL]                         \n"
    "    ldr za[w12, 1], [x1, 1, MUL VL]                         \n"
    "    ldr za[w12, 2], [x1, 2, MUL VL]                         \n"
    "    ldr za[w12, 3], [x1, 3, MUL VL]                         \n"
    "    ldr za[w12, 4], [x1, 4, MUL VL]                         \n"
    "    ldr za[w12, 5], [x1, 5, MUL VL]                         \n"
    "    ldr za[w12, 6], [x1, 6, MUL VL]                         \n"
    "                                                            \n"
    "    add x1, x1, #448                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    ldr za[w12, 0], [x1, 0, MUL VL]                         \n"
    "    add x1, x1, #64                                         \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1", "x12"
  );

  //printf("done load_za_vector_x1_ilp7\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double load_za_vector_x1_ilp8(const void* args) {
  // LDR (ZA vector)
  //
  // Bytes per instruction: 64, bytes per loop iteration: 512 (ILP=8)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 512);

  //printf("starting load_za_vector_x1_ilp8\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x12, #0                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  2:                                                        \n"
    "    ldr za[w12, 0], [x1, 0, MUL VL]                         \n"
    "    ldr za[w12, 1], [x1, 1, MUL VL]                         \n"
    "    ldr za[w12, 2], [x1, 2, MUL VL]                         \n"
    "    ldr za[w12, 3], [x1, 3, MUL VL]                         \n"
    "    ldr za[w12, 4], [x1, 4, MUL VL]                         \n"
    "    ldr za[w12, 5], [x1, 5, MUL VL]                         \n"
    "    ldr za[w12, 6], [x1, 6, MUL VL]                         \n"
    "    ldr za[w12, 7], [x1, 7, MUL VL]                         \n"
    "                                                            \n"
    "    add x1, x1, #512                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    ldr za[w12, 0], [x1, 0, MUL VL]                         \n"
    "    add x1, x1, #64                                         \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1", "x12"
  );

  //printf("done load_za_vector_x1_ilp8\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double load_za_vector_x1_ilp9(const void* args) {
  // LDR (ZA vector)
  //
  // Bytes per instruction: 64, bytes per loop iteration: 576 (ILP=9)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 576);

  //printf("starting load_za_vector_x1_ilp9\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x12, #0                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  2:                                                        \n"
    "    ldr za[w12, 0], [x1, 0, MUL VL]                         \n"
    "    ldr za[w12, 1], [x1, 1, MUL VL]                         \n"
    "    ldr za[w12, 2], [x1, 2, MUL VL]                         \n"
    "    ldr za[w12, 3], [x1, 3, MUL VL]                         \n"
    "    ldr za[w12, 4], [x1, 4, MUL VL]                         \n"
    "    ldr za[w12, 5], [x1, 5, MUL VL]                         \n"
    "    ldr za[w12, 6], [x1, 6, MUL VL]                         \n"
    "    ldr za[w12, 7], [x1, 7, MUL VL]                         \n"
    "    ldr za[w12, 8], [x1, 8, MUL VL]                         \n"
    "                                                            \n"
    "    add x1, x1, #576                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    ldr za[w12, 0], [x1, 0, MUL VL]                         \n"
    "    add x1, x1, #64                                         \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1", "x12"
  );

  //printf("done load_za_vector_x1_ilp9\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double load_za_vector_x1_ilp10(const void* args) {
  // LDR (ZA vector)
  //
  // Bytes per instruction: 64, bytes per loop iteration: 640 (ILP=10)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 640);

  //printf("starting load_za_vector_x1_ilp10\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x12, #0                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  2:                                                        \n"
    "    ldr za[w12, 0], [x1, 0, MUL VL]                         \n"
    "    ldr za[w12, 1], [x1, 1, MUL VL]                         \n"
    "    ldr za[w12, 2], [x1, 2, MUL VL]                         \n"
    "    ldr za[w12, 3], [x1, 3, MUL VL]                         \n"
    "    ldr za[w12, 4], [x1, 4, MUL VL]                         \n"
    "    ldr za[w12, 5], [x1, 5, MUL VL]                         \n"
    "    ldr za[w12, 6], [x1, 6, MUL VL]                         \n"
    "    ldr za[w12, 7], [x1, 7, MUL VL]                         \n"
    "    ldr za[w12, 8], [x1, 8, MUL VL]                         \n"
    "    ldr za[w12, 9], [x1, 9, MUL VL]                         \n"
    "                                                            \n"
    "    add x1, x1, #640                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    ldr za[w12, 0], [x1, 0, MUL VL]                         \n"
    "    add x1, x1, #64                                         \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1", "x12"
  );

  //printf("done load_za_vector_x1_ilp10\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double load_za_vector_x1_ilp11(const void* args) {
  // LDR (ZA vector)
  //
  // Bytes per instruction: 64, bytes per loop iteration: 704 (ILP=11)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 704);

  //printf("starting load_za_vector_x1_ilp11\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x12, #0                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  2:                                                        \n"
    "    ldr za[w12, 0], [x1, 0, MUL VL]                         \n"
    "    ldr za[w12, 1], [x1, 1, MUL VL]                         \n"
    "    ldr za[w12, 2], [x1, 2, MUL VL]                         \n"
    "    ldr za[w12, 3], [x1, 3, MUL VL]                         \n"
    "    ldr za[w12, 4], [x1, 4, MUL VL]                         \n"
    "    ldr za[w12, 5], [x1, 5, MUL VL]                         \n"
    "    ldr za[w12, 6], [x1, 6, MUL VL]                         \n"
    "    ldr za[w12, 7], [x1, 7, MUL VL]                         \n"
    "    ldr za[w12, 8], [x1, 8, MUL VL]                         \n"
    "    ldr za[w12, 9], [x1, 9, MUL VL]                         \n"
    "    ldr za[w12, 10], [x1, 10, MUL VL]                       \n"
    "                                                            \n"
    "    add x1, x1, #704                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    ldr za[w12, 0], [x1, 0, MUL VL]                         \n"
    "    add x1, x1, #64                                         \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1", "x12"
  );

  //printf("done load_za_vector_x1_ilp11\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double load_za_vector_x1_ilp12(const void* args) {
  // LDR (ZA vector)
  //
  // Bytes per instruction: 64, bytes per loop iteration: 768 (ILP=12)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 768);

  //printf("starting load_za_vector_x1_ilp12\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x12, #0                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  2:                                                        \n"
    "    ldr za[w12, 0], [x1, 0, MUL VL]                         \n"
    "    ldr za[w12, 1], [x1, 1, MUL VL]                         \n"
    "    ldr za[w12, 2], [x1, 2, MUL VL]                         \n"
    "    ldr za[w12, 3], [x1, 3, MUL VL]                         \n"
    "    ldr za[w12, 4], [x1, 4, MUL VL]                         \n"
    "    ldr za[w12, 5], [x1, 5, MUL VL]                         \n"
    "    ldr za[w12, 6], [x1, 6, MUL VL]                         \n"
    "    ldr za[w12, 7], [x1, 7, MUL VL]                         \n"
    "    ldr za[w12, 8], [x1, 8, MUL VL]                         \n"
    "    ldr za[w12, 9], [x1, 9, MUL VL]                         \n"
    "    ldr za[w12, 10], [x1, 10, MUL VL]                       \n"
    "    ldr za[w12, 11], [x1, 11, MUL VL]                       \n"
    "                                                            \n"
    "    add x1, x1, #768                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    ldr za[w12, 0], [x1, 0, MUL VL]                         \n"
    "    add x1, x1, #64                                         \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1", "x12"
  );

  //printf("done load_za_vector_x1_ilp12\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double load_za_vector_x1_ilp13(const void* args) {
  // LDR (ZA vector)
  //
  // Bytes per instruction: 64, bytes per loop iteration: 832 (ILP=13)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 832);

  //printf("starting load_za_vector_x1_ilp13\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x12, #0                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  2:                                                        \n"
    "    ldr za[w12, 0], [x1, 0, MUL VL]                         \n"
    "    ldr za[w12, 1], [x1, 1, MUL VL]                         \n"
    "    ldr za[w12, 2], [x1, 2, MUL VL]                         \n"
    "    ldr za[w12, 3], [x1, 3, MUL VL]                         \n"
    "    ldr za[w12, 4], [x1, 4, MUL VL]                         \n"
    "    ldr za[w12, 5], [x1, 5, MUL VL]                         \n"
    "    ldr za[w12, 6], [x1, 6, MUL VL]                         \n"
    "    ldr za[w12, 7], [x1, 7, MUL VL]                         \n"
    "    ldr za[w12, 8], [x1, 8, MUL VL]                         \n"
    "    ldr za[w12, 9], [x1, 9, MUL VL]                         \n"
    "    ldr za[w12, 10], [x1, 10, MUL VL]                       \n"
    "    ldr za[w12, 11], [x1, 11, MUL VL]                       \n"
    "    ldr za[w12, 12], [x1, 12, MUL VL]                       \n"
    "                                                            \n"
    "    add x1, x1, #832                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    ldr za[w12, 0], [x1, 0, MUL VL]                         \n"
    "    add x1, x1, #64                                         \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1", "x12"
  );

  //printf("done load_za_vector_x1_ilp13\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double load_za_vector_x1_ilp14(const void* args) {
  // LDR (ZA vector)
  //
  // Bytes per instruction: 64, bytes per loop iteration: 896 (ILP=14)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 896);

  //printf("starting load_za_vector_x1_ilp14\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x12, #0                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  2:                                                        \n"
    "    ldr za[w12, 0], [x1, 0, MUL VL]                         \n"
    "    ldr za[w12, 1], [x1, 1, MUL VL]                         \n"
    "    ldr za[w12, 2], [x1, 2, MUL VL]                         \n"
    "    ldr za[w12, 3], [x1, 3, MUL VL]                         \n"
    "    ldr za[w12, 4], [x1, 4, MUL VL]                         \n"
    "    ldr za[w12, 5], [x1, 5, MUL VL]                         \n"
    "    ldr za[w12, 6], [x1, 6, MUL VL]                         \n"
    "    ldr za[w12, 7], [x1, 7, MUL VL]                         \n"
    "    ldr za[w12, 8], [x1, 8, MUL VL]                         \n"
    "    ldr za[w12, 9], [x1, 9, MUL VL]                         \n"
    "    ldr za[w12, 10], [x1, 10, MUL VL]                       \n"
    "    ldr za[w12, 11], [x1, 11, MUL VL]                       \n"
    "    ldr za[w12, 12], [x1, 12, MUL VL]                       \n"
    "    ldr za[w12, 13], [x1, 13, MUL VL]                       \n"
    "                                                            \n"
    "    add x1, x1, #896                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    ldr za[w12, 0], [x1, 0, MUL VL]                         \n"
    "    add x1, x1, #64                                         \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1", "x12"
  );

  //printf("done load_za_vector_x1_ilp14\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double load_za_vector_x1_ilp15(const void* args) {
  // LDR (ZA vector)
  //
  // Bytes per instruction: 64, bytes per loop iteration: 960 (ILP=15)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 960);

  //printf("starting load_za_vector_x1_ilp15\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x12, #0                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  2:                                                        \n"
    "    ldr za[w12, 0], [x1, 0, MUL VL]                         \n"
    "    ldr za[w12, 1], [x1, 1, MUL VL]                         \n"
    "    ldr za[w12, 2], [x1, 2, MUL VL]                         \n"
    "    ldr za[w12, 3], [x1, 3, MUL VL]                         \n"
    "    ldr za[w12, 4], [x1, 4, MUL VL]                         \n"
    "    ldr za[w12, 5], [x1, 5, MUL VL]                         \n"
    "    ldr za[w12, 6], [x1, 6, MUL VL]                         \n"
    "    ldr za[w12, 7], [x1, 7, MUL VL]                         \n"
    "    ldr za[w12, 8], [x1, 8, MUL VL]                         \n"
    "    ldr za[w12, 9], [x1, 9, MUL VL]                         \n"
    "    ldr za[w12, 10], [x1, 10, MUL VL]                       \n"
    "    ldr za[w12, 11], [x1, 11, MUL VL]                       \n"
    "    ldr za[w12, 12], [x1, 12, MUL VL]                       \n"
    "    ldr za[w12, 13], [x1, 13, MUL VL]                       \n"
    "    ldr za[w12, 14], [x1, 14, MUL VL]                       \n"
    "                                                            \n"
    "    add x1, x1, #960                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    ldr za[w12, 0], [x1, 0, MUL VL]                         \n"
    "    add x1, x1, #64                                         \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1", "x12"
  );

  //printf("done load_za_vector_x1_ilp15\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double load_za_vector_x1_ilp16(const void* args) {
  // LDR (ZA vector)
  //
  // Bytes per instruction: 64, bytes per loop iteration: 1024 (ILP=16)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 1024);

  //printf("starting load_za_vector_x1_ilp16\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x12, #0                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  2:                                                        \n"
    "    ldr za[w12, 0], [x1, 0, MUL VL]                         \n"
    "    ldr za[w12, 1], [x1, 1, MUL VL]                         \n"
    "    ldr za[w12, 2], [x1, 2, MUL VL]                         \n"
    "    ldr za[w12, 3], [x1, 3, MUL VL]                         \n"
    "    ldr za[w12, 4], [x1, 4, MUL VL]                         \n"
    "    ldr za[w12, 5], [x1, 5, MUL VL]                         \n"
    "    ldr za[w12, 6], [x1, 6, MUL VL]                         \n"
    "    ldr za[w12, 7], [x1, 7, MUL VL]                         \n"
    "    ldr za[w12, 8], [x1, 8, MUL VL]                         \n"
    "    ldr za[w12, 9], [x1, 9, MUL VL]                         \n"
    "    ldr za[w12, 10], [x1, 10, MUL VL]                       \n"
    "    ldr za[w12, 11], [x1, 11, MUL VL]                       \n"
    "    ldr za[w12, 12], [x1, 12, MUL VL]                       \n"
    "    ldr za[w12, 13], [x1, 13, MUL VL]                       \n"
    "    ldr za[w12, 14], [x1, 14, MUL VL]                       \n"
    "    ldr za[w12, 15], [x1, 15, MUL VL]                       \n"
    "                                                            \n"
    "    add x1, x1, #1024                                       \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    ldr za[w12, 0], [x1, 0, MUL VL]                         \n"
    "    add x1, x1, #64                                         \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1", "x12"
  );

  //printf("done load_za_vector_x1_ilp16\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double store_za_vector_x1_ilp1(const void* args) {
  // STR (ZA vector)
  //
  // Bytes per instruction: 64, bytes per loop iteration: 64 (ILP=1)
  const benchmark_data_t* data = args;

  //printf("starting store_za_vector_x1_ilp1\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x12, #0                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[dst]                                            \n"
    "  2:                                                        \n"
    "    str za[w12, 0], [x1, 0, MUL VL]                         \n"
    "                                                            \n"
    "    add x1, x1, #64                                         \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 2b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [dst] "r" (data->dst), [end] "r" (data->dst + data->size)
    : "x0", "x1", "x12"
  );

  //printf("done store_za_vector_x1_ilp1\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double store_za_vector_x1_ilp2(const void* args) {
  // STR (ZA vector)
  //
  // Bytes per instruction: 64, bytes per loop iteration: 128 (ILP=2)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 128);

  //printf("starting store_za_vector_x1_ilp2\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x12, #0                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[dst]                                            \n"
    "  2:                                                        \n"
    "    str za[w12, 0], [x1, 0, MUL VL]                         \n"
    "    str za[w12, 1], [x1, 1, MUL VL]                         \n"
    "                                                            \n"
    "    add x1, x1, #128                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    str za[w12, 0], [x1, 0, MUL VL]                         \n"
    "    add x1, x1, #64                                         \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [dst] "r" (data->dst), [end] "r" (data->dst + data->size), [end_aligned] "r" (data->dst + size_aligned)
    : "x0", "x1", "x12"
  );

  //printf("done store_za_vector_x1_ilp2\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double store_za_vector_x1_ilp3(const void* args) {
  // STR (ZA vector)
  //
  // Bytes per instruction: 64, bytes per loop iteration: 192 (ILP=3)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 192);

  //printf("starting store_za_vector_x1_ilp3\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x12, #0                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[dst]                                            \n"
    "  2:                                                        \n"
    "    str za[w12, 0], [x1, 0, MUL VL]                         \n"
    "    str za[w12, 1], [x1, 1, MUL VL]                         \n"
    "    str za[w12, 2], [x1, 2, MUL VL]                         \n"
    "                                                            \n"
    "    add x1, x1, #192                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    str za[w12, 0], [x1, 0, MUL VL]                         \n"
    "    add x1, x1, #64                                         \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [dst] "r" (data->dst), [end] "r" (data->dst + data->size), [end_aligned] "r" (data->dst + size_aligned)
    : "x0", "x1", "x12"
  );

  //printf("done store_za_vector_x1_ilp3\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double store_za_vector_x1_ilp4(const void* args) {
  // STR (ZA vector)
  //
  // Bytes per instruction: 64, bytes per loop iteration: 256 (ILP=4)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 256);

  //printf("starting store_za_vector_x1_ilp4\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x12, #0                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[dst]                                            \n"
    "  2:                                                        \n"
    "    str za[w12, 0], [x1, 0, MUL VL]                         \n"
    "    str za[w12, 1], [x1, 1, MUL VL]                         \n"
    "    str za[w12, 2], [x1, 2, MUL VL]                         \n"
    "    str za[w12, 3], [x1, 3, MUL VL]                         \n"
    "                                                            \n"
    "    add x1, x1, #256                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    str za[w12, 0], [x1, 0, MUL VL]                         \n"
    "    add x1, x1, #64                                         \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [dst] "r" (data->dst), [end] "r" (data->dst + data->size), [end_aligned] "r" (data->dst + size_aligned)
    : "x0", "x1", "x12"
  );

  //printf("done store_za_vector_x1_ilp4\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double store_za_vector_x1_ilp5(const void* args) {
  // STR (ZA vector)
  //
  // Bytes per instruction: 64, bytes per loop iteration: 320 (ILP=5)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 320);

  //printf("starting store_za_vector_x1_ilp5\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x12, #0                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[dst]                                            \n"
    "  2:                                                        \n"
    "    str za[w12, 0], [x1, 0, MUL VL]                         \n"
    "    str za[w12, 1], [x1, 1, MUL VL]                         \n"
    "    str za[w12, 2], [x1, 2, MUL VL]                         \n"
    "    str za[w12, 3], [x1, 3, MUL VL]                         \n"
    "    str za[w12, 4], [x1, 4, MUL VL]                         \n"
    "                                                            \n"
    "    add x1, x1, #320                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    str za[w12, 0], [x1, 0, MUL VL]                         \n"
    "    add x1, x1, #64                                         \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [dst] "r" (data->dst), [end] "r" (data->dst + data->size), [end_aligned] "r" (data->dst + size_aligned)
    : "x0", "x1", "x12"
  );

  //printf("done store_za_vector_x1_ilp5\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double store_za_vector_x1_ilp6(const void* args) {
  // STR (ZA vector)
  //
  // Bytes per instruction: 64, bytes per loop iteration: 384 (ILP=6)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 384);

  //printf("starting store_za_vector_x1_ilp6\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x12, #0                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[dst]                                            \n"
    "  2:                                                        \n"
    "    str za[w12, 0], [x1, 0, MUL VL]                         \n"
    "    str za[w12, 1], [x1, 1, MUL VL]                         \n"
    "    str za[w12, 2], [x1, 2, MUL VL]                         \n"
    "    str za[w12, 3], [x1, 3, MUL VL]                         \n"
    "    str za[w12, 4], [x1, 4, MUL VL]                         \n"
    "    str za[w12, 5], [x1, 5, MUL VL]                         \n"
    "                                                            \n"
    "    add x1, x1, #384                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    str za[w12, 0], [x1, 0, MUL VL]                         \n"
    "    add x1, x1, #64                                         \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [dst] "r" (data->dst), [end] "r" (data->dst + data->size), [end_aligned] "r" (data->dst + size_aligned)
    : "x0", "x1", "x12"
  );

  //printf("done store_za_vector_x1_ilp6\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double store_za_vector_x1_ilp7(const void* args) {
  // STR (ZA vector)
  //
  // Bytes per instruction: 64, bytes per loop iteration: 448 (ILP=7)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 448);

  //printf("starting store_za_vector_x1_ilp7\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x12, #0                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[dst]                                            \n"
    "  2:                                                        \n"
    "    str za[w12, 0], [x1, 0, MUL VL]                         \n"
    "    str za[w12, 1], [x1, 1, MUL VL]                         \n"
    "    str za[w12, 2], [x1, 2, MUL VL]                         \n"
    "    str za[w12, 3], [x1, 3, MUL VL]                         \n"
    "    str za[w12, 4], [x1, 4, MUL VL]                         \n"
    "    str za[w12, 5], [x1, 5, MUL VL]                         \n"
    "    str za[w12, 6], [x1, 6, MUL VL]                         \n"
    "                                                            \n"
    "    add x1, x1, #448                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    str za[w12, 0], [x1, 0, MUL VL]                         \n"
    "    add x1, x1, #64                                         \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [dst] "r" (data->dst), [end] "r" (data->dst + data->size), [end_aligned] "r" (data->dst + size_aligned)
    : "x0", "x1", "x12"
  );

  //printf("done store_za_vector_x1_ilp7\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double store_za_vector_x1_ilp8(const void* args) {
  // STR (ZA vector)
  //
  // Bytes per instruction: 64, bytes per loop iteration: 512 (ILP=8)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 512);

  //printf("starting store_za_vector_x1_ilp8\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x12, #0                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[dst]                                            \n"
    "  2:                                                        \n"
    "    str za[w12, 0], [x1, 0, MUL VL]                         \n"
    "    str za[w12, 1], [x1, 1, MUL VL]                         \n"
    "    str za[w12, 2], [x1, 2, MUL VL]                         \n"
    "    str za[w12, 3], [x1, 3, MUL VL]                         \n"
    "    str za[w12, 4], [x1, 4, MUL VL]                         \n"
    "    str za[w12, 5], [x1, 5, MUL VL]                         \n"
    "    str za[w12, 6], [x1, 6, MUL VL]                         \n"
    "    str za[w12, 7], [x1, 7, MUL VL]                         \n"
    "                                                            \n"
    "    add x1, x1, #512                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    str za[w12, 0], [x1, 0, MUL VL]                         \n"
    "    add x1, x1, #64                                         \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [dst] "r" (data->dst), [end] "r" (data->dst + data->size), [end_aligned] "r" (data->dst + size_aligned)
    : "x0", "x1", "x12"
  );

  //printf("done store_za_vector_x1_ilp8\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double store_za_vector_x1_ilp9(const void* args) {
  // STR (ZA vector)
  //
  // Bytes per instruction: 64, bytes per loop iteration: 576 (ILP=9)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 576);

  //printf("starting store_za_vector_x1_ilp9\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x12, #0                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[dst]                                            \n"
    "  2:                                                        \n"
    "    str za[w12, 0], [x1, 0, MUL VL]                         \n"
    "    str za[w12, 1], [x1, 1, MUL VL]                         \n"
    "    str za[w12, 2], [x1, 2, MUL VL]                         \n"
    "    str za[w12, 3], [x1, 3, MUL VL]                         \n"
    "    str za[w12, 4], [x1, 4, MUL VL]                         \n"
    "    str za[w12, 5], [x1, 5, MUL VL]                         \n"
    "    str za[w12, 6], [x1, 6, MUL VL]                         \n"
    "    str za[w12, 7], [x1, 7, MUL VL]                         \n"
    "    str za[w12, 8], [x1, 8, MUL VL]                         \n"
    "                                                            \n"
    "    add x1, x1, #576                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    str za[w12, 0], [x1, 0, MUL VL]                         \n"
    "    add x1, x1, #64                                         \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [dst] "r" (data->dst), [end] "r" (data->dst + data->size), [end_aligned] "r" (data->dst + size_aligned)
    : "x0", "x1", "x12"
  );

  //printf("done store_za_vector_x1_ilp9\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double store_za_vector_x1_ilp10(const void* args) {
  // STR (ZA vector)
  //
  // Bytes per instruction: 64, bytes per loop iteration: 640 (ILP=10)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 640);

  //printf("starting store_za_vector_x1_ilp10\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x12, #0                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[dst]                                            \n"
    "  2:                                                        \n"
    "    str za[w12, 0], [x1, 0, MUL VL]                         \n"
    "    str za[w12, 1], [x1, 1, MUL VL]                         \n"
    "    str za[w12, 2], [x1, 2, MUL VL]                         \n"
    "    str za[w12, 3], [x1, 3, MUL VL]                         \n"
    "    str za[w12, 4], [x1, 4, MUL VL]                         \n"
    "    str za[w12, 5], [x1, 5, MUL VL]                         \n"
    "    str za[w12, 6], [x1, 6, MUL VL]                         \n"
    "    str za[w12, 7], [x1, 7, MUL VL]                         \n"
    "    str za[w12, 8], [x1, 8, MUL VL]                         \n"
    "    str za[w12, 9], [x1, 9, MUL VL]                         \n"
    "                                                            \n"
    "    add x1, x1, #640                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    str za[w12, 0], [x1, 0, MUL VL]                         \n"
    "    add x1, x1, #64                                         \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [dst] "r" (data->dst), [end] "r" (data->dst + data->size), [end_aligned] "r" (data->dst + size_aligned)
    : "x0", "x1", "x12"
  );

  //printf("done store_za_vector_x1_ilp10\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double store_za_vector_x1_ilp11(const void* args) {
  // STR (ZA vector)
  //
  // Bytes per instruction: 64, bytes per loop iteration: 704 (ILP=11)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 704);

  //printf("starting store_za_vector_x1_ilp11\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x12, #0                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[dst]                                            \n"
    "  2:                                                        \n"
    "    str za[w12, 0], [x1, 0, MUL VL]                         \n"
    "    str za[w12, 1], [x1, 1, MUL VL]                         \n"
    "    str za[w12, 2], [x1, 2, MUL VL]                         \n"
    "    str za[w12, 3], [x1, 3, MUL VL]                         \n"
    "    str za[w12, 4], [x1, 4, MUL VL]                         \n"
    "    str za[w12, 5], [x1, 5, MUL VL]                         \n"
    "    str za[w12, 6], [x1, 6, MUL VL]                         \n"
    "    str za[w12, 7], [x1, 7, MUL VL]                         \n"
    "    str za[w12, 8], [x1, 8, MUL VL]                         \n"
    "    str za[w12, 9], [x1, 9, MUL VL]                         \n"
    "    str za[w12, 10], [x1, 10, MUL VL]                       \n"
    "                                                            \n"
    "    add x1, x1, #704                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    str za[w12, 0], [x1, 0, MUL VL]                         \n"
    "    add x1, x1, #64                                         \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [dst] "r" (data->dst), [end] "r" (data->dst + data->size), [end_aligned] "r" (data->dst + size_aligned)
    : "x0", "x1", "x12"
  );

  //printf("done store_za_vector_x1_ilp11\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double store_za_vector_x1_ilp12(const void* args) {
  // STR (ZA vector)
  //
  // Bytes per instruction: 64, bytes per loop iteration: 768 (ILP=12)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 768);

  //printf("starting store_za_vector_x1_ilp12\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x12, #0                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[dst]                                            \n"
    "  2:                                                        \n"
    "    str za[w12, 0], [x1, 0, MUL VL]                         \n"
    "    str za[w12, 1], [x1, 1, MUL VL]                         \n"
    "    str za[w12, 2], [x1, 2, MUL VL]                         \n"
    "    str za[w12, 3], [x1, 3, MUL VL]                         \n"
    "    str za[w12, 4], [x1, 4, MUL VL]                         \n"
    "    str za[w12, 5], [x1, 5, MUL VL]                         \n"
    "    str za[w12, 6], [x1, 6, MUL VL]                         \n"
    "    str za[w12, 7], [x1, 7, MUL VL]                         \n"
    "    str za[w12, 8], [x1, 8, MUL VL]                         \n"
    "    str za[w12, 9], [x1, 9, MUL VL]                         \n"
    "    str za[w12, 10], [x1, 10, MUL VL]                       \n"
    "    str za[w12, 11], [x1, 11, MUL VL]                       \n"
    "                                                            \n"
    "    add x1, x1, #768                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    str za[w12, 0], [x1, 0, MUL VL]                         \n"
    "    add x1, x1, #64                                         \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [dst] "r" (data->dst), [end] "r" (data->dst + data->size), [end_aligned] "r" (data->dst + size_aligned)
    : "x0", "x1", "x12"
  );

  //printf("done store_za_vector_x1_ilp12\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double store_za_vector_x1_ilp13(const void* args) {
  // STR (ZA vector)
  //
  // Bytes per instruction: 64, bytes per loop iteration: 832 (ILP=13)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 832);

  //printf("starting store_za_vector_x1_ilp13\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x12, #0                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[dst]                                            \n"
    "  2:                                                        \n"
    "    str za[w12, 0], [x1, 0, MUL VL]                         \n"
    "    str za[w12, 1], [x1, 1, MUL VL]                         \n"
    "    str za[w12, 2], [x1, 2, MUL VL]                         \n"
    "    str za[w12, 3], [x1, 3, MUL VL]                         \n"
    "    str za[w12, 4], [x1, 4, MUL VL]                         \n"
    "    str za[w12, 5], [x1, 5, MUL VL]                         \n"
    "    str za[w12, 6], [x1, 6, MUL VL]                         \n"
    "    str za[w12, 7], [x1, 7, MUL VL]                         \n"
    "    str za[w12, 8], [x1, 8, MUL VL]                         \n"
    "    str za[w12, 9], [x1, 9, MUL VL]                         \n"
    "    str za[w12, 10], [x1, 10, MUL VL]                       \n"
    "    str za[w12, 11], [x1, 11, MUL VL]                       \n"
    "    str za[w12, 12], [x1, 12, MUL VL]                       \n"
    "                                                            \n"
    "    add x1, x1, #832                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    str za[w12, 0], [x1, 0, MUL VL]                         \n"
    "    add x1, x1, #64                                         \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [dst] "r" (data->dst), [end] "r" (data->dst + data->size), [end_aligned] "r" (data->dst + size_aligned)
    : "x0", "x1", "x12"
  );

  //printf("done store_za_vector_x1_ilp13\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double store_za_vector_x1_ilp14(const void* args) {
  // STR (ZA vector)
  //
  // Bytes per instruction: 64, bytes per loop iteration: 896 (ILP=14)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 896);

  //printf("starting store_za_vector_x1_ilp14\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x12, #0                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[dst]                                            \n"
    "  2:                                                        \n"
    "    str za[w12, 0], [x1, 0, MUL VL]                         \n"
    "    str za[w12, 1], [x1, 1, MUL VL]                         \n"
    "    str za[w12, 2], [x1, 2, MUL VL]                         \n"
    "    str za[w12, 3], [x1, 3, MUL VL]                         \n"
    "    str za[w12, 4], [x1, 4, MUL VL]                         \n"
    "    str za[w12, 5], [x1, 5, MUL VL]                         \n"
    "    str za[w12, 6], [x1, 6, MUL VL]                         \n"
    "    str za[w12, 7], [x1, 7, MUL VL]                         \n"
    "    str za[w12, 8], [x1, 8, MUL VL]                         \n"
    "    str za[w12, 9], [x1, 9, MUL VL]                         \n"
    "    str za[w12, 10], [x1, 10, MUL VL]                       \n"
    "    str za[w12, 11], [x1, 11, MUL VL]                       \n"
    "    str za[w12, 12], [x1, 12, MUL VL]                       \n"
    "    str za[w12, 13], [x1, 13, MUL VL]                       \n"
    "                                                            \n"
    "    add x1, x1, #896                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    str za[w12, 0], [x1, 0, MUL VL]                         \n"
    "    add x1, x1, #64                                         \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [dst] "r" (data->dst), [end] "r" (data->dst + data->size), [end_aligned] "r" (data->dst + size_aligned)
    : "x0", "x1", "x12"
  );

  //printf("done store_za_vector_x1_ilp14\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double store_za_vector_x1_ilp15(const void* args) {
  // STR (ZA vector)
  //
  // Bytes per instruction: 64, bytes per loop iteration: 960 (ILP=15)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 960);

  //printf("starting store_za_vector_x1_ilp15\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x12, #0                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[dst]                                            \n"
    "  2:                                                        \n"
    "    str za[w12, 0], [x1, 0, MUL VL]                         \n"
    "    str za[w12, 1], [x1, 1, MUL VL]                         \n"
    "    str za[w12, 2], [x1, 2, MUL VL]                         \n"
    "    str za[w12, 3], [x1, 3, MUL VL]                         \n"
    "    str za[w12, 4], [x1, 4, MUL VL]                         \n"
    "    str za[w12, 5], [x1, 5, MUL VL]                         \n"
    "    str za[w12, 6], [x1, 6, MUL VL]                         \n"
    "    str za[w12, 7], [x1, 7, MUL VL]                         \n"
    "    str za[w12, 8], [x1, 8, MUL VL]                         \n"
    "    str za[w12, 9], [x1, 9, MUL VL]                         \n"
    "    str za[w12, 10], [x1, 10, MUL VL]                       \n"
    "    str za[w12, 11], [x1, 11, MUL VL]                       \n"
    "    str za[w12, 12], [x1, 12, MUL VL]                       \n"
    "    str za[w12, 13], [x1, 13, MUL VL]                       \n"
    "    str za[w12, 14], [x1, 14, MUL VL]                       \n"
    "                                                            \n"
    "    add x1, x1, #960                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    str za[w12, 0], [x1, 0, MUL VL]                         \n"
    "    add x1, x1, #64                                         \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [dst] "r" (data->dst), [end] "r" (data->dst + data->size), [end_aligned] "r" (data->dst + size_aligned)
    : "x0", "x1", "x12"
  );

  //printf("done store_za_vector_x1_ilp15\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double store_za_vector_x1_ilp16(const void* args) {
  // STR (ZA vector)
  //
  // Bytes per instruction: 64, bytes per loop iteration: 1024 (ILP=16)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 1024);

  //printf("starting store_za_vector_x1_ilp16\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x12, #0                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[dst]                                            \n"
    "  2:                                                        \n"
    "    str za[w12, 0], [x1, 0, MUL VL]                         \n"
    "    str za[w12, 1], [x1, 1, MUL VL]                         \n"
    "    str za[w12, 2], [x1, 2, MUL VL]                         \n"
    "    str za[w12, 3], [x1, 3, MUL VL]                         \n"
    "    str za[w12, 4], [x1, 4, MUL VL]                         \n"
    "    str za[w12, 5], [x1, 5, MUL VL]                         \n"
    "    str za[w12, 6], [x1, 6, MUL VL]                         \n"
    "    str za[w12, 7], [x1, 7, MUL VL]                         \n"
    "    str za[w12, 8], [x1, 8, MUL VL]                         \n"
    "    str za[w12, 9], [x1, 9, MUL VL]                         \n"
    "    str za[w12, 10], [x1, 10, MUL VL]                       \n"
    "    str za[w12, 11], [x1, 11, MUL VL]                       \n"
    "    str za[w12, 12], [x1, 12, MUL VL]                       \n"
    "    str za[w12, 13], [x1, 13, MUL VL]                       \n"
    "    str za[w12, 14], [x1, 14, MUL VL]                       \n"
    "    str za[w12, 15], [x1, 15, MUL VL]                       \n"
    "                                                            \n"
    "    add x1, x1, #1024                                       \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    str za[w12, 0], [x1, 0, MUL VL]                         \n"
    "    add x1, x1, #64                                         \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [dst] "r" (data->dst), [end] "r" (data->dst + data->size), [end_aligned] "r" (data->dst + size_aligned)
    : "x0", "x1", "x12"
  );

  //printf("done store_za_vector_x1_ilp16\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double copy_za_vector_x1_ilp1(const void* args) {
  // LDR/STR (ZA vector)
  //
  // Bytes per instruction: 64, bytes per loop iteration: 64 (ILP=1)
  const benchmark_data_t* data = args;

  //printf("starting copy_za_vector_x1_ilp1\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x12, #0                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  mov x2, %[dst]                                            \n"
    "  2:                                                        \n"
    "    ldr za[w12, 0], [x1, 0, MUL VL]                         \n"
    "                                                            \n"
    "    str za[w12, 0], [x2, 0, MUL VL]                         \n"
    "                                                            \n"
    "    add x1, x1, #64                                         \n"
    "    add x2, x2, #64                                         \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 2b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [dst] "r" (data->dst), [end] "r" (data->src + data->size)
    : "x0", "x1", "x2", "x12"
  );

  //printf("done copy_za_vector_x1_ilp1\n");

  // number of bytes transferred overall
  return 2.0*data->total_size;
}


static double copy_za_vector_x1_ilp2(const void* args) {
  // LDR/STR (ZA vector)
  //
  // Bytes per instruction: 64, bytes per loop iteration: 128 (ILP=2)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 128);

  //printf("starting copy_za_vector_x1_ilp2\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x12, #0                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  mov x2, %[dst]                                            \n"
    "  2:                                                        \n"
    "    ldr za[w12, 0], [x1, 0, MUL VL]                         \n"
    "    ldr za[w12, 1], [x1, 1, MUL VL]                         \n"
    "                                                            \n"
    "    str za[w12, 0], [x2, 0, MUL VL]                         \n"
    "    str za[w12, 1], [x2, 1, MUL VL]                         \n"
    "                                                            \n"
    "    add x1, x1, #128                                        \n"
    "    add x2, x2, #128                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    ldr za[w12, 0], [x1, 0, MUL VL]                         \n"
    "    add x1, x1, #64                                         \n"
    "    str za[w12, 0], [x2, 0, MUL VL]                         \n"
    "    add x2, x2, #64                                         \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [dst] "r" (data->dst), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1", "x2", "x12"
  );

  //printf("done copy_za_vector_x1_ilp2\n");

  // number of bytes transferred overall
  return 2.0*data->total_size;
}


static double copy_za_vector_x1_ilp3(const void* args) {
  // LDR/STR (ZA vector)
  //
  // Bytes per instruction: 64, bytes per loop iteration: 192 (ILP=3)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 192);

  //printf("starting copy_za_vector_x1_ilp3\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x12, #0                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  mov x2, %[dst]                                            \n"
    "  2:                                                        \n"
    "    ldr za[w12, 0], [x1, 0, MUL VL]                         \n"
    "    ldr za[w12, 1], [x1, 1, MUL VL]                         \n"
    "    ldr za[w12, 2], [x1, 2, MUL VL]                         \n"
    "                                                            \n"
    "    str za[w12, 0], [x2, 0, MUL VL]                         \n"
    "    str za[w12, 1], [x2, 1, MUL VL]                         \n"
    "    str za[w12, 2], [x2, 2, MUL VL]                         \n"
    "                                                            \n"
    "    add x1, x1, #192                                        \n"
    "    add x2, x2, #192                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    ldr za[w12, 0], [x1, 0, MUL VL]                         \n"
    "    add x1, x1, #64                                         \n"
    "    str za[w12, 0], [x2, 0, MUL VL]                         \n"
    "    add x2, x2, #64                                         \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [dst] "r" (data->dst), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1", "x2", "x12"
  );

  //printf("done copy_za_vector_x1_ilp3\n");

  // number of bytes transferred overall
  return 2.0*data->total_size;
}


static double copy_za_vector_x1_ilp4(const void* args) {
  // LDR/STR (ZA vector)
  //
  // Bytes per instruction: 64, bytes per loop iteration: 256 (ILP=4)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 256);

  //printf("starting copy_za_vector_x1_ilp4\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x12, #0                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  mov x2, %[dst]                                            \n"
    "  2:                                                        \n"
    "    ldr za[w12, 0], [x1, 0, MUL VL]                         \n"
    "    ldr za[w12, 1], [x1, 1, MUL VL]                         \n"
    "    ldr za[w12, 2], [x1, 2, MUL VL]                         \n"
    "    ldr za[w12, 3], [x1, 3, MUL VL]                         \n"
    "                                                            \n"
    "    str za[w12, 0], [x2, 0, MUL VL]                         \n"
    "    str za[w12, 1], [x2, 1, MUL VL]                         \n"
    "    str za[w12, 2], [x2, 2, MUL VL]                         \n"
    "    str za[w12, 3], [x2, 3, MUL VL]                         \n"
    "                                                            \n"
    "    add x1, x1, #256                                        \n"
    "    add x2, x2, #256                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    ldr za[w12, 0], [x1, 0, MUL VL]                         \n"
    "    add x1, x1, #64                                         \n"
    "    str za[w12, 0], [x2, 0, MUL VL]                         \n"
    "    add x2, x2, #64                                         \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [dst] "r" (data->dst), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1", "x2", "x12"
  );

  //printf("done copy_za_vector_x1_ilp4\n");

  // number of bytes transferred overall
  return 2.0*data->total_size;
}


static double copy_za_vector_x1_ilp5(const void* args) {
  // LDR/STR (ZA vector)
  //
  // Bytes per instruction: 64, bytes per loop iteration: 320 (ILP=5)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 320);

  //printf("starting copy_za_vector_x1_ilp5\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x12, #0                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  mov x2, %[dst]                                            \n"
    "  2:                                                        \n"
    "    ldr za[w12, 0], [x1, 0, MUL VL]                         \n"
    "    ldr za[w12, 1], [x1, 1, MUL VL]                         \n"
    "    ldr za[w12, 2], [x1, 2, MUL VL]                         \n"
    "    ldr za[w12, 3], [x1, 3, MUL VL]                         \n"
    "    ldr za[w12, 4], [x1, 4, MUL VL]                         \n"
    "                                                            \n"
    "    str za[w12, 0], [x2, 0, MUL VL]                         \n"
    "    str za[w12, 1], [x2, 1, MUL VL]                         \n"
    "    str za[w12, 2], [x2, 2, MUL VL]                         \n"
    "    str za[w12, 3], [x2, 3, MUL VL]                         \n"
    "    str za[w12, 4], [x2, 4, MUL VL]                         \n"
    "                                                            \n"
    "    add x1, x1, #320                                        \n"
    "    add x2, x2, #320                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    ldr za[w12, 0], [x1, 0, MUL VL]                         \n"
    "    add x1, x1, #64                                         \n"
    "    str za[w12, 0], [x2, 0, MUL VL]                         \n"
    "    add x2, x2, #64                                         \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [dst] "r" (data->dst), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1", "x2", "x12"
  );

  //printf("done copy_za_vector_x1_ilp5\n");

  // number of bytes transferred overall
  return 2.0*data->total_size;
}


static double copy_za_vector_x1_ilp6(const void* args) {
  // LDR/STR (ZA vector)
  //
  // Bytes per instruction: 64, bytes per loop iteration: 384 (ILP=6)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 384);

  //printf("starting copy_za_vector_x1_ilp6\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x12, #0                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  mov x2, %[dst]                                            \n"
    "  2:                                                        \n"
    "    ldr za[w12, 0], [x1, 0, MUL VL]                         \n"
    "    ldr za[w12, 1], [x1, 1, MUL VL]                         \n"
    "    ldr za[w12, 2], [x1, 2, MUL VL]                         \n"
    "    ldr za[w12, 3], [x1, 3, MUL VL]                         \n"
    "    ldr za[w12, 4], [x1, 4, MUL VL]                         \n"
    "    ldr za[w12, 5], [x1, 5, MUL VL]                         \n"
    "                                                            \n"
    "    str za[w12, 0], [x2, 0, MUL VL]                         \n"
    "    str za[w12, 1], [x2, 1, MUL VL]                         \n"
    "    str za[w12, 2], [x2, 2, MUL VL]                         \n"
    "    str za[w12, 3], [x2, 3, MUL VL]                         \n"
    "    str za[w12, 4], [x2, 4, MUL VL]                         \n"
    "    str za[w12, 5], [x2, 5, MUL VL]                         \n"
    "                                                            \n"
    "    add x1, x1, #384                                        \n"
    "    add x2, x2, #384                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    ldr za[w12, 0], [x1, 0, MUL VL]                         \n"
    "    add x1, x1, #64                                         \n"
    "    str za[w12, 0], [x2, 0, MUL VL]                         \n"
    "    add x2, x2, #64                                         \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [dst] "r" (data->dst), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1", "x2", "x12"
  );

  //printf("done copy_za_vector_x1_ilp6\n");

  // number of bytes transferred overall
  return 2.0*data->total_size;
}


static double copy_za_vector_x1_ilp7(const void* args) {
  // LDR/STR (ZA vector)
  //
  // Bytes per instruction: 64, bytes per loop iteration: 448 (ILP=7)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 448);

  //printf("starting copy_za_vector_x1_ilp7\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x12, #0                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  mov x2, %[dst]                                            \n"
    "  2:                                                        \n"
    "    ldr za[w12, 0], [x1, 0, MUL VL]                         \n"
    "    ldr za[w12, 1], [x1, 1, MUL VL]                         \n"
    "    ldr za[w12, 2], [x1, 2, MUL VL]                         \n"
    "    ldr za[w12, 3], [x1, 3, MUL VL]                         \n"
    "    ldr za[w12, 4], [x1, 4, MUL VL]                         \n"
    "    ldr za[w12, 5], [x1, 5, MUL VL]                         \n"
    "    ldr za[w12, 6], [x1, 6, MUL VL]                         \n"
    "                                                            \n"
    "    str za[w12, 0], [x2, 0, MUL VL]                         \n"
    "    str za[w12, 1], [x2, 1, MUL VL]                         \n"
    "    str za[w12, 2], [x2, 2, MUL VL]                         \n"
    "    str za[w12, 3], [x2, 3, MUL VL]                         \n"
    "    str za[w12, 4], [x2, 4, MUL VL]                         \n"
    "    str za[w12, 5], [x2, 5, MUL VL]                         \n"
    "    str za[w12, 6], [x2, 6, MUL VL]                         \n"
    "                                                            \n"
    "    add x1, x1, #448                                        \n"
    "    add x2, x2, #448                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    ldr za[w12, 0], [x1, 0, MUL VL]                         \n"
    "    add x1, x1, #64                                         \n"
    "    str za[w12, 0], [x2, 0, MUL VL]                         \n"
    "    add x2, x2, #64                                         \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [dst] "r" (data->dst), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1", "x2", "x12"
  );

  //printf("done copy_za_vector_x1_ilp7\n");

  // number of bytes transferred overall
  return 2.0*data->total_size;
}


static double copy_za_vector_x1_ilp8(const void* args) {
  // LDR/STR (ZA vector)
  //
  // Bytes per instruction: 64, bytes per loop iteration: 512 (ILP=8)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 512);

  //printf("starting copy_za_vector_x1_ilp8\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x12, #0                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  mov x2, %[dst]                                            \n"
    "  2:                                                        \n"
    "    ldr za[w12, 0], [x1, 0, MUL VL]                         \n"
    "    ldr za[w12, 1], [x1, 1, MUL VL]                         \n"
    "    ldr za[w12, 2], [x1, 2, MUL VL]                         \n"
    "    ldr za[w12, 3], [x1, 3, MUL VL]                         \n"
    "    ldr za[w12, 4], [x1, 4, MUL VL]                         \n"
    "    ldr za[w12, 5], [x1, 5, MUL VL]                         \n"
    "    ldr za[w12, 6], [x1, 6, MUL VL]                         \n"
    "    ldr za[w12, 7], [x1, 7, MUL VL]                         \n"
    "                                                            \n"
    "    str za[w12, 0], [x2, 0, MUL VL]                         \n"
    "    str za[w12, 1], [x2, 1, MUL VL]                         \n"
    "    str za[w12, 2], [x2, 2, MUL VL]                         \n"
    "    str za[w12, 3], [x2, 3, MUL VL]                         \n"
    "    str za[w12, 4], [x2, 4, MUL VL]                         \n"
    "    str za[w12, 5], [x2, 5, MUL VL]                         \n"
    "    str za[w12, 6], [x2, 6, MUL VL]                         \n"
    "    str za[w12, 7], [x2, 7, MUL VL]                         \n"
    "                                                            \n"
    "    add x1, x1, #512                                        \n"
    "    add x2, x2, #512                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    ldr za[w12, 0], [x1, 0, MUL VL]                         \n"
    "    add x1, x1, #64                                         \n"
    "    str za[w12, 0], [x2, 0, MUL VL]                         \n"
    "    add x2, x2, #64                                         \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [dst] "r" (data->dst), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1", "x2", "x12"
  );

  //printf("done copy_za_vector_x1_ilp8\n");

  // number of bytes transferred overall
  return 2.0*data->total_size;
}


static double copy_za_vector_x1_ilp9(const void* args) {
  // LDR/STR (ZA vector)
  //
  // Bytes per instruction: 64, bytes per loop iteration: 576 (ILP=9)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 576);

  //printf("starting copy_za_vector_x1_ilp9\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x12, #0                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  mov x2, %[dst]                                            \n"
    "  2:                                                        \n"
    "    ldr za[w12, 0], [x1, 0, MUL VL]                         \n"
    "    ldr za[w12, 1], [x1, 1, MUL VL]                         \n"
    "    ldr za[w12, 2], [x1, 2, MUL VL]                         \n"
    "    ldr za[w12, 3], [x1, 3, MUL VL]                         \n"
    "    ldr za[w12, 4], [x1, 4, MUL VL]                         \n"
    "    ldr za[w12, 5], [x1, 5, MUL VL]                         \n"
    "    ldr za[w12, 6], [x1, 6, MUL VL]                         \n"
    "    ldr za[w12, 7], [x1, 7, MUL VL]                         \n"
    "    ldr za[w12, 8], [x1, 8, MUL VL]                         \n"
    "                                                            \n"
    "    str za[w12, 0], [x2, 0, MUL VL]                         \n"
    "    str za[w12, 1], [x2, 1, MUL VL]                         \n"
    "    str za[w12, 2], [x2, 2, MUL VL]                         \n"
    "    str za[w12, 3], [x2, 3, MUL VL]                         \n"
    "    str za[w12, 4], [x2, 4, MUL VL]                         \n"
    "    str za[w12, 5], [x2, 5, MUL VL]                         \n"
    "    str za[w12, 6], [x2, 6, MUL VL]                         \n"
    "    str za[w12, 7], [x2, 7, MUL VL]                         \n"
    "    str za[w12, 8], [x2, 8, MUL VL]                         \n"
    "                                                            \n"
    "    add x1, x1, #576                                        \n"
    "    add x2, x2, #576                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    ldr za[w12, 0], [x1, 0, MUL VL]                         \n"
    "    add x1, x1, #64                                         \n"
    "    str za[w12, 0], [x2, 0, MUL VL]                         \n"
    "    add x2, x2, #64                                         \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [dst] "r" (data->dst), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1", "x2", "x12"
  );

  //printf("done copy_za_vector_x1_ilp9\n");

  // number of bytes transferred overall
  return 2.0*data->total_size;
}


static double copy_za_vector_x1_ilp10(const void* args) {
  // LDR/STR (ZA vector)
  //
  // Bytes per instruction: 64, bytes per loop iteration: 640 (ILP=10)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 640);

  //printf("starting copy_za_vector_x1_ilp10\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x12, #0                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  mov x2, %[dst]                                            \n"
    "  2:                                                        \n"
    "    ldr za[w12, 0], [x1, 0, MUL VL]                         \n"
    "    ldr za[w12, 1], [x1, 1, MUL VL]                         \n"
    "    ldr za[w12, 2], [x1, 2, MUL VL]                         \n"
    "    ldr za[w12, 3], [x1, 3, MUL VL]                         \n"
    "    ldr za[w12, 4], [x1, 4, MUL VL]                         \n"
    "    ldr za[w12, 5], [x1, 5, MUL VL]                         \n"
    "    ldr za[w12, 6], [x1, 6, MUL VL]                         \n"
    "    ldr za[w12, 7], [x1, 7, MUL VL]                         \n"
    "    ldr za[w12, 8], [x1, 8, MUL VL]                         \n"
    "    ldr za[w12, 9], [x1, 9, MUL VL]                         \n"
    "                                                            \n"
    "    str za[w12, 0], [x2, 0, MUL VL]                         \n"
    "    str za[w12, 1], [x2, 1, MUL VL]                         \n"
    "    str za[w12, 2], [x2, 2, MUL VL]                         \n"
    "    str za[w12, 3], [x2, 3, MUL VL]                         \n"
    "    str za[w12, 4], [x2, 4, MUL VL]                         \n"
    "    str za[w12, 5], [x2, 5, MUL VL]                         \n"
    "    str za[w12, 6], [x2, 6, MUL VL]                         \n"
    "    str za[w12, 7], [x2, 7, MUL VL]                         \n"
    "    str za[w12, 8], [x2, 8, MUL VL]                         \n"
    "    str za[w12, 9], [x2, 9, MUL VL]                         \n"
    "                                                            \n"
    "    add x1, x1, #640                                        \n"
    "    add x2, x2, #640                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    ldr za[w12, 0], [x1, 0, MUL VL]                         \n"
    "    add x1, x1, #64                                         \n"
    "    str za[w12, 0], [x2, 0, MUL VL]                         \n"
    "    add x2, x2, #64                                         \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [dst] "r" (data->dst), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1", "x2", "x12"
  );

  //printf("done copy_za_vector_x1_ilp10\n");

  // number of bytes transferred overall
  return 2.0*data->total_size;
}


static double copy_za_vector_x1_ilp11(const void* args) {
  // LDR/STR (ZA vector)
  //
  // Bytes per instruction: 64, bytes per loop iteration: 704 (ILP=11)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 704);

  //printf("starting copy_za_vector_x1_ilp11\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x12, #0                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  mov x2, %[dst]                                            \n"
    "  2:                                                        \n"
    "    ldr za[w12, 0], [x1, 0, MUL VL]                         \n"
    "    ldr za[w12, 1], [x1, 1, MUL VL]                         \n"
    "    ldr za[w12, 2], [x1, 2, MUL VL]                         \n"
    "    ldr za[w12, 3], [x1, 3, MUL VL]                         \n"
    "    ldr za[w12, 4], [x1, 4, MUL VL]                         \n"
    "    ldr za[w12, 5], [x1, 5, MUL VL]                         \n"
    "    ldr za[w12, 6], [x1, 6, MUL VL]                         \n"
    "    ldr za[w12, 7], [x1, 7, MUL VL]                         \n"
    "    ldr za[w12, 8], [x1, 8, MUL VL]                         \n"
    "    ldr za[w12, 9], [x1, 9, MUL VL]                         \n"
    "    ldr za[w12, 10], [x1, 10, MUL VL]                       \n"
    "                                                            \n"
    "    str za[w12, 0], [x2, 0, MUL VL]                         \n"
    "    str za[w12, 1], [x2, 1, MUL VL]                         \n"
    "    str za[w12, 2], [x2, 2, MUL VL]                         \n"
    "    str za[w12, 3], [x2, 3, MUL VL]                         \n"
    "    str za[w12, 4], [x2, 4, MUL VL]                         \n"
    "    str za[w12, 5], [x2, 5, MUL VL]                         \n"
    "    str za[w12, 6], [x2, 6, MUL VL]                         \n"
    "    str za[w12, 7], [x2, 7, MUL VL]                         \n"
    "    str za[w12, 8], [x2, 8, MUL VL]                         \n"
    "    str za[w12, 9], [x2, 9, MUL VL]                         \n"
    "    str za[w12, 10], [x2, 10, MUL VL]                       \n"
    "                                                            \n"
    "    add x1, x1, #704                                        \n"
    "    add x2, x2, #704                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    ldr za[w12, 0], [x1, 0, MUL VL]                         \n"
    "    add x1, x1, #64                                         \n"
    "    str za[w12, 0], [x2, 0, MUL VL]                         \n"
    "    add x2, x2, #64                                         \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [dst] "r" (data->dst), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1", "x2", "x12"
  );

  //printf("done copy_za_vector_x1_ilp11\n");

  // number of bytes transferred overall
  return 2.0*data->total_size;
}


static double copy_za_vector_x1_ilp12(const void* args) {
  // LDR/STR (ZA vector)
  //
  // Bytes per instruction: 64, bytes per loop iteration: 768 (ILP=12)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 768);

  //printf("starting copy_za_vector_x1_ilp12\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x12, #0                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  mov x2, %[dst]                                            \n"
    "  2:                                                        \n"
    "    ldr za[w12, 0], [x1, 0, MUL VL]                         \n"
    "    ldr za[w12, 1], [x1, 1, MUL VL]                         \n"
    "    ldr za[w12, 2], [x1, 2, MUL VL]                         \n"
    "    ldr za[w12, 3], [x1, 3, MUL VL]                         \n"
    "    ldr za[w12, 4], [x1, 4, MUL VL]                         \n"
    "    ldr za[w12, 5], [x1, 5, MUL VL]                         \n"
    "    ldr za[w12, 6], [x1, 6, MUL VL]                         \n"
    "    ldr za[w12, 7], [x1, 7, MUL VL]                         \n"
    "    ldr za[w12, 8], [x1, 8, MUL VL]                         \n"
    "    ldr za[w12, 9], [x1, 9, MUL VL]                         \n"
    "    ldr za[w12, 10], [x1, 10, MUL VL]                       \n"
    "    ldr za[w12, 11], [x1, 11, MUL VL]                       \n"
    "                                                            \n"
    "    str za[w12, 0], [x2, 0, MUL VL]                         \n"
    "    str za[w12, 1], [x2, 1, MUL VL]                         \n"
    "    str za[w12, 2], [x2, 2, MUL VL]                         \n"
    "    str za[w12, 3], [x2, 3, MUL VL]                         \n"
    "    str za[w12, 4], [x2, 4, MUL VL]                         \n"
    "    str za[w12, 5], [x2, 5, MUL VL]                         \n"
    "    str za[w12, 6], [x2, 6, MUL VL]                         \n"
    "    str za[w12, 7], [x2, 7, MUL VL]                         \n"
    "    str za[w12, 8], [x2, 8, MUL VL]                         \n"
    "    str za[w12, 9], [x2, 9, MUL VL]                         \n"
    "    str za[w12, 10], [x2, 10, MUL VL]                       \n"
    "    str za[w12, 11], [x2, 11, MUL VL]                       \n"
    "                                                            \n"
    "    add x1, x1, #768                                        \n"
    "    add x2, x2, #768                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    ldr za[w12, 0], [x1, 0, MUL VL]                         \n"
    "    add x1, x1, #64                                         \n"
    "    str za[w12, 0], [x2, 0, MUL VL]                         \n"
    "    add x2, x2, #64                                         \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [dst] "r" (data->dst), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1", "x2", "x12"
  );

  //printf("done copy_za_vector_x1_ilp12\n");

  // number of bytes transferred overall
  return 2.0*data->total_size;
}


static double copy_za_vector_x1_ilp13(const void* args) {
  // LDR/STR (ZA vector)
  //
  // Bytes per instruction: 64, bytes per loop iteration: 832 (ILP=13)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 832);

  //printf("starting copy_za_vector_x1_ilp13\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x12, #0                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  mov x2, %[dst]                                            \n"
    "  2:                                                        \n"
    "    ldr za[w12, 0], [x1, 0, MUL VL]                         \n"
    "    ldr za[w12, 1], [x1, 1, MUL VL]                         \n"
    "    ldr za[w12, 2], [x1, 2, MUL VL]                         \n"
    "    ldr za[w12, 3], [x1, 3, MUL VL]                         \n"
    "    ldr za[w12, 4], [x1, 4, MUL VL]                         \n"
    "    ldr za[w12, 5], [x1, 5, MUL VL]                         \n"
    "    ldr za[w12, 6], [x1, 6, MUL VL]                         \n"
    "    ldr za[w12, 7], [x1, 7, MUL VL]                         \n"
    "    ldr za[w12, 8], [x1, 8, MUL VL]                         \n"
    "    ldr za[w12, 9], [x1, 9, MUL VL]                         \n"
    "    ldr za[w12, 10], [x1, 10, MUL VL]                       \n"
    "    ldr za[w12, 11], [x1, 11, MUL VL]                       \n"
    "    ldr za[w12, 12], [x1, 12, MUL VL]                       \n"
    "                                                            \n"
    "    str za[w12, 0], [x2, 0, MUL VL]                         \n"
    "    str za[w12, 1], [x2, 1, MUL VL]                         \n"
    "    str za[w12, 2], [x2, 2, MUL VL]                         \n"
    "    str za[w12, 3], [x2, 3, MUL VL]                         \n"
    "    str za[w12, 4], [x2, 4, MUL VL]                         \n"
    "    str za[w12, 5], [x2, 5, MUL VL]                         \n"
    "    str za[w12, 6], [x2, 6, MUL VL]                         \n"
    "    str za[w12, 7], [x2, 7, MUL VL]                         \n"
    "    str za[w12, 8], [x2, 8, MUL VL]                         \n"
    "    str za[w12, 9], [x2, 9, MUL VL]                         \n"
    "    str za[w12, 10], [x2, 10, MUL VL]                       \n"
    "    str za[w12, 11], [x2, 11, MUL VL]                       \n"
    "    str za[w12, 12], [x2, 12, MUL VL]                       \n"
    "                                                            \n"
    "    add x1, x1, #832                                        \n"
    "    add x2, x2, #832                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    ldr za[w12, 0], [x1, 0, MUL VL]                         \n"
    "    add x1, x1, #64                                         \n"
    "    str za[w12, 0], [x2, 0, MUL VL]                         \n"
    "    add x2, x2, #64                                         \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [dst] "r" (data->dst), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1", "x2", "x12"
  );

  //printf("done copy_za_vector_x1_ilp13\n");

  // number of bytes transferred overall
  return 2.0*data->total_size;
}


static double copy_za_vector_x1_ilp14(const void* args) {
  // LDR/STR (ZA vector)
  //
  // Bytes per instruction: 64, bytes per loop iteration: 896 (ILP=14)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 896);

  //printf("starting copy_za_vector_x1_ilp14\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x12, #0                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  mov x2, %[dst]                                            \n"
    "  2:                                                        \n"
    "    ldr za[w12, 0], [x1, 0, MUL VL]                         \n"
    "    ldr za[w12, 1], [x1, 1, MUL VL]                         \n"
    "    ldr za[w12, 2], [x1, 2, MUL VL]                         \n"
    "    ldr za[w12, 3], [x1, 3, MUL VL]                         \n"
    "    ldr za[w12, 4], [x1, 4, MUL VL]                         \n"
    "    ldr za[w12, 5], [x1, 5, MUL VL]                         \n"
    "    ldr za[w12, 6], [x1, 6, MUL VL]                         \n"
    "    ldr za[w12, 7], [x1, 7, MUL VL]                         \n"
    "    ldr za[w12, 8], [x1, 8, MUL VL]                         \n"
    "    ldr za[w12, 9], [x1, 9, MUL VL]                         \n"
    "    ldr za[w12, 10], [x1, 10, MUL VL]                       \n"
    "    ldr za[w12, 11], [x1, 11, MUL VL]                       \n"
    "    ldr za[w12, 12], [x1, 12, MUL VL]                       \n"
    "    ldr za[w12, 13], [x1, 13, MUL VL]                       \n"
    "                                                            \n"
    "    str za[w12, 0], [x2, 0, MUL VL]                         \n"
    "    str za[w12, 1], [x2, 1, MUL VL]                         \n"
    "    str za[w12, 2], [x2, 2, MUL VL]                         \n"
    "    str za[w12, 3], [x2, 3, MUL VL]                         \n"
    "    str za[w12, 4], [x2, 4, MUL VL]                         \n"
    "    str za[w12, 5], [x2, 5, MUL VL]                         \n"
    "    str za[w12, 6], [x2, 6, MUL VL]                         \n"
    "    str za[w12, 7], [x2, 7, MUL VL]                         \n"
    "    str za[w12, 8], [x2, 8, MUL VL]                         \n"
    "    str za[w12, 9], [x2, 9, MUL VL]                         \n"
    "    str za[w12, 10], [x2, 10, MUL VL]                       \n"
    "    str za[w12, 11], [x2, 11, MUL VL]                       \n"
    "    str za[w12, 12], [x2, 12, MUL VL]                       \n"
    "    str za[w12, 13], [x2, 13, MUL VL]                       \n"
    "                                                            \n"
    "    add x1, x1, #896                                        \n"
    "    add x2, x2, #896                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    ldr za[w12, 0], [x1, 0, MUL VL]                         \n"
    "    add x1, x1, #64                                         \n"
    "    str za[w12, 0], [x2, 0, MUL VL]                         \n"
    "    add x2, x2, #64                                         \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [dst] "r" (data->dst), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1", "x2", "x12"
  );

  //printf("done copy_za_vector_x1_ilp14\n");

  // number of bytes transferred overall
  return 2.0*data->total_size;
}


static double copy_za_vector_x1_ilp15(const void* args) {
  // LDR/STR (ZA vector)
  //
  // Bytes per instruction: 64, bytes per loop iteration: 960 (ILP=15)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 960);

  //printf("starting copy_za_vector_x1_ilp15\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x12, #0                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  mov x2, %[dst]                                            \n"
    "  2:                                                        \n"
    "    ldr za[w12, 0], [x1, 0, MUL VL]                         \n"
    "    ldr za[w12, 1], [x1, 1, MUL VL]                         \n"
    "    ldr za[w12, 2], [x1, 2, MUL VL]                         \n"
    "    ldr za[w12, 3], [x1, 3, MUL VL]                         \n"
    "    ldr za[w12, 4], [x1, 4, MUL VL]                         \n"
    "    ldr za[w12, 5], [x1, 5, MUL VL]                         \n"
    "    ldr za[w12, 6], [x1, 6, MUL VL]                         \n"
    "    ldr za[w12, 7], [x1, 7, MUL VL]                         \n"
    "    ldr za[w12, 8], [x1, 8, MUL VL]                         \n"
    "    ldr za[w12, 9], [x1, 9, MUL VL]                         \n"
    "    ldr za[w12, 10], [x1, 10, MUL VL]                       \n"
    "    ldr za[w12, 11], [x1, 11, MUL VL]                       \n"
    "    ldr za[w12, 12], [x1, 12, MUL VL]                       \n"
    "    ldr za[w12, 13], [x1, 13, MUL VL]                       \n"
    "    ldr za[w12, 14], [x1, 14, MUL VL]                       \n"
    "                                                            \n"
    "    str za[w12, 0], [x2, 0, MUL VL]                         \n"
    "    str za[w12, 1], [x2, 1, MUL VL]                         \n"
    "    str za[w12, 2], [x2, 2, MUL VL]                         \n"
    "    str za[w12, 3], [x2, 3, MUL VL]                         \n"
    "    str za[w12, 4], [x2, 4, MUL VL]                         \n"
    "    str za[w12, 5], [x2, 5, MUL VL]                         \n"
    "    str za[w12, 6], [x2, 6, MUL VL]                         \n"
    "    str za[w12, 7], [x2, 7, MUL VL]                         \n"
    "    str za[w12, 8], [x2, 8, MUL VL]                         \n"
    "    str za[w12, 9], [x2, 9, MUL VL]                         \n"
    "    str za[w12, 10], [x2, 10, MUL VL]                       \n"
    "    str za[w12, 11], [x2, 11, MUL VL]                       \n"
    "    str za[w12, 12], [x2, 12, MUL VL]                       \n"
    "    str za[w12, 13], [x2, 13, MUL VL]                       \n"
    "    str za[w12, 14], [x2, 14, MUL VL]                       \n"
    "                                                            \n"
    "    add x1, x1, #960                                        \n"
    "    add x2, x2, #960                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    ldr za[w12, 0], [x1, 0, MUL VL]                         \n"
    "    add x1, x1, #64                                         \n"
    "    str za[w12, 0], [x2, 0, MUL VL]                         \n"
    "    add x2, x2, #64                                         \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [dst] "r" (data->dst), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1", "x2", "x12"
  );

  //printf("done copy_za_vector_x1_ilp15\n");

  // number of bytes transferred overall
  return 2.0*data->total_size;
}


static double copy_za_vector_x1_ilp16(const void* args) {
  // LDR/STR (ZA vector)
  //
  // Bytes per instruction: 64, bytes per loop iteration: 1024 (ILP=16)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 1024);

  //printf("starting copy_za_vector_x1_ilp16\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x12, #0                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  mov x2, %[dst]                                            \n"
    "  2:                                                        \n"
    "    ldr za[w12, 0], [x1, 0, MUL VL]                         \n"
    "    ldr za[w12, 1], [x1, 1, MUL VL]                         \n"
    "    ldr za[w12, 2], [x1, 2, MUL VL]                         \n"
    "    ldr za[w12, 3], [x1, 3, MUL VL]                         \n"
    "    ldr za[w12, 4], [x1, 4, MUL VL]                         \n"
    "    ldr za[w12, 5], [x1, 5, MUL VL]                         \n"
    "    ldr za[w12, 6], [x1, 6, MUL VL]                         \n"
    "    ldr za[w12, 7], [x1, 7, MUL VL]                         \n"
    "    ldr za[w12, 8], [x1, 8, MUL VL]                         \n"
    "    ldr za[w12, 9], [x1, 9, MUL VL]                         \n"
    "    ldr za[w12, 10], [x1, 10, MUL VL]                       \n"
    "    ldr za[w12, 11], [x1, 11, MUL VL]                       \n"
    "    ldr za[w12, 12], [x1, 12, MUL VL]                       \n"
    "    ldr za[w12, 13], [x1, 13, MUL VL]                       \n"
    "    ldr za[w12, 14], [x1, 14, MUL VL]                       \n"
    "    ldr za[w12, 15], [x1, 15, MUL VL]                       \n"
    "                                                            \n"
    "    str za[w12, 0], [x2, 0, MUL VL]                         \n"
    "    str za[w12, 1], [x2, 1, MUL VL]                         \n"
    "    str za[w12, 2], [x2, 2, MUL VL]                         \n"
    "    str za[w12, 3], [x2, 3, MUL VL]                         \n"
    "    str za[w12, 4], [x2, 4, MUL VL]                         \n"
    "    str za[w12, 5], [x2, 5, MUL VL]                         \n"
    "    str za[w12, 6], [x2, 6, MUL VL]                         \n"
    "    str za[w12, 7], [x2, 7, MUL VL]                         \n"
    "    str za[w12, 8], [x2, 8, MUL VL]                         \n"
    "    str za[w12, 9], [x2, 9, MUL VL]                         \n"
    "    str za[w12, 10], [x2, 10, MUL VL]                       \n"
    "    str za[w12, 11], [x2, 11, MUL VL]                       \n"
    "    str za[w12, 12], [x2, 12, MUL VL]                       \n"
    "    str za[w12, 13], [x2, 13, MUL VL]                       \n"
    "    str za[w12, 14], [x2, 14, MUL VL]                       \n"
    "    str za[w12, 15], [x2, 15, MUL VL]                       \n"
    "                                                            \n"
    "    add x1, x1, #1024                                       \n"
    "    add x2, x2, #1024                                       \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    ldr za[w12, 0], [x1, 0, MUL VL]                         \n"
    "    add x1, x1, #64                                         \n"
    "    str za[w12, 0], [x2, 0, MUL VL]                         \n"
    "    add x2, x2, #64                                         \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [dst] "r" (data->dst), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1", "x2", "x12"
  );

  //printf("done copy_za_vector_x1_ilp16\n");

  // number of bytes transferred overall
  return 2.0*data->total_size;
}


static double load_reg_adjacent_x1_ilp1(const void* args) {
  // LDR (one register, unpredicated)
  //
  // Bytes per instruction: 64, bytes per loop iteration: 64 (ILP=1)
  const benchmark_data_t* data = args;

  //printf("starting load_reg_adjacent_x1_ilp1\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  2:                                                        \n"
    "    ldr z0, [x1, 0, MUL VL]                                 \n"
    "                                                            \n"
    "    add x1, x1, #64                                         \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 2b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [end] "r" (data->src + data->size)
    : "x0", "x1"
  );

  //printf("done load_reg_adjacent_x1_ilp1\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double load_reg_adjacent_x1_ilp2(const void* args) {
  // LDR (one register, unpredicated)
  //
  // Bytes per instruction: 64, bytes per loop iteration: 128 (ILP=2)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 128);

  //printf("starting load_reg_adjacent_x1_ilp2\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  2:                                                        \n"
    "    ldr z0, [x1, 0, MUL VL]                                 \n"
    "    ldr z1, [x1, 1, MUL VL]                                 \n"
    "                                                            \n"
    "    add x1, x1, #128                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    ldr z0, [x1, 0, MUL VL]                                 \n"
    "    add x1, x1, #64                                         \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1"
  );

  //printf("done load_reg_adjacent_x1_ilp2\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double load_reg_adjacent_x1_ilp3(const void* args) {
  // LDR (one register, unpredicated)
  //
  // Bytes per instruction: 64, bytes per loop iteration: 192 (ILP=3)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 192);

  //printf("starting load_reg_adjacent_x1_ilp3\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  2:                                                        \n"
    "    ldr z0, [x1, 0, MUL VL]                                 \n"
    "    ldr z1, [x1, 1, MUL VL]                                 \n"
    "    ldr z2, [x1, 2, MUL VL]                                 \n"
    "                                                            \n"
    "    add x1, x1, #192                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    ldr z0, [x1, 0, MUL VL]                                 \n"
    "    add x1, x1, #64                                         \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1"
  );

  //printf("done load_reg_adjacent_x1_ilp3\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double load_reg_adjacent_x1_ilp4(const void* args) {
  // LDR (one register, unpredicated)
  //
  // Bytes per instruction: 64, bytes per loop iteration: 256 (ILP=4)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 256);

  //printf("starting load_reg_adjacent_x1_ilp4\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  2:                                                        \n"
    "    ldr z0, [x1, 0, MUL VL]                                 \n"
    "    ldr z1, [x1, 1, MUL VL]                                 \n"
    "    ldr z2, [x1, 2, MUL VL]                                 \n"
    "    ldr z3, [x1, 3, MUL VL]                                 \n"
    "                                                            \n"
    "    add x1, x1, #256                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    ldr z0, [x1, 0, MUL VL]                                 \n"
    "    add x1, x1, #64                                         \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1"
  );

  //printf("done load_reg_adjacent_x1_ilp4\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double load_reg_adjacent_x1_ilp5(const void* args) {
  // LDR (one register, unpredicated)
  //
  // Bytes per instruction: 64, bytes per loop iteration: 320 (ILP=5)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 320);

  //printf("starting load_reg_adjacent_x1_ilp5\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  2:                                                        \n"
    "    ldr z0, [x1, 0, MUL VL]                                 \n"
    "    ldr z1, [x1, 1, MUL VL]                                 \n"
    "    ldr z2, [x1, 2, MUL VL]                                 \n"
    "    ldr z3, [x1, 3, MUL VL]                                 \n"
    "    ldr z4, [x1, 4, MUL VL]                                 \n"
    "                                                            \n"
    "    add x1, x1, #320                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    ldr z0, [x1, 0, MUL VL]                                 \n"
    "    add x1, x1, #64                                         \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1"
  );

  //printf("done load_reg_adjacent_x1_ilp5\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double load_reg_adjacent_x1_ilp6(const void* args) {
  // LDR (one register, unpredicated)
  //
  // Bytes per instruction: 64, bytes per loop iteration: 384 (ILP=6)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 384);

  //printf("starting load_reg_adjacent_x1_ilp6\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  2:                                                        \n"
    "    ldr z0, [x1, 0, MUL VL]                                 \n"
    "    ldr z1, [x1, 1, MUL VL]                                 \n"
    "    ldr z2, [x1, 2, MUL VL]                                 \n"
    "    ldr z3, [x1, 3, MUL VL]                                 \n"
    "    ldr z4, [x1, 4, MUL VL]                                 \n"
    "    ldr z5, [x1, 5, MUL VL]                                 \n"
    "                                                            \n"
    "    add x1, x1, #384                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    ldr z0, [x1, 0, MUL VL]                                 \n"
    "    add x1, x1, #64                                         \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1"
  );

  //printf("done load_reg_adjacent_x1_ilp6\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double load_reg_adjacent_x1_ilp7(const void* args) {
  // LDR (one register, unpredicated)
  //
  // Bytes per instruction: 64, bytes per loop iteration: 448 (ILP=7)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 448);

  //printf("starting load_reg_adjacent_x1_ilp7\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  2:                                                        \n"
    "    ldr z0, [x1, 0, MUL VL]                                 \n"
    "    ldr z1, [x1, 1, MUL VL]                                 \n"
    "    ldr z2, [x1, 2, MUL VL]                                 \n"
    "    ldr z3, [x1, 3, MUL VL]                                 \n"
    "    ldr z4, [x1, 4, MUL VL]                                 \n"
    "    ldr z5, [x1, 5, MUL VL]                                 \n"
    "    ldr z6, [x1, 6, MUL VL]                                 \n"
    "                                                            \n"
    "    add x1, x1, #448                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    ldr z0, [x1, 0, MUL VL]                                 \n"
    "    add x1, x1, #64                                         \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1"
  );

  //printf("done load_reg_adjacent_x1_ilp7\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double load_reg_adjacent_x1_ilp8(const void* args) {
  // LDR (one register, unpredicated)
  //
  // Bytes per instruction: 64, bytes per loop iteration: 512 (ILP=8)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 512);

  //printf("starting load_reg_adjacent_x1_ilp8\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  2:                                                        \n"
    "    ldr z0, [x1, 0, MUL VL]                                 \n"
    "    ldr z1, [x1, 1, MUL VL]                                 \n"
    "    ldr z2, [x1, 2, MUL VL]                                 \n"
    "    ldr z3, [x1, 3, MUL VL]                                 \n"
    "    ldr z4, [x1, 4, MUL VL]                                 \n"
    "    ldr z5, [x1, 5, MUL VL]                                 \n"
    "    ldr z6, [x1, 6, MUL VL]                                 \n"
    "    ldr z7, [x1, 7, MUL VL]                                 \n"
    "                                                            \n"
    "    add x1, x1, #512                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    ldr z0, [x1, 0, MUL VL]                                 \n"
    "    add x1, x1, #64                                         \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1"
  );

  //printf("done load_reg_adjacent_x1_ilp8\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double store_reg_adjacent_x1_ilp1(const void* args) {
  // STR (one register, unpredicated)
  //
  // Bytes per instruction: 64, bytes per loop iteration: 64 (ILP=1)
  const benchmark_data_t* data = args;

  //printf("starting store_reg_adjacent_x1_ilp1\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  mov x1, %[dst]                                            \n"
    "  2:                                                        \n"
    "    str z0, [x1, 0, MUL VL]                                 \n"
    "                                                            \n"
    "    add x1, x1, #64                                         \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 2b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [dst] "r" (data->dst), [end] "r" (data->dst + data->size)
    : "x0", "x1"
  );

  //printf("done store_reg_adjacent_x1_ilp1\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double store_reg_adjacent_x1_ilp2(const void* args) {
  // STR (one register, unpredicated)
  //
  // Bytes per instruction: 64, bytes per loop iteration: 128 (ILP=2)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 128);

  //printf("starting store_reg_adjacent_x1_ilp2\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  mov x1, %[dst]                                            \n"
    "  2:                                                        \n"
    "    str z0, [x1, 0, MUL VL]                                 \n"
    "    str z1, [x1, 1, MUL VL]                                 \n"
    "                                                            \n"
    "    add x1, x1, #128                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    str z0, [x1, 0, MUL VL]                                 \n"
    "    add x1, x1, #64                                         \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [dst] "r" (data->dst), [end] "r" (data->dst + data->size), [end_aligned] "r" (data->dst + size_aligned)
    : "x0", "x1"
  );

  //printf("done store_reg_adjacent_x1_ilp2\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double store_reg_adjacent_x1_ilp3(const void* args) {
  // STR (one register, unpredicated)
  //
  // Bytes per instruction: 64, bytes per loop iteration: 192 (ILP=3)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 192);

  //printf("starting store_reg_adjacent_x1_ilp3\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  mov x1, %[dst]                                            \n"
    "  2:                                                        \n"
    "    str z0, [x1, 0, MUL VL]                                 \n"
    "    str z1, [x1, 1, MUL VL]                                 \n"
    "    str z2, [x1, 2, MUL VL]                                 \n"
    "                                                            \n"
    "    add x1, x1, #192                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    str z0, [x1, 0, MUL VL]                                 \n"
    "    add x1, x1, #64                                         \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [dst] "r" (data->dst), [end] "r" (data->dst + data->size), [end_aligned] "r" (data->dst + size_aligned)
    : "x0", "x1"
  );

  //printf("done store_reg_adjacent_x1_ilp3\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double store_reg_adjacent_x1_ilp4(const void* args) {
  // STR (one register, unpredicated)
  //
  // Bytes per instruction: 64, bytes per loop iteration: 256 (ILP=4)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 256);

  //printf("starting store_reg_adjacent_x1_ilp4\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  mov x1, %[dst]                                            \n"
    "  2:                                                        \n"
    "    str z0, [x1, 0, MUL VL]                                 \n"
    "    str z1, [x1, 1, MUL VL]                                 \n"
    "    str z2, [x1, 2, MUL VL]                                 \n"
    "    str z3, [x1, 3, MUL VL]                                 \n"
    "                                                            \n"
    "    add x1, x1, #256                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    str z0, [x1, 0, MUL VL]                                 \n"
    "    add x1, x1, #64                                         \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [dst] "r" (data->dst), [end] "r" (data->dst + data->size), [end_aligned] "r" (data->dst + size_aligned)
    : "x0", "x1"
  );

  //printf("done store_reg_adjacent_x1_ilp4\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double store_reg_adjacent_x1_ilp5(const void* args) {
  // STR (one register, unpredicated)
  //
  // Bytes per instruction: 64, bytes per loop iteration: 320 (ILP=5)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 320);

  //printf("starting store_reg_adjacent_x1_ilp5\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  mov x1, %[dst]                                            \n"
    "  2:                                                        \n"
    "    str z0, [x1, 0, MUL VL]                                 \n"
    "    str z1, [x1, 1, MUL VL]                                 \n"
    "    str z2, [x1, 2, MUL VL]                                 \n"
    "    str z3, [x1, 3, MUL VL]                                 \n"
    "    str z4, [x1, 4, MUL VL]                                 \n"
    "                                                            \n"
    "    add x1, x1, #320                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    str z0, [x1, 0, MUL VL]                                 \n"
    "    add x1, x1, #64                                         \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [dst] "r" (data->dst), [end] "r" (data->dst + data->size), [end_aligned] "r" (data->dst + size_aligned)
    : "x0", "x1"
  );

  //printf("done store_reg_adjacent_x1_ilp5\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double store_reg_adjacent_x1_ilp6(const void* args) {
  // STR (one register, unpredicated)
  //
  // Bytes per instruction: 64, bytes per loop iteration: 384 (ILP=6)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 384);

  //printf("starting store_reg_adjacent_x1_ilp6\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  mov x1, %[dst]                                            \n"
    "  2:                                                        \n"
    "    str z0, [x1, 0, MUL VL]                                 \n"
    "    str z1, [x1, 1, MUL VL]                                 \n"
    "    str z2, [x1, 2, MUL VL]                                 \n"
    "    str z3, [x1, 3, MUL VL]                                 \n"
    "    str z4, [x1, 4, MUL VL]                                 \n"
    "    str z5, [x1, 5, MUL VL]                                 \n"
    "                                                            \n"
    "    add x1, x1, #384                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    str z0, [x1, 0, MUL VL]                                 \n"
    "    add x1, x1, #64                                         \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [dst] "r" (data->dst), [end] "r" (data->dst + data->size), [end_aligned] "r" (data->dst + size_aligned)
    : "x0", "x1"
  );

  //printf("done store_reg_adjacent_x1_ilp6\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double store_reg_adjacent_x1_ilp7(const void* args) {
  // STR (one register, unpredicated)
  //
  // Bytes per instruction: 64, bytes per loop iteration: 448 (ILP=7)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 448);

  //printf("starting store_reg_adjacent_x1_ilp7\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  mov x1, %[dst]                                            \n"
    "  2:                                                        \n"
    "    str z0, [x1, 0, MUL VL]                                 \n"
    "    str z1, [x1, 1, MUL VL]                                 \n"
    "    str z2, [x1, 2, MUL VL]                                 \n"
    "    str z3, [x1, 3, MUL VL]                                 \n"
    "    str z4, [x1, 4, MUL VL]                                 \n"
    "    str z5, [x1, 5, MUL VL]                                 \n"
    "    str z6, [x1, 6, MUL VL]                                 \n"
    "                                                            \n"
    "    add x1, x1, #448                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    str z0, [x1, 0, MUL VL]                                 \n"
    "    add x1, x1, #64                                         \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [dst] "r" (data->dst), [end] "r" (data->dst + data->size), [end_aligned] "r" (data->dst + size_aligned)
    : "x0", "x1"
  );

  //printf("done store_reg_adjacent_x1_ilp7\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double store_reg_adjacent_x1_ilp8(const void* args) {
  // STR (one register, unpredicated)
  //
  // Bytes per instruction: 64, bytes per loop iteration: 512 (ILP=8)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 512);

  //printf("starting store_reg_adjacent_x1_ilp8\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  mov x1, %[dst]                                            \n"
    "  2:                                                        \n"
    "    str z0, [x1, 0, MUL VL]                                 \n"
    "    str z1, [x1, 1, MUL VL]                                 \n"
    "    str z2, [x1, 2, MUL VL]                                 \n"
    "    str z3, [x1, 3, MUL VL]                                 \n"
    "    str z4, [x1, 4, MUL VL]                                 \n"
    "    str z5, [x1, 5, MUL VL]                                 \n"
    "    str z6, [x1, 6, MUL VL]                                 \n"
    "    str z7, [x1, 7, MUL VL]                                 \n"
    "                                                            \n"
    "    add x1, x1, #512                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    str z0, [x1, 0, MUL VL]                                 \n"
    "    add x1, x1, #64                                         \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [dst] "r" (data->dst), [end] "r" (data->dst + data->size), [end_aligned] "r" (data->dst + size_aligned)
    : "x0", "x1"
  );

  //printf("done store_reg_adjacent_x1_ilp8\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double copy_reg_adjacent_x1_ilp1(const void* args) {
  // LDR/STR (one register, unpredicated)
  //
  // Bytes per instruction: 64, bytes per loop iteration: 64 (ILP=1)
  const benchmark_data_t* data = args;

  //printf("starting copy_reg_adjacent_x1_ilp1\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  mov x2, %[dst]                                            \n"
    "  2:                                                        \n"
    "    ldr z0, [x1, 0, MUL VL]                                 \n"
    "                                                            \n"
    "    str z0, [x2, 0, MUL VL]                                 \n"
    "                                                            \n"
    "    add x1, x1, #64                                         \n"
    "    add x2, x2, #64                                         \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 2b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [dst] "r" (data->dst), [end] "r" (data->src + data->size)
    : "x0", "x1", "x2"
  );

  //printf("done copy_reg_adjacent_x1_ilp1\n");

  // number of bytes transferred overall
  return 2.0*data->total_size;
}


static double copy_reg_adjacent_x1_ilp2(const void* args) {
  // LDR/STR (one register, unpredicated)
  //
  // Bytes per instruction: 64, bytes per loop iteration: 128 (ILP=2)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 128);

  //printf("starting copy_reg_adjacent_x1_ilp2\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  mov x2, %[dst]                                            \n"
    "  2:                                                        \n"
    "    ldr z0, [x1, 0, MUL VL]                                 \n"
    "    ldr z1, [x1, 1, MUL VL]                                 \n"
    "                                                            \n"
    "    str z0, [x2, 0, MUL VL]                                 \n"
    "    str z1, [x2, 1, MUL VL]                                 \n"
    "                                                            \n"
    "    add x1, x1, #128                                        \n"
    "    add x2, x2, #128                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    ldr z0, [x1, 0, MUL VL]                                 \n"
    "    add x1, x1, #64                                         \n"
    "    str z0, [x2, 0, MUL VL]                                 \n"
    "    add x2, x2, #64                                         \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [dst] "r" (data->dst), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1", "x2"
  );

  //printf("done copy_reg_adjacent_x1_ilp2\n");

  // number of bytes transferred overall
  return 2.0*data->total_size;
}


static double copy_reg_adjacent_x1_ilp3(const void* args) {
  // LDR/STR (one register, unpredicated)
  //
  // Bytes per instruction: 64, bytes per loop iteration: 192 (ILP=3)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 192);

  //printf("starting copy_reg_adjacent_x1_ilp3\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  mov x2, %[dst]                                            \n"
    "  2:                                                        \n"
    "    ldr z0, [x1, 0, MUL VL]                                 \n"
    "    ldr z1, [x1, 1, MUL VL]                                 \n"
    "    ldr z2, [x1, 2, MUL VL]                                 \n"
    "                                                            \n"
    "    str z0, [x2, 0, MUL VL]                                 \n"
    "    str z1, [x2, 1, MUL VL]                                 \n"
    "    str z2, [x2, 2, MUL VL]                                 \n"
    "                                                            \n"
    "    add x1, x1, #192                                        \n"
    "    add x2, x2, #192                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    ldr z0, [x1, 0, MUL VL]                                 \n"
    "    add x1, x1, #64                                         \n"
    "    str z0, [x2, 0, MUL VL]                                 \n"
    "    add x2, x2, #64                                         \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [dst] "r" (data->dst), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1", "x2"
  );

  //printf("done copy_reg_adjacent_x1_ilp3\n");

  // number of bytes transferred overall
  return 2.0*data->total_size;
}


static double copy_reg_adjacent_x1_ilp4(const void* args) {
  // LDR/STR (one register, unpredicated)
  //
  // Bytes per instruction: 64, bytes per loop iteration: 256 (ILP=4)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 256);

  //printf("starting copy_reg_adjacent_x1_ilp4\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  mov x2, %[dst]                                            \n"
    "  2:                                                        \n"
    "    ldr z0, [x1, 0, MUL VL]                                 \n"
    "    ldr z1, [x1, 1, MUL VL]                                 \n"
    "    ldr z2, [x1, 2, MUL VL]                                 \n"
    "    ldr z3, [x1, 3, MUL VL]                                 \n"
    "                                                            \n"
    "    str z0, [x2, 0, MUL VL]                                 \n"
    "    str z1, [x2, 1, MUL VL]                                 \n"
    "    str z2, [x2, 2, MUL VL]                                 \n"
    "    str z3, [x2, 3, MUL VL]                                 \n"
    "                                                            \n"
    "    add x1, x1, #256                                        \n"
    "    add x2, x2, #256                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    ldr z0, [x1, 0, MUL VL]                                 \n"
    "    add x1, x1, #64                                         \n"
    "    str z0, [x2, 0, MUL VL]                                 \n"
    "    add x2, x2, #64                                         \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [dst] "r" (data->dst), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1", "x2"
  );

  //printf("done copy_reg_adjacent_x1_ilp4\n");

  // number of bytes transferred overall
  return 2.0*data->total_size;
}


static double copy_reg_adjacent_x1_ilp5(const void* args) {
  // LDR/STR (one register, unpredicated)
  //
  // Bytes per instruction: 64, bytes per loop iteration: 320 (ILP=5)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 320);

  //printf("starting copy_reg_adjacent_x1_ilp5\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  mov x2, %[dst]                                            \n"
    "  2:                                                        \n"
    "    ldr z0, [x1, 0, MUL VL]                                 \n"
    "    ldr z1, [x1, 1, MUL VL]                                 \n"
    "    ldr z2, [x1, 2, MUL VL]                                 \n"
    "    ldr z3, [x1, 3, MUL VL]                                 \n"
    "    ldr z4, [x1, 4, MUL VL]                                 \n"
    "                                                            \n"
    "    str z0, [x2, 0, MUL VL]                                 \n"
    "    str z1, [x2, 1, MUL VL]                                 \n"
    "    str z2, [x2, 2, MUL VL]                                 \n"
    "    str z3, [x2, 3, MUL VL]                                 \n"
    "    str z4, [x2, 4, MUL VL]                                 \n"
    "                                                            \n"
    "    add x1, x1, #320                                        \n"
    "    add x2, x2, #320                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    ldr z0, [x1, 0, MUL VL]                                 \n"
    "    add x1, x1, #64                                         \n"
    "    str z0, [x2, 0, MUL VL]                                 \n"
    "    add x2, x2, #64                                         \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [dst] "r" (data->dst), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1", "x2"
  );

  //printf("done copy_reg_adjacent_x1_ilp5\n");

  // number of bytes transferred overall
  return 2.0*data->total_size;
}


static double copy_reg_adjacent_x1_ilp6(const void* args) {
  // LDR/STR (one register, unpredicated)
  //
  // Bytes per instruction: 64, bytes per loop iteration: 384 (ILP=6)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 384);

  //printf("starting copy_reg_adjacent_x1_ilp6\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  mov x2, %[dst]                                            \n"
    "  2:                                                        \n"
    "    ldr z0, [x1, 0, MUL VL]                                 \n"
    "    ldr z1, [x1, 1, MUL VL]                                 \n"
    "    ldr z2, [x1, 2, MUL VL]                                 \n"
    "    ldr z3, [x1, 3, MUL VL]                                 \n"
    "    ldr z4, [x1, 4, MUL VL]                                 \n"
    "    ldr z5, [x1, 5, MUL VL]                                 \n"
    "                                                            \n"
    "    str z0, [x2, 0, MUL VL]                                 \n"
    "    str z1, [x2, 1, MUL VL]                                 \n"
    "    str z2, [x2, 2, MUL VL]                                 \n"
    "    str z3, [x2, 3, MUL VL]                                 \n"
    "    str z4, [x2, 4, MUL VL]                                 \n"
    "    str z5, [x2, 5, MUL VL]                                 \n"
    "                                                            \n"
    "    add x1, x1, #384                                        \n"
    "    add x2, x2, #384                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    ldr z0, [x1, 0, MUL VL]                                 \n"
    "    add x1, x1, #64                                         \n"
    "    str z0, [x2, 0, MUL VL]                                 \n"
    "    add x2, x2, #64                                         \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [dst] "r" (data->dst), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1", "x2"
  );

  //printf("done copy_reg_adjacent_x1_ilp6\n");

  // number of bytes transferred overall
  return 2.0*data->total_size;
}


static double copy_reg_adjacent_x1_ilp7(const void* args) {
  // LDR/STR (one register, unpredicated)
  //
  // Bytes per instruction: 64, bytes per loop iteration: 448 (ILP=7)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 448);

  //printf("starting copy_reg_adjacent_x1_ilp7\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  mov x2, %[dst]                                            \n"
    "  2:                                                        \n"
    "    ldr z0, [x1, 0, MUL VL]                                 \n"
    "    ldr z1, [x1, 1, MUL VL]                                 \n"
    "    ldr z2, [x1, 2, MUL VL]                                 \n"
    "    ldr z3, [x1, 3, MUL VL]                                 \n"
    "    ldr z4, [x1, 4, MUL VL]                                 \n"
    "    ldr z5, [x1, 5, MUL VL]                                 \n"
    "    ldr z6, [x1, 6, MUL VL]                                 \n"
    "                                                            \n"
    "    str z0, [x2, 0, MUL VL]                                 \n"
    "    str z1, [x2, 1, MUL VL]                                 \n"
    "    str z2, [x2, 2, MUL VL]                                 \n"
    "    str z3, [x2, 3, MUL VL]                                 \n"
    "    str z4, [x2, 4, MUL VL]                                 \n"
    "    str z5, [x2, 5, MUL VL]                                 \n"
    "    str z6, [x2, 6, MUL VL]                                 \n"
    "                                                            \n"
    "    add x1, x1, #448                                        \n"
    "    add x2, x2, #448                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    ldr z0, [x1, 0, MUL VL]                                 \n"
    "    add x1, x1, #64                                         \n"
    "    str z0, [x2, 0, MUL VL]                                 \n"
    "    add x2, x2, #64                                         \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [dst] "r" (data->dst), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1", "x2"
  );

  //printf("done copy_reg_adjacent_x1_ilp7\n");

  // number of bytes transferred overall
  return 2.0*data->total_size;
}


static double copy_reg_adjacent_x1_ilp8(const void* args) {
  // LDR/STR (one register, unpredicated)
  //
  // Bytes per instruction: 64, bytes per loop iteration: 512 (ILP=8)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 512);

  //printf("starting copy_reg_adjacent_x1_ilp8\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  mov x2, %[dst]                                            \n"
    "  2:                                                        \n"
    "    ldr z0, [x1, 0, MUL VL]                                 \n"
    "    ldr z1, [x1, 1, MUL VL]                                 \n"
    "    ldr z2, [x1, 2, MUL VL]                                 \n"
    "    ldr z3, [x1, 3, MUL VL]                                 \n"
    "    ldr z4, [x1, 4, MUL VL]                                 \n"
    "    ldr z5, [x1, 5, MUL VL]                                 \n"
    "    ldr z6, [x1, 6, MUL VL]                                 \n"
    "    ldr z7, [x1, 7, MUL VL]                                 \n"
    "                                                            \n"
    "    str z0, [x2, 0, MUL VL]                                 \n"
    "    str z1, [x2, 1, MUL VL]                                 \n"
    "    str z2, [x2, 2, MUL VL]                                 \n"
    "    str z3, [x2, 3, MUL VL]                                 \n"
    "    str z4, [x2, 4, MUL VL]                                 \n"
    "    str z5, [x2, 5, MUL VL]                                 \n"
    "    str z6, [x2, 6, MUL VL]                                 \n"
    "    str z7, [x2, 7, MUL VL]                                 \n"
    "                                                            \n"
    "    add x1, x1, #512                                        \n"
    "    add x2, x2, #512                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    ldr z0, [x1, 0, MUL VL]                                 \n"
    "    add x1, x1, #64                                         \n"
    "    str z0, [x2, 0, MUL VL]                                 \n"
    "    add x2, x2, #64                                         \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [dst] "r" (data->dst), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1", "x2"
  );

  //printf("done copy_reg_adjacent_x1_ilp8\n");

  // number of bytes transferred overall
  return 2.0*data->total_size;
}


static double load_reg_adjacent_x2_ilp1(const void* args) {
  // LD1W (two register, adjacent, predicated)
  //
  // Bytes per instruction: 128, bytes per loop iteration: 128 (ILP=1)
  const benchmark_data_t* data = args;

  //printf("starting load_reg_adjacent_x2_ilp1\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue pn8.s                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  2:                                                        \n"
    "    ld1w {z0.s-z1.s}, pn8/z, [x1, 0, MUL VL]                \n"
    "                                                            \n"
    "    add x1, x1, #128                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 2b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [end] "r" (data->src + data->size)
    : "x0", "x1"
  );

  //printf("done load_reg_adjacent_x2_ilp1\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double load_reg_adjacent_x2_ilp2(const void* args) {
  // LD1W (two register, adjacent, predicated)
  //
  // Bytes per instruction: 128, bytes per loop iteration: 256 (ILP=2)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 256);

  //printf("starting load_reg_adjacent_x2_ilp2\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue pn8.s                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  2:                                                        \n"
    "    ld1w {z0.s-z1.s}, pn8/z, [x1, 0, MUL VL]                \n"
    "    ld1w {z2.s-z3.s}, pn8/z, [x1, 2, MUL VL]                \n"
    "                                                            \n"
    "    add x1, x1, #256                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    ld1w {z0.s-z1.s}, pn8/z, [x1, 0, MUL VL]                \n"
    "    add x1, x1, #128                                        \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1"
  );

  //printf("done load_reg_adjacent_x2_ilp2\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double load_reg_adjacent_x2_ilp3(const void* args) {
  // LD1W (two register, adjacent, predicated)
  //
  // Bytes per instruction: 128, bytes per loop iteration: 384 (ILP=3)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 384);

  //printf("starting load_reg_adjacent_x2_ilp3\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue pn8.s                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  2:                                                        \n"
    "    ld1w {z0.s-z1.s}, pn8/z, [x1, 0, MUL VL]                \n"
    "    ld1w {z2.s-z3.s}, pn8/z, [x1, 2, MUL VL]                \n"
    "    ld1w {z4.s-z5.s}, pn8/z, [x1, 4, MUL VL]                \n"
    "                                                            \n"
    "    add x1, x1, #384                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    ld1w {z0.s-z1.s}, pn8/z, [x1, 0, MUL VL]                \n"
    "    add x1, x1, #128                                        \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1"
  );

  //printf("done load_reg_adjacent_x2_ilp3\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double load_reg_adjacent_x2_ilp4(const void* args) {
  // LD1W (two register, adjacent, predicated)
  //
  // Bytes per instruction: 128, bytes per loop iteration: 512 (ILP=4)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 512);

  //printf("starting load_reg_adjacent_x2_ilp4\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue pn8.s                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  2:                                                        \n"
    "    ld1w {z0.s-z1.s}, pn8/z, [x1, 0, MUL VL]                \n"
    "    ld1w {z2.s-z3.s}, pn8/z, [x1, 2, MUL VL]                \n"
    "    ld1w {z4.s-z5.s}, pn8/z, [x1, 4, MUL VL]                \n"
    "    ld1w {z6.s-z7.s}, pn8/z, [x1, 6, MUL VL]                \n"
    "                                                            \n"
    "    add x1, x1, #512                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    ld1w {z0.s-z1.s}, pn8/z, [x1, 0, MUL VL]                \n"
    "    add x1, x1, #128                                        \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1"
  );

  //printf("done load_reg_adjacent_x2_ilp4\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double load_reg_adjacent_x2_ilp5(const void* args) {
  // LD1W (two register, adjacent, predicated)
  //
  // Bytes per instruction: 128, bytes per loop iteration: 640 (ILP=5)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 640);

  //printf("starting load_reg_adjacent_x2_ilp5\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue pn8.s                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  2:                                                        \n"
    "    ld1w {z0.s-z1.s}, pn8/z, [x1, 0, MUL VL]                \n"
    "    ld1w {z2.s-z3.s}, pn8/z, [x1, 2, MUL VL]                \n"
    "    ld1w {z4.s-z5.s}, pn8/z, [x1, 4, MUL VL]                \n"
    "    ld1w {z6.s-z7.s}, pn8/z, [x1, 6, MUL VL]                \n"
    "    ld1w {z8.s-z9.s}, pn8/z, [x1, 8, MUL VL]                \n"
    "                                                            \n"
    "    add x1, x1, #640                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    ld1w {z0.s-z1.s}, pn8/z, [x1, 0, MUL VL]                \n"
    "    add x1, x1, #128                                        \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1"
  );

  //printf("done load_reg_adjacent_x2_ilp5\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double load_reg_adjacent_x2_ilp6(const void* args) {
  // LD1W (two register, adjacent, predicated)
  //
  // Bytes per instruction: 128, bytes per loop iteration: 768 (ILP=6)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 768);

  //printf("starting load_reg_adjacent_x2_ilp6\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue pn8.s                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  2:                                                        \n"
    "    ld1w {z0.s-z1.s}, pn8/z, [x1, 0, MUL VL]                \n"
    "    ld1w {z2.s-z3.s}, pn8/z, [x1, 2, MUL VL]                \n"
    "    ld1w {z4.s-z5.s}, pn8/z, [x1, 4, MUL VL]                \n"
    "    ld1w {z6.s-z7.s}, pn8/z, [x1, 6, MUL VL]                \n"
    "    ld1w {z8.s-z9.s}, pn8/z, [x1, 8, MUL VL]                \n"
    "    ld1w {z10.s-z11.s}, pn8/z, [x1, 10, MUL VL]             \n"
    "                                                            \n"
    "    add x1, x1, #768                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    ld1w {z0.s-z1.s}, pn8/z, [x1, 0, MUL VL]                \n"
    "    add x1, x1, #128                                        \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1"
  );

  //printf("done load_reg_adjacent_x2_ilp6\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double load_reg_adjacent_x2_ilp7(const void* args) {
  // LD1W (two register, adjacent, predicated)
  //
  // Bytes per instruction: 128, bytes per loop iteration: 896 (ILP=7)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 896);

  //printf("starting load_reg_adjacent_x2_ilp7\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue pn8.s                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  2:                                                        \n"
    "    ld1w {z0.s-z1.s}, pn8/z, [x1, 0, MUL VL]                \n"
    "    ld1w {z2.s-z3.s}, pn8/z, [x1, 2, MUL VL]                \n"
    "    ld1w {z4.s-z5.s}, pn8/z, [x1, 4, MUL VL]                \n"
    "    ld1w {z6.s-z7.s}, pn8/z, [x1, 6, MUL VL]                \n"
    "    ld1w {z8.s-z9.s}, pn8/z, [x1, 8, MUL VL]                \n"
    "    ld1w {z10.s-z11.s}, pn8/z, [x1, 10, MUL VL]             \n"
    "    ld1w {z12.s-z13.s}, pn8/z, [x1, 12, MUL VL]             \n"
    "                                                            \n"
    "    add x1, x1, #896                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    ld1w {z0.s-z1.s}, pn8/z, [x1, 0, MUL VL]                \n"
    "    add x1, x1, #128                                        \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1"
  );

  //printf("done load_reg_adjacent_x2_ilp7\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double load_reg_adjacent_x2_ilp8(const void* args) {
  // LD1W (two register, adjacent, predicated)
  //
  // Bytes per instruction: 128, bytes per loop iteration: 1024 (ILP=8)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 1024);

  //printf("starting load_reg_adjacent_x2_ilp8\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue pn8.s                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  2:                                                        \n"
    "    ld1w {z0.s-z1.s}, pn8/z, [x1, 0, MUL VL]                \n"
    "    ld1w {z2.s-z3.s}, pn8/z, [x1, 2, MUL VL]                \n"
    "    ld1w {z4.s-z5.s}, pn8/z, [x1, 4, MUL VL]                \n"
    "    ld1w {z6.s-z7.s}, pn8/z, [x1, 6, MUL VL]                \n"
    "    ld1w {z8.s-z9.s}, pn8/z, [x1, 8, MUL VL]                \n"
    "    ld1w {z10.s-z11.s}, pn8/z, [x1, 10, MUL VL]             \n"
    "    ld1w {z12.s-z13.s}, pn8/z, [x1, 12, MUL VL]             \n"
    "    ld1w {z14.s-z15.s}, pn8/z, [x1, 14, MUL VL]             \n"
    "                                                            \n"
    "    add x1, x1, #1024                                       \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    ld1w {z0.s-z1.s}, pn8/z, [x1, 0, MUL VL]                \n"
    "    add x1, x1, #128                                        \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1"
  );

  //printf("done load_reg_adjacent_x2_ilp8\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double store_reg_adjacent_x2_ilp1(const void* args) {
  // ST1W (two register, adjacent, predicated)
  //
  // Bytes per instruction: 128, bytes per loop iteration: 128 (ILP=1)
  const benchmark_data_t* data = args;

  //printf("starting store_reg_adjacent_x2_ilp1\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue pn8.s                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[dst]                                            \n"
    "  2:                                                        \n"
    "    st1w {z0.s-z1.s}, pn8, [x1, 0, MUL VL]                  \n"
    "                                                            \n"
    "    add x1, x1, #128                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 2b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [dst] "r" (data->dst), [end] "r" (data->dst + data->size)
    : "x0", "x1"
  );

  //printf("done store_reg_adjacent_x2_ilp1\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double store_reg_adjacent_x2_ilp2(const void* args) {
  // ST1W (two register, adjacent, predicated)
  //
  // Bytes per instruction: 128, bytes per loop iteration: 256 (ILP=2)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 256);

  //printf("starting store_reg_adjacent_x2_ilp2\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue pn8.s                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[dst]                                            \n"
    "  2:                                                        \n"
    "    st1w {z0.s-z1.s}, pn8, [x1, 0, MUL VL]                  \n"
    "    st1w {z2.s-z3.s}, pn8, [x1, 2, MUL VL]                  \n"
    "                                                            \n"
    "    add x1, x1, #256                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    st1w {z0.s-z1.s}, pn8, [x1, 0, MUL VL]                  \n"
    "    add x1, x1, #128                                        \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [dst] "r" (data->dst), [end] "r" (data->dst + data->size), [end_aligned] "r" (data->dst + size_aligned)
    : "x0", "x1"
  );

  //printf("done store_reg_adjacent_x2_ilp2\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double store_reg_adjacent_x2_ilp3(const void* args) {
  // ST1W (two register, adjacent, predicated)
  //
  // Bytes per instruction: 128, bytes per loop iteration: 384 (ILP=3)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 384);

  //printf("starting store_reg_adjacent_x2_ilp3\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue pn8.s                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[dst]                                            \n"
    "  2:                                                        \n"
    "    st1w {z0.s-z1.s}, pn8, [x1, 0, MUL VL]                  \n"
    "    st1w {z2.s-z3.s}, pn8, [x1, 2, MUL VL]                  \n"
    "    st1w {z4.s-z5.s}, pn8, [x1, 4, MUL VL]                  \n"
    "                                                            \n"
    "    add x1, x1, #384                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    st1w {z0.s-z1.s}, pn8, [x1, 0, MUL VL]                  \n"
    "    add x1, x1, #128                                        \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [dst] "r" (data->dst), [end] "r" (data->dst + data->size), [end_aligned] "r" (data->dst + size_aligned)
    : "x0", "x1"
  );

  //printf("done store_reg_adjacent_x2_ilp3\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double store_reg_adjacent_x2_ilp4(const void* args) {
  // ST1W (two register, adjacent, predicated)
  //
  // Bytes per instruction: 128, bytes per loop iteration: 512 (ILP=4)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 512);

  //printf("starting store_reg_adjacent_x2_ilp4\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue pn8.s                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[dst]                                            \n"
    "  2:                                                        \n"
    "    st1w {z0.s-z1.s}, pn8, [x1, 0, MUL VL]                  \n"
    "    st1w {z2.s-z3.s}, pn8, [x1, 2, MUL VL]                  \n"
    "    st1w {z4.s-z5.s}, pn8, [x1, 4, MUL VL]                  \n"
    "    st1w {z6.s-z7.s}, pn8, [x1, 6, MUL VL]                  \n"
    "                                                            \n"
    "    add x1, x1, #512                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    st1w {z0.s-z1.s}, pn8, [x1, 0, MUL VL]                  \n"
    "    add x1, x1, #128                                        \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [dst] "r" (data->dst), [end] "r" (data->dst + data->size), [end_aligned] "r" (data->dst + size_aligned)
    : "x0", "x1"
  );

  //printf("done store_reg_adjacent_x2_ilp4\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double store_reg_adjacent_x2_ilp5(const void* args) {
  // ST1W (two register, adjacent, predicated)
  //
  // Bytes per instruction: 128, bytes per loop iteration: 640 (ILP=5)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 640);

  //printf("starting store_reg_adjacent_x2_ilp5\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue pn8.s                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[dst]                                            \n"
    "  2:                                                        \n"
    "    st1w {z0.s-z1.s}, pn8, [x1, 0, MUL VL]                  \n"
    "    st1w {z2.s-z3.s}, pn8, [x1, 2, MUL VL]                  \n"
    "    st1w {z4.s-z5.s}, pn8, [x1, 4, MUL VL]                  \n"
    "    st1w {z6.s-z7.s}, pn8, [x1, 6, MUL VL]                  \n"
    "    st1w {z8.s-z9.s}, pn8, [x1, 8, MUL VL]                  \n"
    "                                                            \n"
    "    add x1, x1, #640                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    st1w {z0.s-z1.s}, pn8, [x1, 0, MUL VL]                  \n"
    "    add x1, x1, #128                                        \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [dst] "r" (data->dst), [end] "r" (data->dst + data->size), [end_aligned] "r" (data->dst + size_aligned)
    : "x0", "x1"
  );

  //printf("done store_reg_adjacent_x2_ilp5\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double store_reg_adjacent_x2_ilp6(const void* args) {
  // ST1W (two register, adjacent, predicated)
  //
  // Bytes per instruction: 128, bytes per loop iteration: 768 (ILP=6)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 768);

  //printf("starting store_reg_adjacent_x2_ilp6\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue pn8.s                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[dst]                                            \n"
    "  2:                                                        \n"
    "    st1w {z0.s-z1.s}, pn8, [x1, 0, MUL VL]                  \n"
    "    st1w {z2.s-z3.s}, pn8, [x1, 2, MUL VL]                  \n"
    "    st1w {z4.s-z5.s}, pn8, [x1, 4, MUL VL]                  \n"
    "    st1w {z6.s-z7.s}, pn8, [x1, 6, MUL VL]                  \n"
    "    st1w {z8.s-z9.s}, pn8, [x1, 8, MUL VL]                  \n"
    "    st1w {z10.s-z11.s}, pn8, [x1, 10, MUL VL]               \n"
    "                                                            \n"
    "    add x1, x1, #768                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    st1w {z0.s-z1.s}, pn8, [x1, 0, MUL VL]                  \n"
    "    add x1, x1, #128                                        \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [dst] "r" (data->dst), [end] "r" (data->dst + data->size), [end_aligned] "r" (data->dst + size_aligned)
    : "x0", "x1"
  );

  //printf("done store_reg_adjacent_x2_ilp6\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double store_reg_adjacent_x2_ilp7(const void* args) {
  // ST1W (two register, adjacent, predicated)
  //
  // Bytes per instruction: 128, bytes per loop iteration: 896 (ILP=7)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 896);

  //printf("starting store_reg_adjacent_x2_ilp7\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue pn8.s                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[dst]                                            \n"
    "  2:                                                        \n"
    "    st1w {z0.s-z1.s}, pn8, [x1, 0, MUL VL]                  \n"
    "    st1w {z2.s-z3.s}, pn8, [x1, 2, MUL VL]                  \n"
    "    st1w {z4.s-z5.s}, pn8, [x1, 4, MUL VL]                  \n"
    "    st1w {z6.s-z7.s}, pn8, [x1, 6, MUL VL]                  \n"
    "    st1w {z8.s-z9.s}, pn8, [x1, 8, MUL VL]                  \n"
    "    st1w {z10.s-z11.s}, pn8, [x1, 10, MUL VL]               \n"
    "    st1w {z12.s-z13.s}, pn8, [x1, 12, MUL VL]               \n"
    "                                                            \n"
    "    add x1, x1, #896                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    st1w {z0.s-z1.s}, pn8, [x1, 0, MUL VL]                  \n"
    "    add x1, x1, #128                                        \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [dst] "r" (data->dst), [end] "r" (data->dst + data->size), [end_aligned] "r" (data->dst + size_aligned)
    : "x0", "x1"
  );

  //printf("done store_reg_adjacent_x2_ilp7\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double store_reg_adjacent_x2_ilp8(const void* args) {
  // ST1W (two register, adjacent, predicated)
  //
  // Bytes per instruction: 128, bytes per loop iteration: 1024 (ILP=8)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 1024);

  //printf("starting store_reg_adjacent_x2_ilp8\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue pn8.s                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[dst]                                            \n"
    "  2:                                                        \n"
    "    st1w {z0.s-z1.s}, pn8, [x1, 0, MUL VL]                  \n"
    "    st1w {z2.s-z3.s}, pn8, [x1, 2, MUL VL]                  \n"
    "    st1w {z4.s-z5.s}, pn8, [x1, 4, MUL VL]                  \n"
    "    st1w {z6.s-z7.s}, pn8, [x1, 6, MUL VL]                  \n"
    "    st1w {z8.s-z9.s}, pn8, [x1, 8, MUL VL]                  \n"
    "    st1w {z10.s-z11.s}, pn8, [x1, 10, MUL VL]               \n"
    "    st1w {z12.s-z13.s}, pn8, [x1, 12, MUL VL]               \n"
    "    st1w {z14.s-z15.s}, pn8, [x1, 14, MUL VL]               \n"
    "                                                            \n"
    "    add x1, x1, #1024                                       \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    st1w {z0.s-z1.s}, pn8, [x1, 0, MUL VL]                  \n"
    "    add x1, x1, #128                                        \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [dst] "r" (data->dst), [end] "r" (data->dst + data->size), [end_aligned] "r" (data->dst + size_aligned)
    : "x0", "x1"
  );

  //printf("done store_reg_adjacent_x2_ilp8\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double copy_reg_adjacent_x2_ilp1(const void* args) {
  // LD1W/ST1W (two register, adjacent, predicated)
  //
  // Bytes per instruction: 128, bytes per loop iteration: 128 (ILP=1)
  const benchmark_data_t* data = args;

  //printf("starting copy_reg_adjacent_x2_ilp1\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue pn8.s                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  mov x2, %[dst]                                            \n"
    "  2:                                                        \n"
    "    ld1w {z0.s-z1.s}, pn8/z, [x1, 0, MUL VL]                \n"
    "                                                            \n"
    "    st1w {z0.s-z1.s}, pn8, [x2, 0, MUL VL]                  \n"
    "                                                            \n"
    "    add x1, x1, #128                                        \n"
    "    add x2, x2, #128                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 2b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [dst] "r" (data->dst), [end] "r" (data->src + data->size)
    : "x0", "x1", "x2"
  );

  //printf("done copy_reg_adjacent_x2_ilp1\n");

  // number of bytes transferred overall
  return 2.0*data->total_size;
}


static double copy_reg_adjacent_x2_ilp2(const void* args) {
  // LD1W/ST1W (two register, adjacent, predicated)
  //
  // Bytes per instruction: 128, bytes per loop iteration: 256 (ILP=2)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 256);

  //printf("starting copy_reg_adjacent_x2_ilp2\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue pn8.s                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  mov x2, %[dst]                                            \n"
    "  2:                                                        \n"
    "    ld1w {z0.s-z1.s}, pn8/z, [x1, 0, MUL VL]                \n"
    "    ld1w {z2.s-z3.s}, pn8/z, [x1, 2, MUL VL]                \n"
    "                                                            \n"
    "    st1w {z0.s-z1.s}, pn8, [x2, 0, MUL VL]                  \n"
    "    st1w {z2.s-z3.s}, pn8, [x2, 2, MUL VL]                  \n"
    "                                                            \n"
    "    add x1, x1, #256                                        \n"
    "    add x2, x2, #256                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    ld1w {z0.s-z1.s}, pn8/z, [x1, 0, MUL VL]                \n"
    "    add x1, x1, #128                                        \n"
    "    st1w {z0.s-z1.s}, pn8, [x2, 0, MUL VL]                  \n"
    "    add x2, x2, #128                                        \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [dst] "r" (data->dst), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1", "x2"
  );

  //printf("done copy_reg_adjacent_x2_ilp2\n");

  // number of bytes transferred overall
  return 2.0*data->total_size;
}


static double copy_reg_adjacent_x2_ilp3(const void* args) {
  // LD1W/ST1W (two register, adjacent, predicated)
  //
  // Bytes per instruction: 128, bytes per loop iteration: 384 (ILP=3)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 384);

  //printf("starting copy_reg_adjacent_x2_ilp3\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue pn8.s                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  mov x2, %[dst]                                            \n"
    "  2:                                                        \n"
    "    ld1w {z0.s-z1.s}, pn8/z, [x1, 0, MUL VL]                \n"
    "    ld1w {z2.s-z3.s}, pn8/z, [x1, 2, MUL VL]                \n"
    "    ld1w {z4.s-z5.s}, pn8/z, [x1, 4, MUL VL]                \n"
    "                                                            \n"
    "    st1w {z0.s-z1.s}, pn8, [x2, 0, MUL VL]                  \n"
    "    st1w {z2.s-z3.s}, pn8, [x2, 2, MUL VL]                  \n"
    "    st1w {z4.s-z5.s}, pn8, [x2, 4, MUL VL]                  \n"
    "                                                            \n"
    "    add x1, x1, #384                                        \n"
    "    add x2, x2, #384                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    ld1w {z0.s-z1.s}, pn8/z, [x1, 0, MUL VL]                \n"
    "    add x1, x1, #128                                        \n"
    "    st1w {z0.s-z1.s}, pn8, [x2, 0, MUL VL]                  \n"
    "    add x2, x2, #128                                        \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [dst] "r" (data->dst), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1", "x2"
  );

  //printf("done copy_reg_adjacent_x2_ilp3\n");

  // number of bytes transferred overall
  return 2.0*data->total_size;
}


static double copy_reg_adjacent_x2_ilp4(const void* args) {
  // LD1W/ST1W (two register, adjacent, predicated)
  //
  // Bytes per instruction: 128, bytes per loop iteration: 512 (ILP=4)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 512);

  //printf("starting copy_reg_adjacent_x2_ilp4\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue pn8.s                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  mov x2, %[dst]                                            \n"
    "  2:                                                        \n"
    "    ld1w {z0.s-z1.s}, pn8/z, [x1, 0, MUL VL]                \n"
    "    ld1w {z2.s-z3.s}, pn8/z, [x1, 2, MUL VL]                \n"
    "    ld1w {z4.s-z5.s}, pn8/z, [x1, 4, MUL VL]                \n"
    "    ld1w {z6.s-z7.s}, pn8/z, [x1, 6, MUL VL]                \n"
    "                                                            \n"
    "    st1w {z0.s-z1.s}, pn8, [x2, 0, MUL VL]                  \n"
    "    st1w {z2.s-z3.s}, pn8, [x2, 2, MUL VL]                  \n"
    "    st1w {z4.s-z5.s}, pn8, [x2, 4, MUL VL]                  \n"
    "    st1w {z6.s-z7.s}, pn8, [x2, 6, MUL VL]                  \n"
    "                                                            \n"
    "    add x1, x1, #512                                        \n"
    "    add x2, x2, #512                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    ld1w {z0.s-z1.s}, pn8/z, [x1, 0, MUL VL]                \n"
    "    add x1, x1, #128                                        \n"
    "    st1w {z0.s-z1.s}, pn8, [x2, 0, MUL VL]                  \n"
    "    add x2, x2, #128                                        \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [dst] "r" (data->dst), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1", "x2"
  );

  //printf("done copy_reg_adjacent_x2_ilp4\n");

  // number of bytes transferred overall
  return 2.0*data->total_size;
}


static double copy_reg_adjacent_x2_ilp5(const void* args) {
  // LD1W/ST1W (two register, adjacent, predicated)
  //
  // Bytes per instruction: 128, bytes per loop iteration: 640 (ILP=5)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 640);

  //printf("starting copy_reg_adjacent_x2_ilp5\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue pn8.s                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  mov x2, %[dst]                                            \n"
    "  2:                                                        \n"
    "    ld1w {z0.s-z1.s}, pn8/z, [x1, 0, MUL VL]                \n"
    "    ld1w {z2.s-z3.s}, pn8/z, [x1, 2, MUL VL]                \n"
    "    ld1w {z4.s-z5.s}, pn8/z, [x1, 4, MUL VL]                \n"
    "    ld1w {z6.s-z7.s}, pn8/z, [x1, 6, MUL VL]                \n"
    "    ld1w {z8.s-z9.s}, pn8/z, [x1, 8, MUL VL]                \n"
    "                                                            \n"
    "    st1w {z0.s-z1.s}, pn8, [x2, 0, MUL VL]                  \n"
    "    st1w {z2.s-z3.s}, pn8, [x2, 2, MUL VL]                  \n"
    "    st1w {z4.s-z5.s}, pn8, [x2, 4, MUL VL]                  \n"
    "    st1w {z6.s-z7.s}, pn8, [x2, 6, MUL VL]                  \n"
    "    st1w {z8.s-z9.s}, pn8, [x2, 8, MUL VL]                  \n"
    "                                                            \n"
    "    add x1, x1, #640                                        \n"
    "    add x2, x2, #640                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    ld1w {z0.s-z1.s}, pn8/z, [x1, 0, MUL VL]                \n"
    "    add x1, x1, #128                                        \n"
    "    st1w {z0.s-z1.s}, pn8, [x2, 0, MUL VL]                  \n"
    "    add x2, x2, #128                                        \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [dst] "r" (data->dst), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1", "x2"
  );

  //printf("done copy_reg_adjacent_x2_ilp5\n");

  // number of bytes transferred overall
  return 2.0*data->total_size;
}


static double copy_reg_adjacent_x2_ilp6(const void* args) {
  // LD1W/ST1W (two register, adjacent, predicated)
  //
  // Bytes per instruction: 128, bytes per loop iteration: 768 (ILP=6)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 768);

  //printf("starting copy_reg_adjacent_x2_ilp6\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue pn8.s                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  mov x2, %[dst]                                            \n"
    "  2:                                                        \n"
    "    ld1w {z0.s-z1.s}, pn8/z, [x1, 0, MUL VL]                \n"
    "    ld1w {z2.s-z3.s}, pn8/z, [x1, 2, MUL VL]                \n"
    "    ld1w {z4.s-z5.s}, pn8/z, [x1, 4, MUL VL]                \n"
    "    ld1w {z6.s-z7.s}, pn8/z, [x1, 6, MUL VL]                \n"
    "    ld1w {z8.s-z9.s}, pn8/z, [x1, 8, MUL VL]                \n"
    "    ld1w {z10.s-z11.s}, pn8/z, [x1, 10, MUL VL]             \n"
    "                                                            \n"
    "    st1w {z0.s-z1.s}, pn8, [x2, 0, MUL VL]                  \n"
    "    st1w {z2.s-z3.s}, pn8, [x2, 2, MUL VL]                  \n"
    "    st1w {z4.s-z5.s}, pn8, [x2, 4, MUL VL]                  \n"
    "    st1w {z6.s-z7.s}, pn8, [x2, 6, MUL VL]                  \n"
    "    st1w {z8.s-z9.s}, pn8, [x2, 8, MUL VL]                  \n"
    "    st1w {z10.s-z11.s}, pn8, [x2, 10, MUL VL]               \n"
    "                                                            \n"
    "    add x1, x1, #768                                        \n"
    "    add x2, x2, #768                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    ld1w {z0.s-z1.s}, pn8/z, [x1, 0, MUL VL]                \n"
    "    add x1, x1, #128                                        \n"
    "    st1w {z0.s-z1.s}, pn8, [x2, 0, MUL VL]                  \n"
    "    add x2, x2, #128                                        \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [dst] "r" (data->dst), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1", "x2"
  );

  //printf("done copy_reg_adjacent_x2_ilp6\n");

  // number of bytes transferred overall
  return 2.0*data->total_size;
}


static double copy_reg_adjacent_x2_ilp7(const void* args) {
  // LD1W/ST1W (two register, adjacent, predicated)
  //
  // Bytes per instruction: 128, bytes per loop iteration: 896 (ILP=7)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 896);

  //printf("starting copy_reg_adjacent_x2_ilp7\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue pn8.s                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  mov x2, %[dst]                                            \n"
    "  2:                                                        \n"
    "    ld1w {z0.s-z1.s}, pn8/z, [x1, 0, MUL VL]                \n"
    "    ld1w {z2.s-z3.s}, pn8/z, [x1, 2, MUL VL]                \n"
    "    ld1w {z4.s-z5.s}, pn8/z, [x1, 4, MUL VL]                \n"
    "    ld1w {z6.s-z7.s}, pn8/z, [x1, 6, MUL VL]                \n"
    "    ld1w {z8.s-z9.s}, pn8/z, [x1, 8, MUL VL]                \n"
    "    ld1w {z10.s-z11.s}, pn8/z, [x1, 10, MUL VL]             \n"
    "    ld1w {z12.s-z13.s}, pn8/z, [x1, 12, MUL VL]             \n"
    "                                                            \n"
    "    st1w {z0.s-z1.s}, pn8, [x2, 0, MUL VL]                  \n"
    "    st1w {z2.s-z3.s}, pn8, [x2, 2, MUL VL]                  \n"
    "    st1w {z4.s-z5.s}, pn8, [x2, 4, MUL VL]                  \n"
    "    st1w {z6.s-z7.s}, pn8, [x2, 6, MUL VL]                  \n"
    "    st1w {z8.s-z9.s}, pn8, [x2, 8, MUL VL]                  \n"
    "    st1w {z10.s-z11.s}, pn8, [x2, 10, MUL VL]               \n"
    "    st1w {z12.s-z13.s}, pn8, [x2, 12, MUL VL]               \n"
    "                                                            \n"
    "    add x1, x1, #896                                        \n"
    "    add x2, x2, #896                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    ld1w {z0.s-z1.s}, pn8/z, [x1, 0, MUL VL]                \n"
    "    add x1, x1, #128                                        \n"
    "    st1w {z0.s-z1.s}, pn8, [x2, 0, MUL VL]                  \n"
    "    add x2, x2, #128                                        \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [dst] "r" (data->dst), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1", "x2"
  );

  //printf("done copy_reg_adjacent_x2_ilp7\n");

  // number of bytes transferred overall
  return 2.0*data->total_size;
}


static double copy_reg_adjacent_x2_ilp8(const void* args) {
  // LD1W/ST1W (two register, adjacent, predicated)
  //
  // Bytes per instruction: 128, bytes per loop iteration: 1024 (ILP=8)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 1024);

  //printf("starting copy_reg_adjacent_x2_ilp8\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue pn8.s                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  mov x2, %[dst]                                            \n"
    "  2:                                                        \n"
    "    ld1w {z0.s-z1.s}, pn8/z, [x1, 0, MUL VL]                \n"
    "    ld1w {z2.s-z3.s}, pn8/z, [x1, 2, MUL VL]                \n"
    "    ld1w {z4.s-z5.s}, pn8/z, [x1, 4, MUL VL]                \n"
    "    ld1w {z6.s-z7.s}, pn8/z, [x1, 6, MUL VL]                \n"
    "    ld1w {z8.s-z9.s}, pn8/z, [x1, 8, MUL VL]                \n"
    "    ld1w {z10.s-z11.s}, pn8/z, [x1, 10, MUL VL]             \n"
    "    ld1w {z12.s-z13.s}, pn8/z, [x1, 12, MUL VL]             \n"
    "    ld1w {z14.s-z15.s}, pn8/z, [x1, 14, MUL VL]             \n"
    "                                                            \n"
    "    st1w {z0.s-z1.s}, pn8, [x2, 0, MUL VL]                  \n"
    "    st1w {z2.s-z3.s}, pn8, [x2, 2, MUL VL]                  \n"
    "    st1w {z4.s-z5.s}, pn8, [x2, 4, MUL VL]                  \n"
    "    st1w {z6.s-z7.s}, pn8, [x2, 6, MUL VL]                  \n"
    "    st1w {z8.s-z9.s}, pn8, [x2, 8, MUL VL]                  \n"
    "    st1w {z10.s-z11.s}, pn8, [x2, 10, MUL VL]               \n"
    "    st1w {z12.s-z13.s}, pn8, [x2, 12, MUL VL]               \n"
    "    st1w {z14.s-z15.s}, pn8, [x2, 14, MUL VL]               \n"
    "                                                            \n"
    "    add x1, x1, #1024                                       \n"
    "    add x2, x2, #1024                                       \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    ld1w {z0.s-z1.s}, pn8/z, [x1, 0, MUL VL]                \n"
    "    add x1, x1, #128                                        \n"
    "    st1w {z0.s-z1.s}, pn8, [x2, 0, MUL VL]                  \n"
    "    add x2, x2, #128                                        \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [dst] "r" (data->dst), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1", "x2"
  );

  //printf("done copy_reg_adjacent_x2_ilp8\n");

  // number of bytes transferred overall
  return 2.0*data->total_size;
}


static double load_reg_adjacent_x4_ilp1(const void* args) {
  // LD1W (four register, adjacent, predicated)
  //
  // Bytes per instruction: 256, bytes per loop iteration: 256 (ILP=1)
  const benchmark_data_t* data = args;

  //printf("starting load_reg_adjacent_x4_ilp1\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue pn8.s                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  2:                                                        \n"
    "    ld1w {z0.s-z3.s}, pn8/z, [x1, 0, MUL VL]                \n"
    "                                                            \n"
    "    add x1, x1, #256                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 2b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [end] "r" (data->src + data->size)
    : "x0", "x1"
  );

  //printf("done load_reg_adjacent_x4_ilp1\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double load_reg_adjacent_x4_ilp2(const void* args) {
  // LD1W (four register, adjacent, predicated)
  //
  // Bytes per instruction: 256, bytes per loop iteration: 512 (ILP=2)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 512);

  //printf("starting load_reg_adjacent_x4_ilp2\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue pn8.s                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  2:                                                        \n"
    "    ld1w {z0.s-z3.s}, pn8/z, [x1, 0, MUL VL]                \n"
    "    ld1w {z4.s-z7.s}, pn8/z, [x1, 4, MUL VL]                \n"
    "                                                            \n"
    "    add x1, x1, #512                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    ld1w {z0.s-z3.s}, pn8/z, [x1, 0, MUL VL]                \n"
    "    add x1, x1, #256                                        \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1"
  );

  //printf("done load_reg_adjacent_x4_ilp2\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double load_reg_adjacent_x4_ilp3(const void* args) {
  // LD1W (four register, adjacent, predicated)
  //
  // Bytes per instruction: 256, bytes per loop iteration: 768 (ILP=3)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 768);

  //printf("starting load_reg_adjacent_x4_ilp3\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue pn8.s                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  2:                                                        \n"
    "    ld1w {z0.s-z3.s}, pn8/z, [x1, 0, MUL VL]                \n"
    "    ld1w {z4.s-z7.s}, pn8/z, [x1, 4, MUL VL]                \n"
    "    ld1w {z8.s-z11.s}, pn8/z, [x1, 8, MUL VL]               \n"
    "                                                            \n"
    "    add x1, x1, #768                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    ld1w {z0.s-z3.s}, pn8/z, [x1, 0, MUL VL]                \n"
    "    add x1, x1, #256                                        \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1"
  );

  //printf("done load_reg_adjacent_x4_ilp3\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double load_reg_adjacent_x4_ilp4(const void* args) {
  // LD1W (four register, adjacent, predicated)
  //
  // Bytes per instruction: 256, bytes per loop iteration: 1024 (ILP=4)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 1024);

  //printf("starting load_reg_adjacent_x4_ilp4\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue pn8.s                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  2:                                                        \n"
    "    ld1w {z0.s-z3.s}, pn8/z, [x1, 0, MUL VL]                \n"
    "    ld1w {z4.s-z7.s}, pn8/z, [x1, 4, MUL VL]                \n"
    "    ld1w {z8.s-z11.s}, pn8/z, [x1, 8, MUL VL]               \n"
    "    ld1w {z12.s-z15.s}, pn8/z, [x1, 12, MUL VL]             \n"
    "                                                            \n"
    "    add x1, x1, #1024                                       \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    ld1w {z0.s-z3.s}, pn8/z, [x1, 0, MUL VL]                \n"
    "    add x1, x1, #256                                        \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1"
  );

  //printf("done load_reg_adjacent_x4_ilp4\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double load_reg_adjacent_x4_ilp5(const void* args) {
  // LD1W (four register, adjacent, predicated)
  //
  // Bytes per instruction: 256, bytes per loop iteration: 1280 (ILP=5)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 1280);

  //printf("starting load_reg_adjacent_x4_ilp5\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue pn8.s                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  2:                                                        \n"
    "    ld1w {z0.s-z3.s}, pn8/z, [x1, 0, MUL VL]                \n"
    "    ld1w {z4.s-z7.s}, pn8/z, [x1, 4, MUL VL]                \n"
    "    ld1w {z8.s-z11.s}, pn8/z, [x1, 8, MUL VL]               \n"
    "    ld1w {z12.s-z15.s}, pn8/z, [x1, 12, MUL VL]             \n"
    "    ld1w {z16.s-z19.s}, pn8/z, [x1, 16, MUL VL]             \n"
    "                                                            \n"
    "    add x1, x1, #1280                                       \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    ld1w {z0.s-z3.s}, pn8/z, [x1, 0, MUL VL]                \n"
    "    add x1, x1, #256                                        \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1"
  );

  //printf("done load_reg_adjacent_x4_ilp5\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double load_reg_adjacent_x4_ilp6(const void* args) {
  // LD1W (four register, adjacent, predicated)
  //
  // Bytes per instruction: 256, bytes per loop iteration: 1536 (ILP=6)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 1536);

  //printf("starting load_reg_adjacent_x4_ilp6\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue pn8.s                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  2:                                                        \n"
    "    ld1w {z0.s-z3.s}, pn8/z, [x1, 0, MUL VL]                \n"
    "    ld1w {z4.s-z7.s}, pn8/z, [x1, 4, MUL VL]                \n"
    "    ld1w {z8.s-z11.s}, pn8/z, [x1, 8, MUL VL]               \n"
    "    ld1w {z12.s-z15.s}, pn8/z, [x1, 12, MUL VL]             \n"
    "    ld1w {z16.s-z19.s}, pn8/z, [x1, 16, MUL VL]             \n"
    "    ld1w {z20.s-z23.s}, pn8/z, [x1, 20, MUL VL]             \n"
    "                                                            \n"
    "    add x1, x1, #1536                                       \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    ld1w {z0.s-z3.s}, pn8/z, [x1, 0, MUL VL]                \n"
    "    add x1, x1, #256                                        \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1"
  );

  //printf("done load_reg_adjacent_x4_ilp6\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double load_reg_adjacent_x4_ilp7(const void* args) {
  // LD1W (four register, adjacent, predicated)
  //
  // Bytes per instruction: 256, bytes per loop iteration: 1792 (ILP=7)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 1792);

  //printf("starting load_reg_adjacent_x4_ilp7\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue pn8.s                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  2:                                                        \n"
    "    ld1w {z0.s-z3.s}, pn8/z, [x1, 0, MUL VL]                \n"
    "    ld1w {z4.s-z7.s}, pn8/z, [x1, 4, MUL VL]                \n"
    "    ld1w {z8.s-z11.s}, pn8/z, [x1, 8, MUL VL]               \n"
    "    ld1w {z12.s-z15.s}, pn8/z, [x1, 12, MUL VL]             \n"
    "    ld1w {z16.s-z19.s}, pn8/z, [x1, 16, MUL VL]             \n"
    "    ld1w {z20.s-z23.s}, pn8/z, [x1, 20, MUL VL]             \n"
    "    ld1w {z24.s-z27.s}, pn8/z, [x1, 24, MUL VL]             \n"
    "                                                            \n"
    "    add x1, x1, #1792                                       \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    ld1w {z0.s-z3.s}, pn8/z, [x1, 0, MUL VL]                \n"
    "    add x1, x1, #256                                        \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1"
  );

  //printf("done load_reg_adjacent_x4_ilp7\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double load_reg_adjacent_x4_ilp8(const void* args) {
  // LD1W (four register, adjacent, predicated)
  //
  // Bytes per instruction: 256, bytes per loop iteration: 2048 (ILP=8)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 2048);

  //printf("starting load_reg_adjacent_x4_ilp8\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue pn8.s                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  2:                                                        \n"
    "    ld1w {z0.s-z3.s}, pn8/z, [x1, 0, MUL VL]                \n"
    "    ld1w {z4.s-z7.s}, pn8/z, [x1, 4, MUL VL]                \n"
    "    ld1w {z8.s-z11.s}, pn8/z, [x1, 8, MUL VL]               \n"
    "    ld1w {z12.s-z15.s}, pn8/z, [x1, 12, MUL VL]             \n"
    "    ld1w {z16.s-z19.s}, pn8/z, [x1, 16, MUL VL]             \n"
    "    ld1w {z20.s-z23.s}, pn8/z, [x1, 20, MUL VL]             \n"
    "    ld1w {z24.s-z27.s}, pn8/z, [x1, 24, MUL VL]             \n"
    "    ld1w {z28.s-z31.s}, pn8/z, [x1, 28, MUL VL]             \n"
    "                                                            \n"
    "    add x1, x1, #2048                                       \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    ld1w {z0.s-z3.s}, pn8/z, [x1, 0, MUL VL]                \n"
    "    add x1, x1, #256                                        \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1"
  );

  //printf("done load_reg_adjacent_x4_ilp8\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double store_reg_adjacent_x4_ilp1(const void* args) {
  // ST1W (four register, adjacent, predicated)
  //
  // Bytes per instruction: 256, bytes per loop iteration: 256 (ILP=1)
  const benchmark_data_t* data = args;

  //printf("starting store_reg_adjacent_x4_ilp1\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue pn8.s                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[dst]                                            \n"
    "  2:                                                        \n"
    "    st1w {z0.s-z3.s}, pn8, [x1, 0, MUL VL]                  \n"
    "                                                            \n"
    "    add x1, x1, #256                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 2b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [dst] "r" (data->dst), [end] "r" (data->dst + data->size)
    : "x0", "x1"
  );

  //printf("done store_reg_adjacent_x4_ilp1\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double store_reg_adjacent_x4_ilp2(const void* args) {
  // ST1W (four register, adjacent, predicated)
  //
  // Bytes per instruction: 256, bytes per loop iteration: 512 (ILP=2)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 512);

  //printf("starting store_reg_adjacent_x4_ilp2\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue pn8.s                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[dst]                                            \n"
    "  2:                                                        \n"
    "    st1w {z0.s-z3.s}, pn8, [x1, 0, MUL VL]                  \n"
    "    st1w {z4.s-z7.s}, pn8, [x1, 4, MUL VL]                  \n"
    "                                                            \n"
    "    add x1, x1, #512                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    st1w {z0.s-z3.s}, pn8, [x1, 0, MUL VL]                  \n"
    "    add x1, x1, #256                                        \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [dst] "r" (data->dst), [end] "r" (data->dst + data->size), [end_aligned] "r" (data->dst + size_aligned)
    : "x0", "x1"
  );

  //printf("done store_reg_adjacent_x4_ilp2\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double store_reg_adjacent_x4_ilp3(const void* args) {
  // ST1W (four register, adjacent, predicated)
  //
  // Bytes per instruction: 256, bytes per loop iteration: 768 (ILP=3)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 768);

  //printf("starting store_reg_adjacent_x4_ilp3\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue pn8.s                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[dst]                                            \n"
    "  2:                                                        \n"
    "    st1w {z0.s-z3.s}, pn8, [x1, 0, MUL VL]                  \n"
    "    st1w {z4.s-z7.s}, pn8, [x1, 4, MUL VL]                  \n"
    "    st1w {z8.s-z11.s}, pn8, [x1, 8, MUL VL]                 \n"
    "                                                            \n"
    "    add x1, x1, #768                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    st1w {z0.s-z3.s}, pn8, [x1, 0, MUL VL]                  \n"
    "    add x1, x1, #256                                        \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [dst] "r" (data->dst), [end] "r" (data->dst + data->size), [end_aligned] "r" (data->dst + size_aligned)
    : "x0", "x1"
  );

  //printf("done store_reg_adjacent_x4_ilp3\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double store_reg_adjacent_x4_ilp4(const void* args) {
  // ST1W (four register, adjacent, predicated)
  //
  // Bytes per instruction: 256, bytes per loop iteration: 1024 (ILP=4)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 1024);

  //printf("starting store_reg_adjacent_x4_ilp4\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue pn8.s                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[dst]                                            \n"
    "  2:                                                        \n"
    "    st1w {z0.s-z3.s}, pn8, [x1, 0, MUL VL]                  \n"
    "    st1w {z4.s-z7.s}, pn8, [x1, 4, MUL VL]                  \n"
    "    st1w {z8.s-z11.s}, pn8, [x1, 8, MUL VL]                 \n"
    "    st1w {z12.s-z15.s}, pn8, [x1, 12, MUL VL]               \n"
    "                                                            \n"
    "    add x1, x1, #1024                                       \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    st1w {z0.s-z3.s}, pn8, [x1, 0, MUL VL]                  \n"
    "    add x1, x1, #256                                        \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [dst] "r" (data->dst), [end] "r" (data->dst + data->size), [end_aligned] "r" (data->dst + size_aligned)
    : "x0", "x1"
  );

  //printf("done store_reg_adjacent_x4_ilp4\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double store_reg_adjacent_x4_ilp5(const void* args) {
  // ST1W (four register, adjacent, predicated)
  //
  // Bytes per instruction: 256, bytes per loop iteration: 1280 (ILP=5)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 1280);

  //printf("starting store_reg_adjacent_x4_ilp5\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue pn8.s                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[dst]                                            \n"
    "  2:                                                        \n"
    "    st1w {z0.s-z3.s}, pn8, [x1, 0, MUL VL]                  \n"
    "    st1w {z4.s-z7.s}, pn8, [x1, 4, MUL VL]                  \n"
    "    st1w {z8.s-z11.s}, pn8, [x1, 8, MUL VL]                 \n"
    "    st1w {z12.s-z15.s}, pn8, [x1, 12, MUL VL]               \n"
    "    st1w {z16.s-z19.s}, pn8, [x1, 16, MUL VL]               \n"
    "                                                            \n"
    "    add x1, x1, #1280                                       \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    st1w {z0.s-z3.s}, pn8, [x1, 0, MUL VL]                  \n"
    "    add x1, x1, #256                                        \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [dst] "r" (data->dst), [end] "r" (data->dst + data->size), [end_aligned] "r" (data->dst + size_aligned)
    : "x0", "x1"
  );

  //printf("done store_reg_adjacent_x4_ilp5\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double store_reg_adjacent_x4_ilp6(const void* args) {
  // ST1W (four register, adjacent, predicated)
  //
  // Bytes per instruction: 256, bytes per loop iteration: 1536 (ILP=6)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 1536);

  //printf("starting store_reg_adjacent_x4_ilp6\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue pn8.s                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[dst]                                            \n"
    "  2:                                                        \n"
    "    st1w {z0.s-z3.s}, pn8, [x1, 0, MUL VL]                  \n"
    "    st1w {z4.s-z7.s}, pn8, [x1, 4, MUL VL]                  \n"
    "    st1w {z8.s-z11.s}, pn8, [x1, 8, MUL VL]                 \n"
    "    st1w {z12.s-z15.s}, pn8, [x1, 12, MUL VL]               \n"
    "    st1w {z16.s-z19.s}, pn8, [x1, 16, MUL VL]               \n"
    "    st1w {z20.s-z23.s}, pn8, [x1, 20, MUL VL]               \n"
    "                                                            \n"
    "    add x1, x1, #1536                                       \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    st1w {z0.s-z3.s}, pn8, [x1, 0, MUL VL]                  \n"
    "    add x1, x1, #256                                        \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [dst] "r" (data->dst), [end] "r" (data->dst + data->size), [end_aligned] "r" (data->dst + size_aligned)
    : "x0", "x1"
  );

  //printf("done store_reg_adjacent_x4_ilp6\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double store_reg_adjacent_x4_ilp7(const void* args) {
  // ST1W (four register, adjacent, predicated)
  //
  // Bytes per instruction: 256, bytes per loop iteration: 1792 (ILP=7)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 1792);

  //printf("starting store_reg_adjacent_x4_ilp7\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue pn8.s                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[dst]                                            \n"
    "  2:                                                        \n"
    "    st1w {z0.s-z3.s}, pn8, [x1, 0, MUL VL]                  \n"
    "    st1w {z4.s-z7.s}, pn8, [x1, 4, MUL VL]                  \n"
    "    st1w {z8.s-z11.s}, pn8, [x1, 8, MUL VL]                 \n"
    "    st1w {z12.s-z15.s}, pn8, [x1, 12, MUL VL]               \n"
    "    st1w {z16.s-z19.s}, pn8, [x1, 16, MUL VL]               \n"
    "    st1w {z20.s-z23.s}, pn8, [x1, 20, MUL VL]               \n"
    "    st1w {z24.s-z27.s}, pn8, [x1, 24, MUL VL]               \n"
    "                                                            \n"
    "    add x1, x1, #1792                                       \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    st1w {z0.s-z3.s}, pn8, [x1, 0, MUL VL]                  \n"
    "    add x1, x1, #256                                        \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [dst] "r" (data->dst), [end] "r" (data->dst + data->size), [end_aligned] "r" (data->dst + size_aligned)
    : "x0", "x1"
  );

  //printf("done store_reg_adjacent_x4_ilp7\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double store_reg_adjacent_x4_ilp8(const void* args) {
  // ST1W (four register, adjacent, predicated)
  //
  // Bytes per instruction: 256, bytes per loop iteration: 2048 (ILP=8)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 2048);

  //printf("starting store_reg_adjacent_x4_ilp8\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue pn8.s                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[dst]                                            \n"
    "  2:                                                        \n"
    "    st1w {z0.s-z3.s}, pn8, [x1, 0, MUL VL]                  \n"
    "    st1w {z4.s-z7.s}, pn8, [x1, 4, MUL VL]                  \n"
    "    st1w {z8.s-z11.s}, pn8, [x1, 8, MUL VL]                 \n"
    "    st1w {z12.s-z15.s}, pn8, [x1, 12, MUL VL]               \n"
    "    st1w {z16.s-z19.s}, pn8, [x1, 16, MUL VL]               \n"
    "    st1w {z20.s-z23.s}, pn8, [x1, 20, MUL VL]               \n"
    "    st1w {z24.s-z27.s}, pn8, [x1, 24, MUL VL]               \n"
    "    st1w {z28.s-z31.s}, pn8, [x1, 28, MUL VL]               \n"
    "                                                            \n"
    "    add x1, x1, #2048                                       \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    st1w {z0.s-z3.s}, pn8, [x1, 0, MUL VL]                  \n"
    "    add x1, x1, #256                                        \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [dst] "r" (data->dst), [end] "r" (data->dst + data->size), [end_aligned] "r" (data->dst + size_aligned)
    : "x0", "x1"
  );

  //printf("done store_reg_adjacent_x4_ilp8\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double copy_reg_adjacent_x4_ilp1(const void* args) {
  // LD1W/ST1W (four register, adjacent, predicated)
  //
  // Bytes per instruction: 256, bytes per loop iteration: 256 (ILP=1)
  const benchmark_data_t* data = args;

  //printf("starting copy_reg_adjacent_x4_ilp1\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue pn8.s                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  mov x2, %[dst]                                            \n"
    "  2:                                                        \n"
    "    ld1w {z0.s-z3.s}, pn8/z, [x1, 0, MUL VL]                \n"
    "                                                            \n"
    "    st1w {z0.s-z3.s}, pn8, [x2, 0, MUL VL]                  \n"
    "                                                            \n"
    "    add x1, x1, #256                                        \n"
    "    add x2, x2, #256                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 2b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [dst] "r" (data->dst), [end] "r" (data->src + data->size)
    : "x0", "x1", "x2"
  );

  //printf("done copy_reg_adjacent_x4_ilp1\n");

  // number of bytes transferred overall
  return 2.0*data->total_size;
}


static double copy_reg_adjacent_x4_ilp2(const void* args) {
  // LD1W/ST1W (four register, adjacent, predicated)
  //
  // Bytes per instruction: 256, bytes per loop iteration: 512 (ILP=2)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 512);

  //printf("starting copy_reg_adjacent_x4_ilp2\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue pn8.s                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  mov x2, %[dst]                                            \n"
    "  2:                                                        \n"
    "    ld1w {z0.s-z3.s}, pn8/z, [x1, 0, MUL VL]                \n"
    "    ld1w {z4.s-z7.s}, pn8/z, [x1, 4, MUL VL]                \n"
    "                                                            \n"
    "    st1w {z0.s-z3.s}, pn8, [x2, 0, MUL VL]                  \n"
    "    st1w {z4.s-z7.s}, pn8, [x2, 4, MUL VL]                  \n"
    "                                                            \n"
    "    add x1, x1, #512                                        \n"
    "    add x2, x2, #512                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    ld1w {z0.s-z3.s}, pn8/z, [x1, 0, MUL VL]                \n"
    "    add x1, x1, #256                                        \n"
    "    st1w {z0.s-z3.s}, pn8, [x2, 0, MUL VL]                  \n"
    "    add x2, x2, #256                                        \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [dst] "r" (data->dst), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1", "x2"
  );

  //printf("done copy_reg_adjacent_x4_ilp2\n");

  // number of bytes transferred overall
  return 2.0*data->total_size;
}


static double copy_reg_adjacent_x4_ilp3(const void* args) {
  // LD1W/ST1W (four register, adjacent, predicated)
  //
  // Bytes per instruction: 256, bytes per loop iteration: 768 (ILP=3)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 768);

  //printf("starting copy_reg_adjacent_x4_ilp3\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue pn8.s                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  mov x2, %[dst]                                            \n"
    "  2:                                                        \n"
    "    ld1w {z0.s-z3.s}, pn8/z, [x1, 0, MUL VL]                \n"
    "    ld1w {z4.s-z7.s}, pn8/z, [x1, 4, MUL VL]                \n"
    "    ld1w {z8.s-z11.s}, pn8/z, [x1, 8, MUL VL]               \n"
    "                                                            \n"
    "    st1w {z0.s-z3.s}, pn8, [x2, 0, MUL VL]                  \n"
    "    st1w {z4.s-z7.s}, pn8, [x2, 4, MUL VL]                  \n"
    "    st1w {z8.s-z11.s}, pn8, [x2, 8, MUL VL]                 \n"
    "                                                            \n"
    "    add x1, x1, #768                                        \n"
    "    add x2, x2, #768                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    ld1w {z0.s-z3.s}, pn8/z, [x1, 0, MUL VL]                \n"
    "    add x1, x1, #256                                        \n"
    "    st1w {z0.s-z3.s}, pn8, [x2, 0, MUL VL]                  \n"
    "    add x2, x2, #256                                        \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [dst] "r" (data->dst), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1", "x2"
  );

  //printf("done copy_reg_adjacent_x4_ilp3\n");

  // number of bytes transferred overall
  return 2.0*data->total_size;
}


static double copy_reg_adjacent_x4_ilp4(const void* args) {
  // LD1W/ST1W (four register, adjacent, predicated)
  //
  // Bytes per instruction: 256, bytes per loop iteration: 1024 (ILP=4)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 1024);

  //printf("starting copy_reg_adjacent_x4_ilp4\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue pn8.s                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  mov x2, %[dst]                                            \n"
    "  2:                                                        \n"
    "    ld1w {z0.s-z3.s}, pn8/z, [x1, 0, MUL VL]                \n"
    "    ld1w {z4.s-z7.s}, pn8/z, [x1, 4, MUL VL]                \n"
    "    ld1w {z8.s-z11.s}, pn8/z, [x1, 8, MUL VL]               \n"
    "    ld1w {z12.s-z15.s}, pn8/z, [x1, 12, MUL VL]             \n"
    "                                                            \n"
    "    st1w {z0.s-z3.s}, pn8, [x2, 0, MUL VL]                  \n"
    "    st1w {z4.s-z7.s}, pn8, [x2, 4, MUL VL]                  \n"
    "    st1w {z8.s-z11.s}, pn8, [x2, 8, MUL VL]                 \n"
    "    st1w {z12.s-z15.s}, pn8, [x2, 12, MUL VL]               \n"
    "                                                            \n"
    "    add x1, x1, #1024                                       \n"
    "    add x2, x2, #1024                                       \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    ld1w {z0.s-z3.s}, pn8/z, [x1, 0, MUL VL]                \n"
    "    add x1, x1, #256                                        \n"
    "    st1w {z0.s-z3.s}, pn8, [x2, 0, MUL VL]                  \n"
    "    add x2, x2, #256                                        \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [dst] "r" (data->dst), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1", "x2"
  );

  //printf("done copy_reg_adjacent_x4_ilp4\n");

  // number of bytes transferred overall
  return 2.0*data->total_size;
}


static double copy_reg_adjacent_x4_ilp5(const void* args) {
  // LD1W/ST1W (four register, adjacent, predicated)
  //
  // Bytes per instruction: 256, bytes per loop iteration: 1280 (ILP=5)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 1280);

  //printf("starting copy_reg_adjacent_x4_ilp5\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue pn8.s                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  mov x2, %[dst]                                            \n"
    "  2:                                                        \n"
    "    ld1w {z0.s-z3.s}, pn8/z, [x1, 0, MUL VL]                \n"
    "    ld1w {z4.s-z7.s}, pn8/z, [x1, 4, MUL VL]                \n"
    "    ld1w {z8.s-z11.s}, pn8/z, [x1, 8, MUL VL]               \n"
    "    ld1w {z12.s-z15.s}, pn8/z, [x1, 12, MUL VL]             \n"
    "    ld1w {z16.s-z19.s}, pn8/z, [x1, 16, MUL VL]             \n"
    "                                                            \n"
    "    st1w {z0.s-z3.s}, pn8, [x2, 0, MUL VL]                  \n"
    "    st1w {z4.s-z7.s}, pn8, [x2, 4, MUL VL]                  \n"
    "    st1w {z8.s-z11.s}, pn8, [x2, 8, MUL VL]                 \n"
    "    st1w {z12.s-z15.s}, pn8, [x2, 12, MUL VL]               \n"
    "    st1w {z16.s-z19.s}, pn8, [x2, 16, MUL VL]               \n"
    "                                                            \n"
    "    add x1, x1, #1280                                       \n"
    "    add x2, x2, #1280                                       \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    ld1w {z0.s-z3.s}, pn8/z, [x1, 0, MUL VL]                \n"
    "    add x1, x1, #256                                        \n"
    "    st1w {z0.s-z3.s}, pn8, [x2, 0, MUL VL]                  \n"
    "    add x2, x2, #256                                        \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [dst] "r" (data->dst), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1", "x2"
  );

  //printf("done copy_reg_adjacent_x4_ilp5\n");

  // number of bytes transferred overall
  return 2.0*data->total_size;
}


static double copy_reg_adjacent_x4_ilp6(const void* args) {
  // LD1W/ST1W (four register, adjacent, predicated)
  //
  // Bytes per instruction: 256, bytes per loop iteration: 1536 (ILP=6)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 1536);

  //printf("starting copy_reg_adjacent_x4_ilp6\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue pn8.s                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  mov x2, %[dst]                                            \n"
    "  2:                                                        \n"
    "    ld1w {z0.s-z3.s}, pn8/z, [x1, 0, MUL VL]                \n"
    "    ld1w {z4.s-z7.s}, pn8/z, [x1, 4, MUL VL]                \n"
    "    ld1w {z8.s-z11.s}, pn8/z, [x1, 8, MUL VL]               \n"
    "    ld1w {z12.s-z15.s}, pn8/z, [x1, 12, MUL VL]             \n"
    "    ld1w {z16.s-z19.s}, pn8/z, [x1, 16, MUL VL]             \n"
    "    ld1w {z20.s-z23.s}, pn8/z, [x1, 20, MUL VL]             \n"
    "                                                            \n"
    "    st1w {z0.s-z3.s}, pn8, [x2, 0, MUL VL]                  \n"
    "    st1w {z4.s-z7.s}, pn8, [x2, 4, MUL VL]                  \n"
    "    st1w {z8.s-z11.s}, pn8, [x2, 8, MUL VL]                 \n"
    "    st1w {z12.s-z15.s}, pn8, [x2, 12, MUL VL]               \n"
    "    st1w {z16.s-z19.s}, pn8, [x2, 16, MUL VL]               \n"
    "    st1w {z20.s-z23.s}, pn8, [x2, 20, MUL VL]               \n"
    "                                                            \n"
    "    add x1, x1, #1536                                       \n"
    "    add x2, x2, #1536                                       \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    ld1w {z0.s-z3.s}, pn8/z, [x1, 0, MUL VL]                \n"
    "    add x1, x1, #256                                        \n"
    "    st1w {z0.s-z3.s}, pn8, [x2, 0, MUL VL]                  \n"
    "    add x2, x2, #256                                        \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [dst] "r" (data->dst), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1", "x2"
  );

  //printf("done copy_reg_adjacent_x4_ilp6\n");

  // number of bytes transferred overall
  return 2.0*data->total_size;
}


static double copy_reg_adjacent_x4_ilp7(const void* args) {
  // LD1W/ST1W (four register, adjacent, predicated)
  //
  // Bytes per instruction: 256, bytes per loop iteration: 1792 (ILP=7)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 1792);

  //printf("starting copy_reg_adjacent_x4_ilp7\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue pn8.s                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  mov x2, %[dst]                                            \n"
    "  2:                                                        \n"
    "    ld1w {z0.s-z3.s}, pn8/z, [x1, 0, MUL VL]                \n"
    "    ld1w {z4.s-z7.s}, pn8/z, [x1, 4, MUL VL]                \n"
    "    ld1w {z8.s-z11.s}, pn8/z, [x1, 8, MUL VL]               \n"
    "    ld1w {z12.s-z15.s}, pn8/z, [x1, 12, MUL VL]             \n"
    "    ld1w {z16.s-z19.s}, pn8/z, [x1, 16, MUL VL]             \n"
    "    ld1w {z20.s-z23.s}, pn8/z, [x1, 20, MUL VL]             \n"
    "    ld1w {z24.s-z27.s}, pn8/z, [x1, 24, MUL VL]             \n"
    "                                                            \n"
    "    st1w {z0.s-z3.s}, pn8, [x2, 0, MUL VL]                  \n"
    "    st1w {z4.s-z7.s}, pn8, [x2, 4, MUL VL]                  \n"
    "    st1w {z8.s-z11.s}, pn8, [x2, 8, MUL VL]                 \n"
    "    st1w {z12.s-z15.s}, pn8, [x2, 12, MUL VL]               \n"
    "    st1w {z16.s-z19.s}, pn8, [x2, 16, MUL VL]               \n"
    "    st1w {z20.s-z23.s}, pn8, [x2, 20, MUL VL]               \n"
    "    st1w {z24.s-z27.s}, pn8, [x2, 24, MUL VL]               \n"
    "                                                            \n"
    "    add x1, x1, #1792                                       \n"
    "    add x2, x2, #1792                                       \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    ld1w {z0.s-z3.s}, pn8/z, [x1, 0, MUL VL]                \n"
    "    add x1, x1, #256                                        \n"
    "    st1w {z0.s-z3.s}, pn8, [x2, 0, MUL VL]                  \n"
    "    add x2, x2, #256                                        \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [dst] "r" (data->dst), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1", "x2"
  );

  //printf("done copy_reg_adjacent_x4_ilp7\n");

  // number of bytes transferred overall
  return 2.0*data->total_size;
}


static double copy_reg_adjacent_x4_ilp8(const void* args) {
  // LD1W/ST1W (four register, adjacent, predicated)
  //
  // Bytes per instruction: 256, bytes per loop iteration: 2048 (ILP=8)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 2048);

  //printf("starting copy_reg_adjacent_x4_ilp8\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue pn8.s                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  mov x2, %[dst]                                            \n"
    "  2:                                                        \n"
    "    ld1w {z0.s-z3.s}, pn8/z, [x1, 0, MUL VL]                \n"
    "    ld1w {z4.s-z7.s}, pn8/z, [x1, 4, MUL VL]                \n"
    "    ld1w {z8.s-z11.s}, pn8/z, [x1, 8, MUL VL]               \n"
    "    ld1w {z12.s-z15.s}, pn8/z, [x1, 12, MUL VL]             \n"
    "    ld1w {z16.s-z19.s}, pn8/z, [x1, 16, MUL VL]             \n"
    "    ld1w {z20.s-z23.s}, pn8/z, [x1, 20, MUL VL]             \n"
    "    ld1w {z24.s-z27.s}, pn8/z, [x1, 24, MUL VL]             \n"
    "    ld1w {z28.s-z31.s}, pn8/z, [x1, 28, MUL VL]             \n"
    "                                                            \n"
    "    st1w {z0.s-z3.s}, pn8, [x2, 0, MUL VL]                  \n"
    "    st1w {z4.s-z7.s}, pn8, [x2, 4, MUL VL]                  \n"
    "    st1w {z8.s-z11.s}, pn8, [x2, 8, MUL VL]                 \n"
    "    st1w {z12.s-z15.s}, pn8, [x2, 12, MUL VL]               \n"
    "    st1w {z16.s-z19.s}, pn8, [x2, 16, MUL VL]               \n"
    "    st1w {z20.s-z23.s}, pn8, [x2, 20, MUL VL]               \n"
    "    st1w {z24.s-z27.s}, pn8, [x2, 24, MUL VL]               \n"
    "    st1w {z28.s-z31.s}, pn8, [x2, 28, MUL VL]               \n"
    "                                                            \n"
    "    add x1, x1, #2048                                       \n"
    "    add x2, x2, #2048                                       \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    ld1w {z0.s-z3.s}, pn8/z, [x1, 0, MUL VL]                \n"
    "    add x1, x1, #256                                        \n"
    "    st1w {z0.s-z3.s}, pn8, [x2, 0, MUL VL]                  \n"
    "    add x2, x2, #256                                        \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [dst] "r" (data->dst), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1", "x2"
  );

  //printf("done copy_reg_adjacent_x4_ilp8\n");

  // number of bytes transferred overall
  return 2.0*data->total_size;
}


static double load_reg_strided_x2_ilp1(const void* args) {
  // LD1W (two register, strided, predicated)
  //
  // Bytes per instruction: 128, bytes per loop iteration: 128 (ILP=1)
  const benchmark_data_t* data = args;

  //printf("starting load_reg_strided_x2_ilp1\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue pn8.s                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  2:                                                        \n"
    "    ld1w {z0.s, z8.s}, pn8/z, [x1, 0, MUL VL]               \n"
    "                                                            \n"
    "    add x1, x1, #128                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 2b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [end] "r" (data->src + data->size)
    : "x0", "x1"
  );

  //printf("done load_reg_strided_x2_ilp1\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double load_reg_strided_x2_ilp2(const void* args) {
  // LD1W (two register, strided, predicated)
  //
  // Bytes per instruction: 128, bytes per loop iteration: 256 (ILP=2)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 256);

  //printf("starting load_reg_strided_x2_ilp2\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue pn8.s                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  2:                                                        \n"
    "    ld1w {z0.s, z8.s}, pn8/z, [x1, 0, MUL VL]               \n"
    "    ld1w {z1.s, z9.s}, pn8/z, [x1, 2, MUL VL]               \n"
    "                                                            \n"
    "    add x1, x1, #256                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    ld1w {z0.s, z8.s}, pn8/z, [x1, 0, MUL VL]               \n"
    "    add x1, x1, #128                                        \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1"
  );

  //printf("done load_reg_strided_x2_ilp2\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double load_reg_strided_x2_ilp3(const void* args) {
  // LD1W (two register, strided, predicated)
  //
  // Bytes per instruction: 128, bytes per loop iteration: 384 (ILP=3)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 384);

  //printf("starting load_reg_strided_x2_ilp3\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue pn8.s                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  2:                                                        \n"
    "    ld1w {z0.s, z8.s}, pn8/z, [x1, 0, MUL VL]               \n"
    "    ld1w {z1.s, z9.s}, pn8/z, [x1, 2, MUL VL]               \n"
    "    ld1w {z2.s, z10.s}, pn8/z, [x1, 4, MUL VL]              \n"
    "                                                            \n"
    "    add x1, x1, #384                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    ld1w {z0.s, z8.s}, pn8/z, [x1, 0, MUL VL]               \n"
    "    add x1, x1, #128                                        \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1"
  );

  //printf("done load_reg_strided_x2_ilp3\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double load_reg_strided_x2_ilp4(const void* args) {
  // LD1W (two register, strided, predicated)
  //
  // Bytes per instruction: 128, bytes per loop iteration: 512 (ILP=4)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 512);

  //printf("starting load_reg_strided_x2_ilp4\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue pn8.s                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  2:                                                        \n"
    "    ld1w {z0.s, z8.s}, pn8/z, [x1, 0, MUL VL]               \n"
    "    ld1w {z1.s, z9.s}, pn8/z, [x1, 2, MUL VL]               \n"
    "    ld1w {z2.s, z10.s}, pn8/z, [x1, 4, MUL VL]              \n"
    "    ld1w {z3.s, z11.s}, pn8/z, [x1, 6, MUL VL]              \n"
    "                                                            \n"
    "    add x1, x1, #512                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    ld1w {z0.s, z8.s}, pn8/z, [x1, 0, MUL VL]               \n"
    "    add x1, x1, #128                                        \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1"
  );

  //printf("done load_reg_strided_x2_ilp4\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double load_reg_strided_x2_ilp5(const void* args) {
  // LD1W (two register, strided, predicated)
  //
  // Bytes per instruction: 128, bytes per loop iteration: 640 (ILP=5)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 640);

  //printf("starting load_reg_strided_x2_ilp5\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue pn8.s                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  2:                                                        \n"
    "    ld1w {z0.s, z8.s}, pn8/z, [x1, 0, MUL VL]               \n"
    "    ld1w {z1.s, z9.s}, pn8/z, [x1, 2, MUL VL]               \n"
    "    ld1w {z2.s, z10.s}, pn8/z, [x1, 4, MUL VL]              \n"
    "    ld1w {z3.s, z11.s}, pn8/z, [x1, 6, MUL VL]              \n"
    "    ld1w {z4.s, z12.s}, pn8/z, [x1, 8, MUL VL]              \n"
    "                                                            \n"
    "    add x1, x1, #640                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    ld1w {z0.s, z8.s}, pn8/z, [x1, 0, MUL VL]               \n"
    "    add x1, x1, #128                                        \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1"
  );

  //printf("done load_reg_strided_x2_ilp5\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double load_reg_strided_x2_ilp6(const void* args) {
  // LD1W (two register, strided, predicated)
  //
  // Bytes per instruction: 128, bytes per loop iteration: 768 (ILP=6)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 768);

  //printf("starting load_reg_strided_x2_ilp6\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue pn8.s                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  2:                                                        \n"
    "    ld1w {z0.s, z8.s}, pn8/z, [x1, 0, MUL VL]               \n"
    "    ld1w {z1.s, z9.s}, pn8/z, [x1, 2, MUL VL]               \n"
    "    ld1w {z2.s, z10.s}, pn8/z, [x1, 4, MUL VL]              \n"
    "    ld1w {z3.s, z11.s}, pn8/z, [x1, 6, MUL VL]              \n"
    "    ld1w {z4.s, z12.s}, pn8/z, [x1, 8, MUL VL]              \n"
    "    ld1w {z5.s, z13.s}, pn8/z, [x1, 10, MUL VL]             \n"
    "                                                            \n"
    "    add x1, x1, #768                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    ld1w {z0.s, z8.s}, pn8/z, [x1, 0, MUL VL]               \n"
    "    add x1, x1, #128                                        \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1"
  );

  //printf("done load_reg_strided_x2_ilp6\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double load_reg_strided_x2_ilp7(const void* args) {
  // LD1W (two register, strided, predicated)
  //
  // Bytes per instruction: 128, bytes per loop iteration: 896 (ILP=7)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 896);

  //printf("starting load_reg_strided_x2_ilp7\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue pn8.s                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  2:                                                        \n"
    "    ld1w {z0.s, z8.s}, pn8/z, [x1, 0, MUL VL]               \n"
    "    ld1w {z1.s, z9.s}, pn8/z, [x1, 2, MUL VL]               \n"
    "    ld1w {z2.s, z10.s}, pn8/z, [x1, 4, MUL VL]              \n"
    "    ld1w {z3.s, z11.s}, pn8/z, [x1, 6, MUL VL]              \n"
    "    ld1w {z4.s, z12.s}, pn8/z, [x1, 8, MUL VL]              \n"
    "    ld1w {z5.s, z13.s}, pn8/z, [x1, 10, MUL VL]             \n"
    "    ld1w {z6.s, z14.s}, pn8/z, [x1, 12, MUL VL]             \n"
    "                                                            \n"
    "    add x1, x1, #896                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    ld1w {z0.s, z8.s}, pn8/z, [x1, 0, MUL VL]               \n"
    "    add x1, x1, #128                                        \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1"
  );

  //printf("done load_reg_strided_x2_ilp7\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double load_reg_strided_x2_ilp8(const void* args) {
  // LD1W (two register, strided, predicated)
  //
  // Bytes per instruction: 128, bytes per loop iteration: 1024 (ILP=8)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 1024);

  //printf("starting load_reg_strided_x2_ilp8\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue pn8.s                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  2:                                                        \n"
    "    ld1w {z0.s, z8.s}, pn8/z, [x1, 0, MUL VL]               \n"
    "    ld1w {z1.s, z9.s}, pn8/z, [x1, 2, MUL VL]               \n"
    "    ld1w {z2.s, z10.s}, pn8/z, [x1, 4, MUL VL]              \n"
    "    ld1w {z3.s, z11.s}, pn8/z, [x1, 6, MUL VL]              \n"
    "    ld1w {z4.s, z12.s}, pn8/z, [x1, 8, MUL VL]              \n"
    "    ld1w {z5.s, z13.s}, pn8/z, [x1, 10, MUL VL]             \n"
    "    ld1w {z6.s, z14.s}, pn8/z, [x1, 12, MUL VL]             \n"
    "    ld1w {z7.s, z15.s}, pn8/z, [x1, 14, MUL VL]             \n"
    "                                                            \n"
    "    add x1, x1, #1024                                       \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    ld1w {z0.s, z8.s}, pn8/z, [x1, 0, MUL VL]               \n"
    "    add x1, x1, #128                                        \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1"
  );

  //printf("done load_reg_strided_x2_ilp8\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double store_reg_strided_x2_ilp1(const void* args) {
  // ST1W (two register, strided, predicated)
  //
  // Bytes per instruction: 128, bytes per loop iteration: 128 (ILP=1)
  const benchmark_data_t* data = args;

  //printf("starting store_reg_strided_x2_ilp1\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue pn8.s                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[dst]                                            \n"
    "  2:                                                        \n"
    "    st1w {z0.s, z8.s}, pn8, [x1, 0, MUL VL]                 \n"
    "                                                            \n"
    "    add x1, x1, #128                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 2b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [dst] "r" (data->dst), [end] "r" (data->dst + data->size)
    : "x0", "x1"
  );

  //printf("done store_reg_strided_x2_ilp1\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double store_reg_strided_x2_ilp2(const void* args) {
  // ST1W (two register, strided, predicated)
  //
  // Bytes per instruction: 128, bytes per loop iteration: 256 (ILP=2)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 256);

  //printf("starting store_reg_strided_x2_ilp2\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue pn8.s                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[dst]                                            \n"
    "  2:                                                        \n"
    "    st1w {z0.s, z8.s}, pn8, [x1, 0, MUL VL]                 \n"
    "    st1w {z1.s, z9.s}, pn8, [x1, 2, MUL VL]                 \n"
    "                                                            \n"
    "    add x1, x1, #256                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    st1w {z0.s, z8.s}, pn8, [x1, 0, MUL VL]                 \n"
    "    add x1, x1, #128                                        \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [dst] "r" (data->dst), [end] "r" (data->dst + data->size), [end_aligned] "r" (data->dst + size_aligned)
    : "x0", "x1"
  );

  //printf("done store_reg_strided_x2_ilp2\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double store_reg_strided_x2_ilp3(const void* args) {
  // ST1W (two register, strided, predicated)
  //
  // Bytes per instruction: 128, bytes per loop iteration: 384 (ILP=3)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 384);

  //printf("starting store_reg_strided_x2_ilp3\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue pn8.s                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[dst]                                            \n"
    "  2:                                                        \n"
    "    st1w {z0.s, z8.s}, pn8, [x1, 0, MUL VL]                 \n"
    "    st1w {z1.s, z9.s}, pn8, [x1, 2, MUL VL]                 \n"
    "    st1w {z2.s, z10.s}, pn8, [x1, 4, MUL VL]                \n"
    "                                                            \n"
    "    add x1, x1, #384                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    st1w {z0.s, z8.s}, pn8, [x1, 0, MUL VL]                 \n"
    "    add x1, x1, #128                                        \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [dst] "r" (data->dst), [end] "r" (data->dst + data->size), [end_aligned] "r" (data->dst + size_aligned)
    : "x0", "x1"
  );

  //printf("done store_reg_strided_x2_ilp3\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double store_reg_strided_x2_ilp4(const void* args) {
  // ST1W (two register, strided, predicated)
  //
  // Bytes per instruction: 128, bytes per loop iteration: 512 (ILP=4)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 512);

  //printf("starting store_reg_strided_x2_ilp4\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue pn8.s                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[dst]                                            \n"
    "  2:                                                        \n"
    "    st1w {z0.s, z8.s}, pn8, [x1, 0, MUL VL]                 \n"
    "    st1w {z1.s, z9.s}, pn8, [x1, 2, MUL VL]                 \n"
    "    st1w {z2.s, z10.s}, pn8, [x1, 4, MUL VL]                \n"
    "    st1w {z3.s, z11.s}, pn8, [x1, 6, MUL VL]                \n"
    "                                                            \n"
    "    add x1, x1, #512                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    st1w {z0.s, z8.s}, pn8, [x1, 0, MUL VL]                 \n"
    "    add x1, x1, #128                                        \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [dst] "r" (data->dst), [end] "r" (data->dst + data->size), [end_aligned] "r" (data->dst + size_aligned)
    : "x0", "x1"
  );

  //printf("done store_reg_strided_x2_ilp4\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double store_reg_strided_x2_ilp5(const void* args) {
  // ST1W (two register, strided, predicated)
  //
  // Bytes per instruction: 128, bytes per loop iteration: 640 (ILP=5)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 640);

  //printf("starting store_reg_strided_x2_ilp5\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue pn8.s                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[dst]                                            \n"
    "  2:                                                        \n"
    "    st1w {z0.s, z8.s}, pn8, [x1, 0, MUL VL]                 \n"
    "    st1w {z1.s, z9.s}, pn8, [x1, 2, MUL VL]                 \n"
    "    st1w {z2.s, z10.s}, pn8, [x1, 4, MUL VL]                \n"
    "    st1w {z3.s, z11.s}, pn8, [x1, 6, MUL VL]                \n"
    "    st1w {z4.s, z12.s}, pn8, [x1, 8, MUL VL]                \n"
    "                                                            \n"
    "    add x1, x1, #640                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    st1w {z0.s, z8.s}, pn8, [x1, 0, MUL VL]                 \n"
    "    add x1, x1, #128                                        \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [dst] "r" (data->dst), [end] "r" (data->dst + data->size), [end_aligned] "r" (data->dst + size_aligned)
    : "x0", "x1"
  );

  //printf("done store_reg_strided_x2_ilp5\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double store_reg_strided_x2_ilp6(const void* args) {
  // ST1W (two register, strided, predicated)
  //
  // Bytes per instruction: 128, bytes per loop iteration: 768 (ILP=6)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 768);

  //printf("starting store_reg_strided_x2_ilp6\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue pn8.s                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[dst]                                            \n"
    "  2:                                                        \n"
    "    st1w {z0.s, z8.s}, pn8, [x1, 0, MUL VL]                 \n"
    "    st1w {z1.s, z9.s}, pn8, [x1, 2, MUL VL]                 \n"
    "    st1w {z2.s, z10.s}, pn8, [x1, 4, MUL VL]                \n"
    "    st1w {z3.s, z11.s}, pn8, [x1, 6, MUL VL]                \n"
    "    st1w {z4.s, z12.s}, pn8, [x1, 8, MUL VL]                \n"
    "    st1w {z5.s, z13.s}, pn8, [x1, 10, MUL VL]               \n"
    "                                                            \n"
    "    add x1, x1, #768                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    st1w {z0.s, z8.s}, pn8, [x1, 0, MUL VL]                 \n"
    "    add x1, x1, #128                                        \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [dst] "r" (data->dst), [end] "r" (data->dst + data->size), [end_aligned] "r" (data->dst + size_aligned)
    : "x0", "x1"
  );

  //printf("done store_reg_strided_x2_ilp6\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double store_reg_strided_x2_ilp7(const void* args) {
  // ST1W (two register, strided, predicated)
  //
  // Bytes per instruction: 128, bytes per loop iteration: 896 (ILP=7)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 896);

  //printf("starting store_reg_strided_x2_ilp7\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue pn8.s                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[dst]                                            \n"
    "  2:                                                        \n"
    "    st1w {z0.s, z8.s}, pn8, [x1, 0, MUL VL]                 \n"
    "    st1w {z1.s, z9.s}, pn8, [x1, 2, MUL VL]                 \n"
    "    st1w {z2.s, z10.s}, pn8, [x1, 4, MUL VL]                \n"
    "    st1w {z3.s, z11.s}, pn8, [x1, 6, MUL VL]                \n"
    "    st1w {z4.s, z12.s}, pn8, [x1, 8, MUL VL]                \n"
    "    st1w {z5.s, z13.s}, pn8, [x1, 10, MUL VL]               \n"
    "    st1w {z6.s, z14.s}, pn8, [x1, 12, MUL VL]               \n"
    "                                                            \n"
    "    add x1, x1, #896                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    st1w {z0.s, z8.s}, pn8, [x1, 0, MUL VL]                 \n"
    "    add x1, x1, #128                                        \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [dst] "r" (data->dst), [end] "r" (data->dst + data->size), [end_aligned] "r" (data->dst + size_aligned)
    : "x0", "x1"
  );

  //printf("done store_reg_strided_x2_ilp7\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double store_reg_strided_x2_ilp8(const void* args) {
  // ST1W (two register, strided, predicated)
  //
  // Bytes per instruction: 128, bytes per loop iteration: 1024 (ILP=8)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 1024);

  //printf("starting store_reg_strided_x2_ilp8\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue pn8.s                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[dst]                                            \n"
    "  2:                                                        \n"
    "    st1w {z0.s, z8.s}, pn8, [x1, 0, MUL VL]                 \n"
    "    st1w {z1.s, z9.s}, pn8, [x1, 2, MUL VL]                 \n"
    "    st1w {z2.s, z10.s}, pn8, [x1, 4, MUL VL]                \n"
    "    st1w {z3.s, z11.s}, pn8, [x1, 6, MUL VL]                \n"
    "    st1w {z4.s, z12.s}, pn8, [x1, 8, MUL VL]                \n"
    "    st1w {z5.s, z13.s}, pn8, [x1, 10, MUL VL]               \n"
    "    st1w {z6.s, z14.s}, pn8, [x1, 12, MUL VL]               \n"
    "    st1w {z7.s, z15.s}, pn8, [x1, 14, MUL VL]               \n"
    "                                                            \n"
    "    add x1, x1, #1024                                       \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    st1w {z0.s, z8.s}, pn8, [x1, 0, MUL VL]                 \n"
    "    add x1, x1, #128                                        \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [dst] "r" (data->dst), [end] "r" (data->dst + data->size), [end_aligned] "r" (data->dst + size_aligned)
    : "x0", "x1"
  );

  //printf("done store_reg_strided_x2_ilp8\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double copy_reg_strided_x2_ilp1(const void* args) {
  // LD1W/ST1W (two register, strided, predicated)
  //
  // Bytes per instruction: 128, bytes per loop iteration: 128 (ILP=1)
  const benchmark_data_t* data = args;

  //printf("starting copy_reg_strided_x2_ilp1\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue pn8.s                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  mov x2, %[dst]                                            \n"
    "  2:                                                        \n"
    "    ld1w {z0.s, z8.s}, pn8/z, [x1, 0, MUL VL]               \n"
    "                                                            \n"
    "    st1w {z0.s, z8.s}, pn8, [x2, 0, MUL VL]                 \n"
    "                                                            \n"
    "    add x1, x1, #128                                        \n"
    "    add x2, x2, #128                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 2b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [dst] "r" (data->dst), [end] "r" (data->src + data->size)
    : "x0", "x1", "x2"
  );

  //printf("done copy_reg_strided_x2_ilp1\n");

  // number of bytes transferred overall
  return 2.0*data->total_size;
}


static double copy_reg_strided_x2_ilp2(const void* args) {
  // LD1W/ST1W (two register, strided, predicated)
  //
  // Bytes per instruction: 128, bytes per loop iteration: 256 (ILP=2)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 256);

  //printf("starting copy_reg_strided_x2_ilp2\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue pn8.s                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  mov x2, %[dst]                                            \n"
    "  2:                                                        \n"
    "    ld1w {z0.s, z8.s}, pn8/z, [x1, 0, MUL VL]               \n"
    "    ld1w {z1.s, z9.s}, pn8/z, [x1, 2, MUL VL]               \n"
    "                                                            \n"
    "    st1w {z0.s, z8.s}, pn8, [x2, 0, MUL VL]                 \n"
    "    st1w {z1.s, z9.s}, pn8, [x2, 2, MUL VL]                 \n"
    "                                                            \n"
    "    add x1, x1, #256                                        \n"
    "    add x2, x2, #256                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    ld1w {z0.s, z8.s}, pn8/z, [x1, 0, MUL VL]               \n"
    "    add x1, x1, #128                                        \n"
    "    st1w {z0.s, z8.s}, pn8, [x2, 0, MUL VL]                 \n"
    "    add x2, x2, #128                                        \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [dst] "r" (data->dst), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1", "x2"
  );

  //printf("done copy_reg_strided_x2_ilp2\n");

  // number of bytes transferred overall
  return 2.0*data->total_size;
}


static double copy_reg_strided_x2_ilp3(const void* args) {
  // LD1W/ST1W (two register, strided, predicated)
  //
  // Bytes per instruction: 128, bytes per loop iteration: 384 (ILP=3)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 384);

  //printf("starting copy_reg_strided_x2_ilp3\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue pn8.s                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  mov x2, %[dst]                                            \n"
    "  2:                                                        \n"
    "    ld1w {z0.s, z8.s}, pn8/z, [x1, 0, MUL VL]               \n"
    "    ld1w {z1.s, z9.s}, pn8/z, [x1, 2, MUL VL]               \n"
    "    ld1w {z2.s, z10.s}, pn8/z, [x1, 4, MUL VL]              \n"
    "                                                            \n"
    "    st1w {z0.s, z8.s}, pn8, [x2, 0, MUL VL]                 \n"
    "    st1w {z1.s, z9.s}, pn8, [x2, 2, MUL VL]                 \n"
    "    st1w {z2.s, z10.s}, pn8, [x2, 4, MUL VL]                \n"
    "                                                            \n"
    "    add x1, x1, #384                                        \n"
    "    add x2, x2, #384                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    ld1w {z0.s, z8.s}, pn8/z, [x1, 0, MUL VL]               \n"
    "    add x1, x1, #128                                        \n"
    "    st1w {z0.s, z8.s}, pn8, [x2, 0, MUL VL]                 \n"
    "    add x2, x2, #128                                        \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [dst] "r" (data->dst), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1", "x2"
  );

  //printf("done copy_reg_strided_x2_ilp3\n");

  // number of bytes transferred overall
  return 2.0*data->total_size;
}


static double copy_reg_strided_x2_ilp4(const void* args) {
  // LD1W/ST1W (two register, strided, predicated)
  //
  // Bytes per instruction: 128, bytes per loop iteration: 512 (ILP=4)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 512);

  //printf("starting copy_reg_strided_x2_ilp4\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue pn8.s                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  mov x2, %[dst]                                            \n"
    "  2:                                                        \n"
    "    ld1w {z0.s, z8.s}, pn8/z, [x1, 0, MUL VL]               \n"
    "    ld1w {z1.s, z9.s}, pn8/z, [x1, 2, MUL VL]               \n"
    "    ld1w {z2.s, z10.s}, pn8/z, [x1, 4, MUL VL]              \n"
    "    ld1w {z3.s, z11.s}, pn8/z, [x1, 6, MUL VL]              \n"
    "                                                            \n"
    "    st1w {z0.s, z8.s}, pn8, [x2, 0, MUL VL]                 \n"
    "    st1w {z1.s, z9.s}, pn8, [x2, 2, MUL VL]                 \n"
    "    st1w {z2.s, z10.s}, pn8, [x2, 4, MUL VL]                \n"
    "    st1w {z3.s, z11.s}, pn8, [x2, 6, MUL VL]                \n"
    "                                                            \n"
    "    add x1, x1, #512                                        \n"
    "    add x2, x2, #512                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    ld1w {z0.s, z8.s}, pn8/z, [x1, 0, MUL VL]               \n"
    "    add x1, x1, #128                                        \n"
    "    st1w {z0.s, z8.s}, pn8, [x2, 0, MUL VL]                 \n"
    "    add x2, x2, #128                                        \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [dst] "r" (data->dst), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1", "x2"
  );

  //printf("done copy_reg_strided_x2_ilp4\n");

  // number of bytes transferred overall
  return 2.0*data->total_size;
}


static double copy_reg_strided_x2_ilp5(const void* args) {
  // LD1W/ST1W (two register, strided, predicated)
  //
  // Bytes per instruction: 128, bytes per loop iteration: 640 (ILP=5)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 640);

  //printf("starting copy_reg_strided_x2_ilp5\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue pn8.s                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  mov x2, %[dst]                                            \n"
    "  2:                                                        \n"
    "    ld1w {z0.s, z8.s}, pn8/z, [x1, 0, MUL VL]               \n"
    "    ld1w {z1.s, z9.s}, pn8/z, [x1, 2, MUL VL]               \n"
    "    ld1w {z2.s, z10.s}, pn8/z, [x1, 4, MUL VL]              \n"
    "    ld1w {z3.s, z11.s}, pn8/z, [x1, 6, MUL VL]              \n"
    "    ld1w {z4.s, z12.s}, pn8/z, [x1, 8, MUL VL]              \n"
    "                                                            \n"
    "    st1w {z0.s, z8.s}, pn8, [x2, 0, MUL VL]                 \n"
    "    st1w {z1.s, z9.s}, pn8, [x2, 2, MUL VL]                 \n"
    "    st1w {z2.s, z10.s}, pn8, [x2, 4, MUL VL]                \n"
    "    st1w {z3.s, z11.s}, pn8, [x2, 6, MUL VL]                \n"
    "    st1w {z4.s, z12.s}, pn8, [x2, 8, MUL VL]                \n"
    "                                                            \n"
    "    add x1, x1, #640                                        \n"
    "    add x2, x2, #640                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    ld1w {z0.s, z8.s}, pn8/z, [x1, 0, MUL VL]               \n"
    "    add x1, x1, #128                                        \n"
    "    st1w {z0.s, z8.s}, pn8, [x2, 0, MUL VL]                 \n"
    "    add x2, x2, #128                                        \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [dst] "r" (data->dst), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1", "x2"
  );

  //printf("done copy_reg_strided_x2_ilp5\n");

  // number of bytes transferred overall
  return 2.0*data->total_size;
}


static double copy_reg_strided_x2_ilp6(const void* args) {
  // LD1W/ST1W (two register, strided, predicated)
  //
  // Bytes per instruction: 128, bytes per loop iteration: 768 (ILP=6)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 768);

  //printf("starting copy_reg_strided_x2_ilp6\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue pn8.s                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  mov x2, %[dst]                                            \n"
    "  2:                                                        \n"
    "    ld1w {z0.s, z8.s}, pn8/z, [x1, 0, MUL VL]               \n"
    "    ld1w {z1.s, z9.s}, pn8/z, [x1, 2, MUL VL]               \n"
    "    ld1w {z2.s, z10.s}, pn8/z, [x1, 4, MUL VL]              \n"
    "    ld1w {z3.s, z11.s}, pn8/z, [x1, 6, MUL VL]              \n"
    "    ld1w {z4.s, z12.s}, pn8/z, [x1, 8, MUL VL]              \n"
    "    ld1w {z5.s, z13.s}, pn8/z, [x1, 10, MUL VL]             \n"
    "                                                            \n"
    "    st1w {z0.s, z8.s}, pn8, [x2, 0, MUL VL]                 \n"
    "    st1w {z1.s, z9.s}, pn8, [x2, 2, MUL VL]                 \n"
    "    st1w {z2.s, z10.s}, pn8, [x2, 4, MUL VL]                \n"
    "    st1w {z3.s, z11.s}, pn8, [x2, 6, MUL VL]                \n"
    "    st1w {z4.s, z12.s}, pn8, [x2, 8, MUL VL]                \n"
    "    st1w {z5.s, z13.s}, pn8, [x2, 10, MUL VL]               \n"
    "                                                            \n"
    "    add x1, x1, #768                                        \n"
    "    add x2, x2, #768                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    ld1w {z0.s, z8.s}, pn8/z, [x1, 0, MUL VL]               \n"
    "    add x1, x1, #128                                        \n"
    "    st1w {z0.s, z8.s}, pn8, [x2, 0, MUL VL]                 \n"
    "    add x2, x2, #128                                        \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [dst] "r" (data->dst), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1", "x2"
  );

  //printf("done copy_reg_strided_x2_ilp6\n");

  // number of bytes transferred overall
  return 2.0*data->total_size;
}


static double copy_reg_strided_x2_ilp7(const void* args) {
  // LD1W/ST1W (two register, strided, predicated)
  //
  // Bytes per instruction: 128, bytes per loop iteration: 896 (ILP=7)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 896);

  //printf("starting copy_reg_strided_x2_ilp7\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue pn8.s                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  mov x2, %[dst]                                            \n"
    "  2:                                                        \n"
    "    ld1w {z0.s, z8.s}, pn8/z, [x1, 0, MUL VL]               \n"
    "    ld1w {z1.s, z9.s}, pn8/z, [x1, 2, MUL VL]               \n"
    "    ld1w {z2.s, z10.s}, pn8/z, [x1, 4, MUL VL]              \n"
    "    ld1w {z3.s, z11.s}, pn8/z, [x1, 6, MUL VL]              \n"
    "    ld1w {z4.s, z12.s}, pn8/z, [x1, 8, MUL VL]              \n"
    "    ld1w {z5.s, z13.s}, pn8/z, [x1, 10, MUL VL]             \n"
    "    ld1w {z6.s, z14.s}, pn8/z, [x1, 12, MUL VL]             \n"
    "                                                            \n"
    "    st1w {z0.s, z8.s}, pn8, [x2, 0, MUL VL]                 \n"
    "    st1w {z1.s, z9.s}, pn8, [x2, 2, MUL VL]                 \n"
    "    st1w {z2.s, z10.s}, pn8, [x2, 4, MUL VL]                \n"
    "    st1w {z3.s, z11.s}, pn8, [x2, 6, MUL VL]                \n"
    "    st1w {z4.s, z12.s}, pn8, [x2, 8, MUL VL]                \n"
    "    st1w {z5.s, z13.s}, pn8, [x2, 10, MUL VL]               \n"
    "    st1w {z6.s, z14.s}, pn8, [x2, 12, MUL VL]               \n"
    "                                                            \n"
    "    add x1, x1, #896                                        \n"
    "    add x2, x2, #896                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    ld1w {z0.s, z8.s}, pn8/z, [x1, 0, MUL VL]               \n"
    "    add x1, x1, #128                                        \n"
    "    st1w {z0.s, z8.s}, pn8, [x2, 0, MUL VL]                 \n"
    "    add x2, x2, #128                                        \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [dst] "r" (data->dst), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1", "x2"
  );

  //printf("done copy_reg_strided_x2_ilp7\n");

  // number of bytes transferred overall
  return 2.0*data->total_size;
}


static double copy_reg_strided_x2_ilp8(const void* args) {
  // LD1W/ST1W (two register, strided, predicated)
  //
  // Bytes per instruction: 128, bytes per loop iteration: 1024 (ILP=8)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 1024);

  //printf("starting copy_reg_strided_x2_ilp8\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue pn8.s                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  mov x2, %[dst]                                            \n"
    "  2:                                                        \n"
    "    ld1w {z0.s, z8.s}, pn8/z, [x1, 0, MUL VL]               \n"
    "    ld1w {z1.s, z9.s}, pn8/z, [x1, 2, MUL VL]               \n"
    "    ld1w {z2.s, z10.s}, pn8/z, [x1, 4, MUL VL]              \n"
    "    ld1w {z3.s, z11.s}, pn8/z, [x1, 6, MUL VL]              \n"
    "    ld1w {z4.s, z12.s}, pn8/z, [x1, 8, MUL VL]              \n"
    "    ld1w {z5.s, z13.s}, pn8/z, [x1, 10, MUL VL]             \n"
    "    ld1w {z6.s, z14.s}, pn8/z, [x1, 12, MUL VL]             \n"
    "    ld1w {z7.s, z15.s}, pn8/z, [x1, 14, MUL VL]             \n"
    "                                                            \n"
    "    st1w {z0.s, z8.s}, pn8, [x2, 0, MUL VL]                 \n"
    "    st1w {z1.s, z9.s}, pn8, [x2, 2, MUL VL]                 \n"
    "    st1w {z2.s, z10.s}, pn8, [x2, 4, MUL VL]                \n"
    "    st1w {z3.s, z11.s}, pn8, [x2, 6, MUL VL]                \n"
    "    st1w {z4.s, z12.s}, pn8, [x2, 8, MUL VL]                \n"
    "    st1w {z5.s, z13.s}, pn8, [x2, 10, MUL VL]               \n"
    "    st1w {z6.s, z14.s}, pn8, [x2, 12, MUL VL]               \n"
    "    st1w {z7.s, z15.s}, pn8, [x2, 14, MUL VL]               \n"
    "                                                            \n"
    "    add x1, x1, #1024                                       \n"
    "    add x2, x2, #1024                                       \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    ld1w {z0.s, z8.s}, pn8/z, [x1, 0, MUL VL]               \n"
    "    add x1, x1, #128                                        \n"
    "    st1w {z0.s, z8.s}, pn8, [x2, 0, MUL VL]                 \n"
    "    add x2, x2, #128                                        \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [dst] "r" (data->dst), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1", "x2"
  );

  //printf("done copy_reg_strided_x2_ilp8\n");

  // number of bytes transferred overall
  return 2.0*data->total_size;
}


static double load_reg_strided_x4_ilp1(const void* args) {
  // LD1W (four register, strided, predicated)
  //
  // Bytes per instruction: 256, bytes per loop iteration: 256 (ILP=1)
  const benchmark_data_t* data = args;

  //printf("starting load_reg_strided_x4_ilp1\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue pn8.s                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  2:                                                        \n"
    "    ld1w {z0.s, z4.s, z8.s, z12.s}, pn8/z, [x1, 0, MUL VL]  \n"
    "                                                            \n"
    "    add x1, x1, #256                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 2b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [end] "r" (data->src + data->size)
    : "x0", "x1"
  );

  //printf("done load_reg_strided_x4_ilp1\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double load_reg_strided_x4_ilp2(const void* args) {
  // LD1W (four register, strided, predicated)
  //
  // Bytes per instruction: 256, bytes per loop iteration: 512 (ILP=2)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 512);

  //printf("starting load_reg_strided_x4_ilp2\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue pn8.s                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  2:                                                        \n"
    "    ld1w {z0.s, z4.s, z8.s, z12.s}, pn8/z, [x1, 0, MUL VL]  \n"
    "    ld1w {z1.s, z5.s, z9.s, z13.s}, pn8/z, [x1, 4, MUL VL]  \n"
    "                                                            \n"
    "    add x1, x1, #512                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    ld1w {z0.s, z4.s, z8.s, z12.s}, pn8/z, [x1, 0, MUL VL]  \n"
    "    add x1, x1, #256                                        \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1"
  );

  //printf("done load_reg_strided_x4_ilp2\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double load_reg_strided_x4_ilp3(const void* args) {
  // LD1W (four register, strided, predicated)
  //
  // Bytes per instruction: 256, bytes per loop iteration: 768 (ILP=3)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 768);

  //printf("starting load_reg_strided_x4_ilp3\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue pn8.s                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  2:                                                        \n"
    "    ld1w {z0.s, z4.s, z8.s, z12.s}, pn8/z, [x1, 0, MUL VL]  \n"
    "    ld1w {z1.s, z5.s, z9.s, z13.s}, pn8/z, [x1, 4, MUL VL]  \n"
    "    ld1w {z2.s, z6.s, z10.s, z14.s}, pn8/z, [x1, 8, MUL VL] \n"
    "                                                            \n"
    "    add x1, x1, #768                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    ld1w {z0.s, z4.s, z8.s, z12.s}, pn8/z, [x1, 0, MUL VL]  \n"
    "    add x1, x1, #256                                        \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1"
  );

  //printf("done load_reg_strided_x4_ilp3\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double load_reg_strided_x4_ilp4(const void* args) {
  // LD1W (four register, strided, predicated)
  //
  // Bytes per instruction: 256, bytes per loop iteration: 1024 (ILP=4)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 1024);

  //printf("starting load_reg_strided_x4_ilp4\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue pn8.s                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  2:                                                        \n"
    "    ld1w {z0.s, z4.s, z8.s, z12.s}, pn8/z, [x1, 0, MUL VL]  \n"
    "    ld1w {z1.s, z5.s, z9.s, z13.s}, pn8/z, [x1, 4, MUL VL]  \n"
    "    ld1w {z2.s, z6.s, z10.s, z14.s}, pn8/z, [x1, 8, MUL VL] \n"
    "    ld1w {z3.s, z7.s, z11.s, z15.s}, pn8/z, [x1, 12, MUL VL]\n"
    "                                                            \n"
    "    add x1, x1, #1024                                       \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    ld1w {z0.s, z4.s, z8.s, z12.s}, pn8/z, [x1, 0, MUL VL]  \n"
    "    add x1, x1, #256                                        \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1"
  );

  //printf("done load_reg_strided_x4_ilp4\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double load_reg_strided_x4_ilp5(const void* args) {
  // LD1W (four register, strided, predicated)
  //
  // Bytes per instruction: 256, bytes per loop iteration: 1280 (ILP=5)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 1280);

  //printf("starting load_reg_strided_x4_ilp5\n");

  __asm__ __volatile__ (
    "smstart                                                       \n"
    "mov x0, %[n]                                                  \n"
    "ptrue pn8.s                                                   \n"
    "1:                                                            \n"
    "  mov x1, %[src]                                              \n"
    "  2:                                                          \n"
    "    ld1w {z0.s, z4.s, z8.s, z12.s}, pn8/z, [x1, 0, MUL VL]    \n"
    "    ld1w {z1.s, z5.s, z9.s, z13.s}, pn8/z, [x1, 4, MUL VL]    \n"
    "    ld1w {z2.s, z6.s, z10.s, z14.s}, pn8/z, [x1, 8, MUL VL]   \n"
    "    ld1w {z3.s, z7.s, z11.s, z15.s}, pn8/z, [x1, 12, MUL VL]  \n"
    "    ld1w {z16.s, z20.s, z24.s, z28.s}, pn8/z, [x1, 16, MUL VL]\n"
    "                                                              \n"
    "    add x1, x1, #1280                                         \n"
    "    cmp x1, %[end_aligned]                                    \n"
    "    b.lo 2b                                                   \n"
    "    b 4f                                                      \n"
    "  3:                                                          \n"
    "    ld1w {z0.s, z4.s, z8.s, z12.s}, pn8/z, [x1, 0, MUL VL]    \n"
    "    add x1, x1, #256                                          \n"
    "  4:                                                          \n"
    "    cmp x1, %[end]                                            \n"
    "    b.lo 3b                                                   \n"
    "                                                              \n"
    "  subs x0, x0, #1                                             \n"
    "  b.ne 1b                                                     \n"
    "  smstop                                                      \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1"
  );

  //printf("done load_reg_strided_x4_ilp5\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double load_reg_strided_x4_ilp6(const void* args) {
  // LD1W (four register, strided, predicated)
  //
  // Bytes per instruction: 256, bytes per loop iteration: 1536 (ILP=6)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 1536);

  //printf("starting load_reg_strided_x4_ilp6\n");

  __asm__ __volatile__ (
    "smstart                                                       \n"
    "mov x0, %[n]                                                  \n"
    "ptrue pn8.s                                                   \n"
    "1:                                                            \n"
    "  mov x1, %[src]                                              \n"
    "  2:                                                          \n"
    "    ld1w {z0.s, z4.s, z8.s, z12.s}, pn8/z, [x1, 0, MUL VL]    \n"
    "    ld1w {z1.s, z5.s, z9.s, z13.s}, pn8/z, [x1, 4, MUL VL]    \n"
    "    ld1w {z2.s, z6.s, z10.s, z14.s}, pn8/z, [x1, 8, MUL VL]   \n"
    "    ld1w {z3.s, z7.s, z11.s, z15.s}, pn8/z, [x1, 12, MUL VL]  \n"
    "    ld1w {z16.s, z20.s, z24.s, z28.s}, pn8/z, [x1, 16, MUL VL]\n"
    "    ld1w {z17.s, z21.s, z25.s, z29.s}, pn8/z, [x1, 20, MUL VL]\n"
    "                                                              \n"
    "    add x1, x1, #1536                                         \n"
    "    cmp x1, %[end_aligned]                                    \n"
    "    b.lo 2b                                                   \n"
    "    b 4f                                                      \n"
    "  3:                                                          \n"
    "    ld1w {z0.s, z4.s, z8.s, z12.s}, pn8/z, [x1, 0, MUL VL]    \n"
    "    add x1, x1, #256                                          \n"
    "  4:                                                          \n"
    "    cmp x1, %[end]                                            \n"
    "    b.lo 3b                                                   \n"
    "                                                              \n"
    "  subs x0, x0, #1                                             \n"
    "  b.ne 1b                                                     \n"
    "  smstop                                                      \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1"
  );

  //printf("done load_reg_strided_x4_ilp6\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double load_reg_strided_x4_ilp7(const void* args) {
  // LD1W (four register, strided, predicated)
  //
  // Bytes per instruction: 256, bytes per loop iteration: 1792 (ILP=7)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 1792);

  //printf("starting load_reg_strided_x4_ilp7\n");

  __asm__ __volatile__ (
    "smstart                                                       \n"
    "mov x0, %[n]                                                  \n"
    "ptrue pn8.s                                                   \n"
    "1:                                                            \n"
    "  mov x1, %[src]                                              \n"
    "  2:                                                          \n"
    "    ld1w {z0.s, z4.s, z8.s, z12.s}, pn8/z, [x1, 0, MUL VL]    \n"
    "    ld1w {z1.s, z5.s, z9.s, z13.s}, pn8/z, [x1, 4, MUL VL]    \n"
    "    ld1w {z2.s, z6.s, z10.s, z14.s}, pn8/z, [x1, 8, MUL VL]   \n"
    "    ld1w {z3.s, z7.s, z11.s, z15.s}, pn8/z, [x1, 12, MUL VL]  \n"
    "    ld1w {z16.s, z20.s, z24.s, z28.s}, pn8/z, [x1, 16, MUL VL]\n"
    "    ld1w {z17.s, z21.s, z25.s, z29.s}, pn8/z, [x1, 20, MUL VL]\n"
    "    ld1w {z18.s, z22.s, z26.s, z30.s}, pn8/z, [x1, 24, MUL VL]\n"
    "                                                              \n"
    "    add x1, x1, #1792                                         \n"
    "    cmp x1, %[end_aligned]                                    \n"
    "    b.lo 2b                                                   \n"
    "    b 4f                                                      \n"
    "  3:                                                          \n"
    "    ld1w {z0.s, z4.s, z8.s, z12.s}, pn8/z, [x1, 0, MUL VL]    \n"
    "    add x1, x1, #256                                          \n"
    "  4:                                                          \n"
    "    cmp x1, %[end]                                            \n"
    "    b.lo 3b                                                   \n"
    "                                                              \n"
    "  subs x0, x0, #1                                             \n"
    "  b.ne 1b                                                     \n"
    "  smstop                                                      \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1"
  );

  //printf("done load_reg_strided_x4_ilp7\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double load_reg_strided_x4_ilp8(const void* args) {
  // LD1W (four register, strided, predicated)
  //
  // Bytes per instruction: 256, bytes per loop iteration: 2048 (ILP=8)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 2048);

  //printf("starting load_reg_strided_x4_ilp8\n");

  __asm__ __volatile__ (
    "smstart                                                       \n"
    "mov x0, %[n]                                                  \n"
    "ptrue pn8.s                                                   \n"
    "1:                                                            \n"
    "  mov x1, %[src]                                              \n"
    "  2:                                                          \n"
    "    ld1w {z0.s, z4.s, z8.s, z12.s}, pn8/z, [x1, 0, MUL VL]    \n"
    "    ld1w {z1.s, z5.s, z9.s, z13.s}, pn8/z, [x1, 4, MUL VL]    \n"
    "    ld1w {z2.s, z6.s, z10.s, z14.s}, pn8/z, [x1, 8, MUL VL]   \n"
    "    ld1w {z3.s, z7.s, z11.s, z15.s}, pn8/z, [x1, 12, MUL VL]  \n"
    "    ld1w {z16.s, z20.s, z24.s, z28.s}, pn8/z, [x1, 16, MUL VL]\n"
    "    ld1w {z17.s, z21.s, z25.s, z29.s}, pn8/z, [x1, 20, MUL VL]\n"
    "    ld1w {z18.s, z22.s, z26.s, z30.s}, pn8/z, [x1, 24, MUL VL]\n"
    "    ld1w {z19.s, z23.s, z27.s, z31.s}, pn8/z, [x1, 28, MUL VL]\n"
    "                                                              \n"
    "    add x1, x1, #2048                                         \n"
    "    cmp x1, %[end_aligned]                                    \n"
    "    b.lo 2b                                                   \n"
    "    b 4f                                                      \n"
    "  3:                                                          \n"
    "    ld1w {z0.s, z4.s, z8.s, z12.s}, pn8/z, [x1, 0, MUL VL]    \n"
    "    add x1, x1, #256                                          \n"
    "  4:                                                          \n"
    "    cmp x1, %[end]                                            \n"
    "    b.lo 3b                                                   \n"
    "                                                              \n"
    "  subs x0, x0, #1                                             \n"
    "  b.ne 1b                                                     \n"
    "  smstop                                                      \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1"
  );

  //printf("done load_reg_strided_x4_ilp8\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double store_reg_strided_x4_ilp1(const void* args) {
  // ST1W (four register, strided, predicated)
  //
  // Bytes per instruction: 256, bytes per loop iteration: 256 (ILP=1)
  const benchmark_data_t* data = args;

  //printf("starting store_reg_strided_x4_ilp1\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue pn8.s                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[dst]                                            \n"
    "  2:                                                        \n"
    "    st1w {z0.s, z4.s, z8.s, z12.s}, pn8, [x1, 0, MUL VL]    \n"
    "                                                            \n"
    "    add x1, x1, #256                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 2b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [dst] "r" (data->dst), [end] "r" (data->dst + data->size)
    : "x0", "x1"
  );

  //printf("done store_reg_strided_x4_ilp1\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double store_reg_strided_x4_ilp2(const void* args) {
  // ST1W (four register, strided, predicated)
  //
  // Bytes per instruction: 256, bytes per loop iteration: 512 (ILP=2)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 512);

  //printf("starting store_reg_strided_x4_ilp2\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue pn8.s                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[dst]                                            \n"
    "  2:                                                        \n"
    "    st1w {z0.s, z4.s, z8.s, z12.s}, pn8, [x1, 0, MUL VL]    \n"
    "    st1w {z1.s, z5.s, z9.s, z13.s}, pn8, [x1, 4, MUL VL]    \n"
    "                                                            \n"
    "    add x1, x1, #512                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    st1w {z0.s, z4.s, z8.s, z12.s}, pn8, [x1, 0, MUL VL]    \n"
    "    add x1, x1, #256                                        \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [dst] "r" (data->dst), [end] "r" (data->dst + data->size), [end_aligned] "r" (data->dst + size_aligned)
    : "x0", "x1"
  );

  //printf("done store_reg_strided_x4_ilp2\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double store_reg_strided_x4_ilp3(const void* args) {
  // ST1W (four register, strided, predicated)
  //
  // Bytes per instruction: 256, bytes per loop iteration: 768 (ILP=3)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 768);

  //printf("starting store_reg_strided_x4_ilp3\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue pn8.s                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[dst]                                            \n"
    "  2:                                                        \n"
    "    st1w {z0.s, z4.s, z8.s, z12.s}, pn8, [x1, 0, MUL VL]    \n"
    "    st1w {z1.s, z5.s, z9.s, z13.s}, pn8, [x1, 4, MUL VL]    \n"
    "    st1w {z2.s, z6.s, z10.s, z14.s}, pn8, [x1, 8, MUL VL]   \n"
    "                                                            \n"
    "    add x1, x1, #768                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    st1w {z0.s, z4.s, z8.s, z12.s}, pn8, [x1, 0, MUL VL]    \n"
    "    add x1, x1, #256                                        \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [dst] "r" (data->dst), [end] "r" (data->dst + data->size), [end_aligned] "r" (data->dst + size_aligned)
    : "x0", "x1"
  );

  //printf("done store_reg_strided_x4_ilp3\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double store_reg_strided_x4_ilp4(const void* args) {
  // ST1W (four register, strided, predicated)
  //
  // Bytes per instruction: 256, bytes per loop iteration: 1024 (ILP=4)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 1024);

  //printf("starting store_reg_strided_x4_ilp4\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue pn8.s                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[dst]                                            \n"
    "  2:                                                        \n"
    "    st1w {z0.s, z4.s, z8.s, z12.s}, pn8, [x1, 0, MUL VL]    \n"
    "    st1w {z1.s, z5.s, z9.s, z13.s}, pn8, [x1, 4, MUL VL]    \n"
    "    st1w {z2.s, z6.s, z10.s, z14.s}, pn8, [x1, 8, MUL VL]   \n"
    "    st1w {z3.s, z7.s, z11.s, z15.s}, pn8, [x1, 12, MUL VL]  \n"
    "                                                            \n"
    "    add x1, x1, #1024                                       \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    st1w {z0.s, z4.s, z8.s, z12.s}, pn8, [x1, 0, MUL VL]    \n"
    "    add x1, x1, #256                                        \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [dst] "r" (data->dst), [end] "r" (data->dst + data->size), [end_aligned] "r" (data->dst + size_aligned)
    : "x0", "x1"
  );

  //printf("done store_reg_strided_x4_ilp4\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double store_reg_strided_x4_ilp5(const void* args) {
  // ST1W (four register, strided, predicated)
  //
  // Bytes per instruction: 256, bytes per loop iteration: 1280 (ILP=5)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 1280);

  //printf("starting store_reg_strided_x4_ilp5\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue pn8.s                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[dst]                                            \n"
    "  2:                                                        \n"
    "    st1w {z0.s, z4.s, z8.s, z12.s}, pn8, [x1, 0, MUL VL]    \n"
    "    st1w {z1.s, z5.s, z9.s, z13.s}, pn8, [x1, 4, MUL VL]    \n"
    "    st1w {z2.s, z6.s, z10.s, z14.s}, pn8, [x1, 8, MUL VL]   \n"
    "    st1w {z3.s, z7.s, z11.s, z15.s}, pn8, [x1, 12, MUL VL]  \n"
    "    st1w {z16.s, z20.s, z24.s, z28.s}, pn8, [x1, 16, MUL VL]\n"
    "                                                            \n"
    "    add x1, x1, #1280                                       \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    st1w {z0.s, z4.s, z8.s, z12.s}, pn8, [x1, 0, MUL VL]    \n"
    "    add x1, x1, #256                                        \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [dst] "r" (data->dst), [end] "r" (data->dst + data->size), [end_aligned] "r" (data->dst + size_aligned)
    : "x0", "x1"
  );

  //printf("done store_reg_strided_x4_ilp5\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double store_reg_strided_x4_ilp6(const void* args) {
  // ST1W (four register, strided, predicated)
  //
  // Bytes per instruction: 256, bytes per loop iteration: 1536 (ILP=6)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 1536);

  //printf("starting store_reg_strided_x4_ilp6\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue pn8.s                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[dst]                                            \n"
    "  2:                                                        \n"
    "    st1w {z0.s, z4.s, z8.s, z12.s}, pn8, [x1, 0, MUL VL]    \n"
    "    st1w {z1.s, z5.s, z9.s, z13.s}, pn8, [x1, 4, MUL VL]    \n"
    "    st1w {z2.s, z6.s, z10.s, z14.s}, pn8, [x1, 8, MUL VL]   \n"
    "    st1w {z3.s, z7.s, z11.s, z15.s}, pn8, [x1, 12, MUL VL]  \n"
    "    st1w {z16.s, z20.s, z24.s, z28.s}, pn8, [x1, 16, MUL VL]\n"
    "    st1w {z17.s, z21.s, z25.s, z29.s}, pn8, [x1, 20, MUL VL]\n"
    "                                                            \n"
    "    add x1, x1, #1536                                       \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    st1w {z0.s, z4.s, z8.s, z12.s}, pn8, [x1, 0, MUL VL]    \n"
    "    add x1, x1, #256                                        \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [dst] "r" (data->dst), [end] "r" (data->dst + data->size), [end_aligned] "r" (data->dst + size_aligned)
    : "x0", "x1"
  );

  //printf("done store_reg_strided_x4_ilp6\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double store_reg_strided_x4_ilp7(const void* args) {
  // ST1W (four register, strided, predicated)
  //
  // Bytes per instruction: 256, bytes per loop iteration: 1792 (ILP=7)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 1792);

  //printf("starting store_reg_strided_x4_ilp7\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue pn8.s                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[dst]                                            \n"
    "  2:                                                        \n"
    "    st1w {z0.s, z4.s, z8.s, z12.s}, pn8, [x1, 0, MUL VL]    \n"
    "    st1w {z1.s, z5.s, z9.s, z13.s}, pn8, [x1, 4, MUL VL]    \n"
    "    st1w {z2.s, z6.s, z10.s, z14.s}, pn8, [x1, 8, MUL VL]   \n"
    "    st1w {z3.s, z7.s, z11.s, z15.s}, pn8, [x1, 12, MUL VL]  \n"
    "    st1w {z16.s, z20.s, z24.s, z28.s}, pn8, [x1, 16, MUL VL]\n"
    "    st1w {z17.s, z21.s, z25.s, z29.s}, pn8, [x1, 20, MUL VL]\n"
    "    st1w {z18.s, z22.s, z26.s, z30.s}, pn8, [x1, 24, MUL VL]\n"
    "                                                            \n"
    "    add x1, x1, #1792                                       \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    st1w {z0.s, z4.s, z8.s, z12.s}, pn8, [x1, 0, MUL VL]    \n"
    "    add x1, x1, #256                                        \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [dst] "r" (data->dst), [end] "r" (data->dst + data->size), [end_aligned] "r" (data->dst + size_aligned)
    : "x0", "x1"
  );

  //printf("done store_reg_strided_x4_ilp7\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double store_reg_strided_x4_ilp8(const void* args) {
  // ST1W (four register, strided, predicated)
  //
  // Bytes per instruction: 256, bytes per loop iteration: 2048 (ILP=8)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 2048);

  //printf("starting store_reg_strided_x4_ilp8\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue pn8.s                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[dst]                                            \n"
    "  2:                                                        \n"
    "    st1w {z0.s, z4.s, z8.s, z12.s}, pn8, [x1, 0, MUL VL]    \n"
    "    st1w {z1.s, z5.s, z9.s, z13.s}, pn8, [x1, 4, MUL VL]    \n"
    "    st1w {z2.s, z6.s, z10.s, z14.s}, pn8, [x1, 8, MUL VL]   \n"
    "    st1w {z3.s, z7.s, z11.s, z15.s}, pn8, [x1, 12, MUL VL]  \n"
    "    st1w {z16.s, z20.s, z24.s, z28.s}, pn8, [x1, 16, MUL VL]\n"
    "    st1w {z17.s, z21.s, z25.s, z29.s}, pn8, [x1, 20, MUL VL]\n"
    "    st1w {z18.s, z22.s, z26.s, z30.s}, pn8, [x1, 24, MUL VL]\n"
    "    st1w {z19.s, z23.s, z27.s, z31.s}, pn8, [x1, 28, MUL VL]\n"
    "                                                            \n"
    "    add x1, x1, #2048                                       \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    st1w {z0.s, z4.s, z8.s, z12.s}, pn8, [x1, 0, MUL VL]    \n"
    "    add x1, x1, #256                                        \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [dst] "r" (data->dst), [end] "r" (data->dst + data->size), [end_aligned] "r" (data->dst + size_aligned)
    : "x0", "x1"
  );

  //printf("done store_reg_strided_x4_ilp8\n");

  // number of bytes transferred overall
  return data->total_size;
}


static double copy_reg_strided_x4_ilp1(const void* args) {
  // LD1W/ST1W (four register, strided, predicated)
  //
  // Bytes per instruction: 256, bytes per loop iteration: 256 (ILP=1)
  const benchmark_data_t* data = args;

  //printf("starting copy_reg_strided_x4_ilp1\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue pn8.s                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  mov x2, %[dst]                                            \n"
    "  2:                                                        \n"
    "    ld1w {z0.s, z4.s, z8.s, z12.s}, pn8/z, [x1, 0, MUL VL]  \n"
    "                                                            \n"
    "    st1w {z0.s, z4.s, z8.s, z12.s}, pn8, [x2, 0, MUL VL]    \n"
    "                                                            \n"
    "    add x1, x1, #256                                        \n"
    "    add x2, x2, #256                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 2b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [dst] "r" (data->dst), [end] "r" (data->src + data->size)
    : "x0", "x1", "x2"
  );

  //printf("done copy_reg_strided_x4_ilp1\n");

  // number of bytes transferred overall
  return 2.0*data->total_size;
}


static double copy_reg_strided_x4_ilp2(const void* args) {
  // LD1W/ST1W (four register, strided, predicated)
  //
  // Bytes per instruction: 256, bytes per loop iteration: 512 (ILP=2)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 512);

  //printf("starting copy_reg_strided_x4_ilp2\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue pn8.s                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  mov x2, %[dst]                                            \n"
    "  2:                                                        \n"
    "    ld1w {z0.s, z4.s, z8.s, z12.s}, pn8/z, [x1, 0, MUL VL]  \n"
    "    ld1w {z1.s, z5.s, z9.s, z13.s}, pn8/z, [x1, 4, MUL VL]  \n"
    "                                                            \n"
    "    st1w {z0.s, z4.s, z8.s, z12.s}, pn8, [x2, 0, MUL VL]    \n"
    "    st1w {z1.s, z5.s, z9.s, z13.s}, pn8, [x2, 4, MUL VL]    \n"
    "                                                            \n"
    "    add x1, x1, #512                                        \n"
    "    add x2, x2, #512                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    ld1w {z0.s, z4.s, z8.s, z12.s}, pn8/z, [x1, 0, MUL VL]  \n"
    "    add x1, x1, #256                                        \n"
    "    st1w {z0.s, z4.s, z8.s, z12.s}, pn8, [x2, 0, MUL VL]    \n"
    "    add x2, x2, #256                                        \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [dst] "r" (data->dst), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1", "x2"
  );

  //printf("done copy_reg_strided_x4_ilp2\n");

  // number of bytes transferred overall
  return 2.0*data->total_size;
}


static double copy_reg_strided_x4_ilp3(const void* args) {
  // LD1W/ST1W (four register, strided, predicated)
  //
  // Bytes per instruction: 256, bytes per loop iteration: 768 (ILP=3)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 768);

  //printf("starting copy_reg_strided_x4_ilp3\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue pn8.s                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  mov x2, %[dst]                                            \n"
    "  2:                                                        \n"
    "    ld1w {z0.s, z4.s, z8.s, z12.s}, pn8/z, [x1, 0, MUL VL]  \n"
    "    ld1w {z1.s, z5.s, z9.s, z13.s}, pn8/z, [x1, 4, MUL VL]  \n"
    "    ld1w {z2.s, z6.s, z10.s, z14.s}, pn8/z, [x1, 8, MUL VL] \n"
    "                                                            \n"
    "    st1w {z0.s, z4.s, z8.s, z12.s}, pn8, [x2, 0, MUL VL]    \n"
    "    st1w {z1.s, z5.s, z9.s, z13.s}, pn8, [x2, 4, MUL VL]    \n"
    "    st1w {z2.s, z6.s, z10.s, z14.s}, pn8, [x2, 8, MUL VL]   \n"
    "                                                            \n"
    "    add x1, x1, #768                                        \n"
    "    add x2, x2, #768                                        \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    ld1w {z0.s, z4.s, z8.s, z12.s}, pn8/z, [x1, 0, MUL VL]  \n"
    "    add x1, x1, #256                                        \n"
    "    st1w {z0.s, z4.s, z8.s, z12.s}, pn8, [x2, 0, MUL VL]    \n"
    "    add x2, x2, #256                                        \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [dst] "r" (data->dst), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1", "x2"
  );

  //printf("done copy_reg_strided_x4_ilp3\n");

  // number of bytes transferred overall
  return 2.0*data->total_size;
}


static double copy_reg_strided_x4_ilp4(const void* args) {
  // LD1W/ST1W (four register, strided, predicated)
  //
  // Bytes per instruction: 256, bytes per loop iteration: 1024 (ILP=4)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 1024);

  //printf("starting copy_reg_strided_x4_ilp4\n");

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue pn8.s                                                 \n"
    "1:                                                          \n"
    "  mov x1, %[src]                                            \n"
    "  mov x2, %[dst]                                            \n"
    "  2:                                                        \n"
    "    ld1w {z0.s, z4.s, z8.s, z12.s}, pn8/z, [x1, 0, MUL VL]  \n"
    "    ld1w {z1.s, z5.s, z9.s, z13.s}, pn8/z, [x1, 4, MUL VL]  \n"
    "    ld1w {z2.s, z6.s, z10.s, z14.s}, pn8/z, [x1, 8, MUL VL] \n"
    "    ld1w {z3.s, z7.s, z11.s, z15.s}, pn8/z, [x1, 12, MUL VL]\n"
    "                                                            \n"
    "    st1w {z0.s, z4.s, z8.s, z12.s}, pn8, [x2, 0, MUL VL]    \n"
    "    st1w {z1.s, z5.s, z9.s, z13.s}, pn8, [x2, 4, MUL VL]    \n"
    "    st1w {z2.s, z6.s, z10.s, z14.s}, pn8, [x2, 8, MUL VL]   \n"
    "    st1w {z3.s, z7.s, z11.s, z15.s}, pn8, [x2, 12, MUL VL]  \n"
    "                                                            \n"
    "    add x1, x1, #1024                                       \n"
    "    add x2, x2, #1024                                       \n"
    "    cmp x1, %[end_aligned]                                  \n"
    "    b.lo 2b                                                 \n"
    "    b 4f                                                    \n"
    "  3:                                                        \n"
    "    ld1w {z0.s, z4.s, z8.s, z12.s}, pn8/z, [x1, 0, MUL VL]  \n"
    "    add x1, x1, #256                                        \n"
    "    st1w {z0.s, z4.s, z8.s, z12.s}, pn8, [x2, 0, MUL VL]    \n"
    "    add x2, x2, #256                                        \n"
    "  4:                                                        \n"
    "    cmp x1, %[end]                                          \n"
    "    b.lo 3b                                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "  smstop                                                    \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [dst] "r" (data->dst), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1", "x2"
  );

  //printf("done copy_reg_strided_x4_ilp4\n");

  // number of bytes transferred overall
  return 2.0*data->total_size;
}


static double copy_reg_strided_x4_ilp5(const void* args) {
  // LD1W/ST1W (four register, strided, predicated)
  //
  // Bytes per instruction: 256, bytes per loop iteration: 1280 (ILP=5)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 1280);

  //printf("starting copy_reg_strided_x4_ilp5\n");

  __asm__ __volatile__ (
    "smstart                                                       \n"
    "mov x0, %[n]                                                  \n"
    "ptrue pn8.s                                                   \n"
    "1:                                                            \n"
    "  mov x1, %[src]                                              \n"
    "  mov x2, %[dst]                                              \n"
    "  2:                                                          \n"
    "    ld1w {z0.s, z4.s, z8.s, z12.s}, pn8/z, [x1, 0, MUL VL]    \n"
    "    ld1w {z1.s, z5.s, z9.s, z13.s}, pn8/z, [x1, 4, MUL VL]    \n"
    "    ld1w {z2.s, z6.s, z10.s, z14.s}, pn8/z, [x1, 8, MUL VL]   \n"
    "    ld1w {z3.s, z7.s, z11.s, z15.s}, pn8/z, [x1, 12, MUL VL]  \n"
    "    ld1w {z16.s, z20.s, z24.s, z28.s}, pn8/z, [x1, 16, MUL VL]\n"
    "                                                              \n"
    "    st1w {z0.s, z4.s, z8.s, z12.s}, pn8, [x2, 0, MUL VL]      \n"
    "    st1w {z1.s, z5.s, z9.s, z13.s}, pn8, [x2, 4, MUL VL]      \n"
    "    st1w {z2.s, z6.s, z10.s, z14.s}, pn8, [x2, 8, MUL VL]     \n"
    "    st1w {z3.s, z7.s, z11.s, z15.s}, pn8, [x2, 12, MUL VL]    \n"
    "    st1w {z16.s, z20.s, z24.s, z28.s}, pn8, [x2, 16, MUL VL]  \n"
    "                                                              \n"
    "    add x1, x1, #1280                                         \n"
    "    add x2, x2, #1280                                         \n"
    "    cmp x1, %[end_aligned]                                    \n"
    "    b.lo 2b                                                   \n"
    "    b 4f                                                      \n"
    "  3:                                                          \n"
    "    ld1w {z0.s, z4.s, z8.s, z12.s}, pn8/z, [x1, 0, MUL VL]    \n"
    "    add x1, x1, #256                                          \n"
    "    st1w {z0.s, z4.s, z8.s, z12.s}, pn8, [x2, 0, MUL VL]      \n"
    "    add x2, x2, #256                                          \n"
    "  4:                                                          \n"
    "    cmp x1, %[end]                                            \n"
    "    b.lo 3b                                                   \n"
    "                                                              \n"
    "  subs x0, x0, #1                                             \n"
    "  b.ne 1b                                                     \n"
    "  smstop                                                      \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [dst] "r" (data->dst), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1", "x2"
  );

  //printf("done copy_reg_strided_x4_ilp5\n");

  // number of bytes transferred overall
  return 2.0*data->total_size;
}


static double copy_reg_strided_x4_ilp6(const void* args) {
  // LD1W/ST1W (four register, strided, predicated)
  //
  // Bytes per instruction: 256, bytes per loop iteration: 1536 (ILP=6)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 1536);

  //printf("starting copy_reg_strided_x4_ilp6\n");

  __asm__ __volatile__ (
    "smstart                                                       \n"
    "mov x0, %[n]                                                  \n"
    "ptrue pn8.s                                                   \n"
    "1:                                                            \n"
    "  mov x1, %[src]                                              \n"
    "  mov x2, %[dst]                                              \n"
    "  2:                                                          \n"
    "    ld1w {z0.s, z4.s, z8.s, z12.s}, pn8/z, [x1, 0, MUL VL]    \n"
    "    ld1w {z1.s, z5.s, z9.s, z13.s}, pn8/z, [x1, 4, MUL VL]    \n"
    "    ld1w {z2.s, z6.s, z10.s, z14.s}, pn8/z, [x1, 8, MUL VL]   \n"
    "    ld1w {z3.s, z7.s, z11.s, z15.s}, pn8/z, [x1, 12, MUL VL]  \n"
    "    ld1w {z16.s, z20.s, z24.s, z28.s}, pn8/z, [x1, 16, MUL VL]\n"
    "    ld1w {z17.s, z21.s, z25.s, z29.s}, pn8/z, [x1, 20, MUL VL]\n"
    "                                                              \n"
    "    st1w {z0.s, z4.s, z8.s, z12.s}, pn8, [x2, 0, MUL VL]      \n"
    "    st1w {z1.s, z5.s, z9.s, z13.s}, pn8, [x2, 4, MUL VL]      \n"
    "    st1w {z2.s, z6.s, z10.s, z14.s}, pn8, [x2, 8, MUL VL]     \n"
    "    st1w {z3.s, z7.s, z11.s, z15.s}, pn8, [x2, 12, MUL VL]    \n"
    "    st1w {z16.s, z20.s, z24.s, z28.s}, pn8, [x2, 16, MUL VL]  \n"
    "    st1w {z17.s, z21.s, z25.s, z29.s}, pn8, [x2, 20, MUL VL]  \n"
    "                                                              \n"
    "    add x1, x1, #1536                                         \n"
    "    add x2, x2, #1536                                         \n"
    "    cmp x1, %[end_aligned]                                    \n"
    "    b.lo 2b                                                   \n"
    "    b 4f                                                      \n"
    "  3:                                                          \n"
    "    ld1w {z0.s, z4.s, z8.s, z12.s}, pn8/z, [x1, 0, MUL VL]    \n"
    "    add x1, x1, #256                                          \n"
    "    st1w {z0.s, z4.s, z8.s, z12.s}, pn8, [x2, 0, MUL VL]      \n"
    "    add x2, x2, #256                                          \n"
    "  4:                                                          \n"
    "    cmp x1, %[end]                                            \n"
    "    b.lo 3b                                                   \n"
    "                                                              \n"
    "  subs x0, x0, #1                                             \n"
    "  b.ne 1b                                                     \n"
    "  smstop                                                      \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [dst] "r" (data->dst), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1", "x2"
  );

  //printf("done copy_reg_strided_x4_ilp6\n");

  // number of bytes transferred overall
  return 2.0*data->total_size;
}


static double copy_reg_strided_x4_ilp7(const void* args) {
  // LD1W/ST1W (four register, strided, predicated)
  //
  // Bytes per instruction: 256, bytes per loop iteration: 1792 (ILP=7)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 1792);

  //printf("starting copy_reg_strided_x4_ilp7\n");

  __asm__ __volatile__ (
    "smstart                                                       \n"
    "mov x0, %[n]                                                  \n"
    "ptrue pn8.s                                                   \n"
    "1:                                                            \n"
    "  mov x1, %[src]                                              \n"
    "  mov x2, %[dst]                                              \n"
    "  2:                                                          \n"
    "    ld1w {z0.s, z4.s, z8.s, z12.s}, pn8/z, [x1, 0, MUL VL]    \n"
    "    ld1w {z1.s, z5.s, z9.s, z13.s}, pn8/z, [x1, 4, MUL VL]    \n"
    "    ld1w {z2.s, z6.s, z10.s, z14.s}, pn8/z, [x1, 8, MUL VL]   \n"
    "    ld1w {z3.s, z7.s, z11.s, z15.s}, pn8/z, [x1, 12, MUL VL]  \n"
    "    ld1w {z16.s, z20.s, z24.s, z28.s}, pn8/z, [x1, 16, MUL VL]\n"
    "    ld1w {z17.s, z21.s, z25.s, z29.s}, pn8/z, [x1, 20, MUL VL]\n"
    "    ld1w {z18.s, z22.s, z26.s, z30.s}, pn8/z, [x1, 24, MUL VL]\n"
    "                                                              \n"
    "    st1w {z0.s, z4.s, z8.s, z12.s}, pn8, [x2, 0, MUL VL]      \n"
    "    st1w {z1.s, z5.s, z9.s, z13.s}, pn8, [x2, 4, MUL VL]      \n"
    "    st1w {z2.s, z6.s, z10.s, z14.s}, pn8, [x2, 8, MUL VL]     \n"
    "    st1w {z3.s, z7.s, z11.s, z15.s}, pn8, [x2, 12, MUL VL]    \n"
    "    st1w {z16.s, z20.s, z24.s, z28.s}, pn8, [x2, 16, MUL VL]  \n"
    "    st1w {z17.s, z21.s, z25.s, z29.s}, pn8, [x2, 20, MUL VL]  \n"
    "    st1w {z18.s, z22.s, z26.s, z30.s}, pn8, [x2, 24, MUL VL]  \n"
    "                                                              \n"
    "    add x1, x1, #1792                                         \n"
    "    add x2, x2, #1792                                         \n"
    "    cmp x1, %[end_aligned]                                    \n"
    "    b.lo 2b                                                   \n"
    "    b 4f                                                      \n"
    "  3:                                                          \n"
    "    ld1w {z0.s, z4.s, z8.s, z12.s}, pn8/z, [x1, 0, MUL VL]    \n"
    "    add x1, x1, #256                                          \n"
    "    st1w {z0.s, z4.s, z8.s, z12.s}, pn8, [x2, 0, MUL VL]      \n"
    "    add x2, x2, #256                                          \n"
    "  4:                                                          \n"
    "    cmp x1, %[end]                                            \n"
    "    b.lo 3b                                                   \n"
    "                                                              \n"
    "  subs x0, x0, #1                                             \n"
    "  b.ne 1b                                                     \n"
    "  smstop                                                      \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [dst] "r" (data->dst), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1", "x2"
  );

  //printf("done copy_reg_strided_x4_ilp7\n");

  // number of bytes transferred overall
  return 2.0*data->total_size;
}


static double copy_reg_strided_x4_ilp8(const void* args) {
  // LD1W/ST1W (four register, strided, predicated)
  //
  // Bytes per instruction: 256, bytes per loop iteration: 2048 (ILP=8)
  const benchmark_data_t* data = args;
  size_t size_aligned = data->size - (data->size % 2048);

  //printf("starting copy_reg_strided_x4_ilp8\n");

  __asm__ __volatile__ (
    "smstart                                                       \n"
    "mov x0, %[n]                                                  \n"
    "ptrue pn8.s                                                   \n"
    "1:                                                            \n"
    "  mov x1, %[src]                                              \n"
    "  mov x2, %[dst]                                              \n"
    "  2:                                                          \n"
    "    ld1w {z0.s, z4.s, z8.s, z12.s}, pn8/z, [x1, 0, MUL VL]    \n"
    "    ld1w {z1.s, z5.s, z9.s, z13.s}, pn8/z, [x1, 4, MUL VL]    \n"
    "    ld1w {z2.s, z6.s, z10.s, z14.s}, pn8/z, [x1, 8, MUL VL]   \n"
    "    ld1w {z3.s, z7.s, z11.s, z15.s}, pn8/z, [x1, 12, MUL VL]  \n"
    "    ld1w {z16.s, z20.s, z24.s, z28.s}, pn8/z, [x1, 16, MUL VL]\n"
    "    ld1w {z17.s, z21.s, z25.s, z29.s}, pn8/z, [x1, 20, MUL VL]\n"
    "    ld1w {z18.s, z22.s, z26.s, z30.s}, pn8/z, [x1, 24, MUL VL]\n"
    "    ld1w {z19.s, z23.s, z27.s, z31.s}, pn8/z, [x1, 28, MUL VL]\n"
    "                                                              \n"
    "    st1w {z0.s, z4.s, z8.s, z12.s}, pn8, [x2, 0, MUL VL]      \n"
    "    st1w {z1.s, z5.s, z9.s, z13.s}, pn8, [x2, 4, MUL VL]      \n"
    "    st1w {z2.s, z6.s, z10.s, z14.s}, pn8, [x2, 8, MUL VL]     \n"
    "    st1w {z3.s, z7.s, z11.s, z15.s}, pn8, [x2, 12, MUL VL]    \n"
    "    st1w {z16.s, z20.s, z24.s, z28.s}, pn8, [x2, 16, MUL VL]  \n"
    "    st1w {z17.s, z21.s, z25.s, z29.s}, pn8, [x2, 20, MUL VL]  \n"
    "    st1w {z18.s, z22.s, z26.s, z30.s}, pn8, [x2, 24, MUL VL]  \n"
    "    st1w {z19.s, z23.s, z27.s, z31.s}, pn8, [x2, 28, MUL VL]  \n"
    "                                                              \n"
    "    add x1, x1, #2048                                         \n"
    "    add x2, x2, #2048                                         \n"
    "    cmp x1, %[end_aligned]                                    \n"
    "    b.lo 2b                                                   \n"
    "    b 4f                                                      \n"
    "  3:                                                          \n"
    "    ld1w {z0.s, z4.s, z8.s, z12.s}, pn8/z, [x1, 0, MUL VL]    \n"
    "    add x1, x1, #256                                          \n"
    "    st1w {z0.s, z4.s, z8.s, z12.s}, pn8, [x2, 0, MUL VL]      \n"
    "    add x2, x2, #256                                          \n"
    "  4:                                                          \n"
    "    cmp x1, %[end]                                            \n"
    "    b.lo 3b                                                   \n"
    "                                                              \n"
    "  subs x0, x0, #1                                             \n"
    "  b.ne 1b                                                     \n"
    "  smstop                                                      \n"
    : // nothing
    : [n] "r" (data->n_iterations), [src] "r" (data->src), [dst] "r" (data->dst), [end] "r" (data->src + data->size), [end_aligned] "r" (data->src + size_aligned)
    : "x0", "x1", "x2"
  );

  //printf("done copy_reg_strided_x4_ilp8\n");

  // number of bytes transferred overall
  return 2.0*data->total_size;
}


// benchmark setup
#define MB(x) (size_t)x*1048576UL

static size_t find_n_iterations(size_t size) {
  // at least 512MB
  size_t n = MB(512)/size;
  n = n < 16 ? 16 : n;
  return n;
}

static void* setup(const void* args) {
  const mem_benchmark_params_t* params = args;

  // allocations must be done in steps of SIZE_ALIGNMENT
  assert(params->size % SIZE_ALIGNMENT == 0);

  // at least 16-byte alignment
  assert(params->alignment % 16UL == 0);

  // allocate buffer for the benchmark
  benchmark_data_t* data = malloc(sizeof(benchmark_data_t));
  data->size = params->size;
  data->src = aligned_alloc(params->alignment, params->size);
  data->dst = aligned_alloc(params->alignment, params->size);
  data->n_iterations = find_n_iterations(data->size);
  data->total_size = (double)data->size*(double)data->n_iterations;

  assert(data->src != nullptr);
  assert(data->dst != nullptr);

  return data;
}

static void teardown(void* args) {
  benchmark_data_t* data = args;

  free(data->src); data->src = nullptr;
  free(data->dst); data->src = nullptr;
  free(data);
}


// benchmark table
static const mem_benchmark_t benchmarks[] = {
  {{ &setup, &load_za_vector_x1_ilp1, &teardown }, "LDR (ZA vector)", "za-vector", "FEAT_SME2", "load", 1, -1, 1},
  {{ &setup, &load_za_vector_x1_ilp2, &teardown }, "LDR (ZA vector)", "za-vector", "FEAT_SME2", "load", 1, -1, 2},
  {{ &setup, &load_za_vector_x1_ilp3, &teardown }, "LDR (ZA vector)", "za-vector", "FEAT_SME2", "load", 1, -1, 3},
  {{ &setup, &load_za_vector_x1_ilp4, &teardown }, "LDR (ZA vector)", "za-vector", "FEAT_SME2", "load", 1, -1, 4},
  {{ &setup, &load_za_vector_x1_ilp5, &teardown }, "LDR (ZA vector)", "za-vector", "FEAT_SME2", "load", 1, -1, 5},
  {{ &setup, &load_za_vector_x1_ilp6, &teardown }, "LDR (ZA vector)", "za-vector", "FEAT_SME2", "load", 1, -1, 6},
  {{ &setup, &load_za_vector_x1_ilp7, &teardown }, "LDR (ZA vector)", "za-vector", "FEAT_SME2", "load", 1, -1, 7},
  {{ &setup, &load_za_vector_x1_ilp8, &teardown }, "LDR (ZA vector)", "za-vector", "FEAT_SME2", "load", 1, -1, 8},
  {{ &setup, &load_za_vector_x1_ilp9, &teardown }, "LDR (ZA vector)", "za-vector", "FEAT_SME2", "load", 1, -1, 9},
  {{ &setup, &load_za_vector_x1_ilp10, &teardown }, "LDR (ZA vector)", "za-vector", "FEAT_SME2", "load", 1, -1, 10},
  {{ &setup, &load_za_vector_x1_ilp11, &teardown }, "LDR (ZA vector)", "za-vector", "FEAT_SME2", "load", 1, -1, 11},
  {{ &setup, &load_za_vector_x1_ilp12, &teardown }, "LDR (ZA vector)", "za-vector", "FEAT_SME2", "load", 1, -1, 12},
  {{ &setup, &load_za_vector_x1_ilp13, &teardown }, "LDR (ZA vector)", "za-vector", "FEAT_SME2", "load", 1, -1, 13},
  {{ &setup, &load_za_vector_x1_ilp14, &teardown }, "LDR (ZA vector)", "za-vector", "FEAT_SME2", "load", 1, -1, 14},
  {{ &setup, &load_za_vector_x1_ilp15, &teardown }, "LDR (ZA vector)", "za-vector", "FEAT_SME2", "load", 1, -1, 15},
  {{ &setup, &load_za_vector_x1_ilp16, &teardown }, "LDR (ZA vector)", "za-vector", "FEAT_SME2", "load", 1, -1, 16},
  {{ &setup, &store_za_vector_x1_ilp1, &teardown }, "STR (ZA vector)", "za-vector", "FEAT_SME2", "store", 1, -1, 1},
  {{ &setup, &store_za_vector_x1_ilp2, &teardown }, "STR (ZA vector)", "za-vector", "FEAT_SME2", "store", 1, -1, 2},
  {{ &setup, &store_za_vector_x1_ilp3, &teardown }, "STR (ZA vector)", "za-vector", "FEAT_SME2", "store", 1, -1, 3},
  {{ &setup, &store_za_vector_x1_ilp4, &teardown }, "STR (ZA vector)", "za-vector", "FEAT_SME2", "store", 1, -1, 4},
  {{ &setup, &store_za_vector_x1_ilp5, &teardown }, "STR (ZA vector)", "za-vector", "FEAT_SME2", "store", 1, -1, 5},
  {{ &setup, &store_za_vector_x1_ilp6, &teardown }, "STR (ZA vector)", "za-vector", "FEAT_SME2", "store", 1, -1, 6},
  {{ &setup, &store_za_vector_x1_ilp7, &teardown }, "STR (ZA vector)", "za-vector", "FEAT_SME2", "store", 1, -1, 7},
  {{ &setup, &store_za_vector_x1_ilp8, &teardown }, "STR (ZA vector)", "za-vector", "FEAT_SME2", "store", 1, -1, 8},
  {{ &setup, &store_za_vector_x1_ilp9, &teardown }, "STR (ZA vector)", "za-vector", "FEAT_SME2", "store", 1, -1, 9},
  {{ &setup, &store_za_vector_x1_ilp10, &teardown }, "STR (ZA vector)", "za-vector", "FEAT_SME2", "store", 1, -1, 10},
  {{ &setup, &store_za_vector_x1_ilp11, &teardown }, "STR (ZA vector)", "za-vector", "FEAT_SME2", "store", 1, -1, 11},
  {{ &setup, &store_za_vector_x1_ilp12, &teardown }, "STR (ZA vector)", "za-vector", "FEAT_SME2", "store", 1, -1, 12},
  {{ &setup, &store_za_vector_x1_ilp13, &teardown }, "STR (ZA vector)", "za-vector", "FEAT_SME2", "store", 1, -1, 13},
  {{ &setup, &store_za_vector_x1_ilp14, &teardown }, "STR (ZA vector)", "za-vector", "FEAT_SME2", "store", 1, -1, 14},
  {{ &setup, &store_za_vector_x1_ilp15, &teardown }, "STR (ZA vector)", "za-vector", "FEAT_SME2", "store", 1, -1, 15},
  {{ &setup, &store_za_vector_x1_ilp16, &teardown }, "STR (ZA vector)", "za-vector", "FEAT_SME2", "store", 1, -1, 16},
  {{ &setup, &copy_za_vector_x1_ilp1, &teardown }, "LDR/STR (ZA vector)", "za-vector", "FEAT_SME2", "copy", 1, -1, 1},
  {{ &setup, &copy_za_vector_x1_ilp2, &teardown }, "LDR/STR (ZA vector)", "za-vector", "FEAT_SME2", "copy", 1, -1, 2},
  {{ &setup, &copy_za_vector_x1_ilp3, &teardown }, "LDR/STR (ZA vector)", "za-vector", "FEAT_SME2", "copy", 1, -1, 3},
  {{ &setup, &copy_za_vector_x1_ilp4, &teardown }, "LDR/STR (ZA vector)", "za-vector", "FEAT_SME2", "copy", 1, -1, 4},
  {{ &setup, &copy_za_vector_x1_ilp5, &teardown }, "LDR/STR (ZA vector)", "za-vector", "FEAT_SME2", "copy", 1, -1, 5},
  {{ &setup, &copy_za_vector_x1_ilp6, &teardown }, "LDR/STR (ZA vector)", "za-vector", "FEAT_SME2", "copy", 1, -1, 6},
  {{ &setup, &copy_za_vector_x1_ilp7, &teardown }, "LDR/STR (ZA vector)", "za-vector", "FEAT_SME2", "copy", 1, -1, 7},
  {{ &setup, &copy_za_vector_x1_ilp8, &teardown }, "LDR/STR (ZA vector)", "za-vector", "FEAT_SME2", "copy", 1, -1, 8},
  {{ &setup, &copy_za_vector_x1_ilp9, &teardown }, "LDR/STR (ZA vector)", "za-vector", "FEAT_SME2", "copy", 1, -1, 9},
  {{ &setup, &copy_za_vector_x1_ilp10, &teardown }, "LDR/STR (ZA vector)", "za-vector", "FEAT_SME2", "copy", 1, -1, 10},
  {{ &setup, &copy_za_vector_x1_ilp11, &teardown }, "LDR/STR (ZA vector)", "za-vector", "FEAT_SME2", "copy", 1, -1, 11},
  {{ &setup, &copy_za_vector_x1_ilp12, &teardown }, "LDR/STR (ZA vector)", "za-vector", "FEAT_SME2", "copy", 1, -1, 12},
  {{ &setup, &copy_za_vector_x1_ilp13, &teardown }, "LDR/STR (ZA vector)", "za-vector", "FEAT_SME2", "copy", 1, -1, 13},
  {{ &setup, &copy_za_vector_x1_ilp14, &teardown }, "LDR/STR (ZA vector)", "za-vector", "FEAT_SME2", "copy", 1, -1, 14},
  {{ &setup, &copy_za_vector_x1_ilp15, &teardown }, "LDR/STR (ZA vector)", "za-vector", "FEAT_SME2", "copy", 1, -1, 15},
  {{ &setup, &copy_za_vector_x1_ilp16, &teardown }, "LDR/STR (ZA vector)", "za-vector", "FEAT_SME2", "copy", 1, -1, 16},
  {{ &setup, &load_reg_adjacent_x1_ilp1, &teardown }, "LDR (one register, unpredicated)", "reg-adjacent", "FEAT_SME2", "load", 1, -1, 1},
  {{ &setup, &load_reg_adjacent_x1_ilp2, &teardown }, "LDR (one register, unpredicated)", "reg-adjacent", "FEAT_SME2", "load", 1, -1, 2},
  {{ &setup, &load_reg_adjacent_x1_ilp3, &teardown }, "LDR (one register, unpredicated)", "reg-adjacent", "FEAT_SME2", "load", 1, -1, 3},
  {{ &setup, &load_reg_adjacent_x1_ilp4, &teardown }, "LDR (one register, unpredicated)", "reg-adjacent", "FEAT_SME2", "load", 1, -1, 4},
  {{ &setup, &load_reg_adjacent_x1_ilp5, &teardown }, "LDR (one register, unpredicated)", "reg-adjacent", "FEAT_SME2", "load", 1, -1, 5},
  {{ &setup, &load_reg_adjacent_x1_ilp6, &teardown }, "LDR (one register, unpredicated)", "reg-adjacent", "FEAT_SME2", "load", 1, -1, 6},
  {{ &setup, &load_reg_adjacent_x1_ilp7, &teardown }, "LDR (one register, unpredicated)", "reg-adjacent", "FEAT_SME2", "load", 1, -1, 7},
  {{ &setup, &load_reg_adjacent_x1_ilp8, &teardown }, "LDR (one register, unpredicated)", "reg-adjacent", "FEAT_SME2", "load", 1, -1, 8},
  {{ &setup, &store_reg_adjacent_x1_ilp1, &teardown }, "STR (one register, unpredicated)", "reg-adjacent", "FEAT_SME2", "store", 1, -1, 1},
  {{ &setup, &store_reg_adjacent_x1_ilp2, &teardown }, "STR (one register, unpredicated)", "reg-adjacent", "FEAT_SME2", "store", 1, -1, 2},
  {{ &setup, &store_reg_adjacent_x1_ilp3, &teardown }, "STR (one register, unpredicated)", "reg-adjacent", "FEAT_SME2", "store", 1, -1, 3},
  {{ &setup, &store_reg_adjacent_x1_ilp4, &teardown }, "STR (one register, unpredicated)", "reg-adjacent", "FEAT_SME2", "store", 1, -1, 4},
  {{ &setup, &store_reg_adjacent_x1_ilp5, &teardown }, "STR (one register, unpredicated)", "reg-adjacent", "FEAT_SME2", "store", 1, -1, 5},
  {{ &setup, &store_reg_adjacent_x1_ilp6, &teardown }, "STR (one register, unpredicated)", "reg-adjacent", "FEAT_SME2", "store", 1, -1, 6},
  {{ &setup, &store_reg_adjacent_x1_ilp7, &teardown }, "STR (one register, unpredicated)", "reg-adjacent", "FEAT_SME2", "store", 1, -1, 7},
  {{ &setup, &store_reg_adjacent_x1_ilp8, &teardown }, "STR (one register, unpredicated)", "reg-adjacent", "FEAT_SME2", "store", 1, -1, 8},
  {{ &setup, &copy_reg_adjacent_x1_ilp1, &teardown }, "LDR/STR (one register, unpredicated)", "reg-adjacent", "FEAT_SME2", "copy", 1, -1, 1},
  {{ &setup, &copy_reg_adjacent_x1_ilp2, &teardown }, "LDR/STR (one register, unpredicated)", "reg-adjacent", "FEAT_SME2", "copy", 1, -1, 2},
  {{ &setup, &copy_reg_adjacent_x1_ilp3, &teardown }, "LDR/STR (one register, unpredicated)", "reg-adjacent", "FEAT_SME2", "copy", 1, -1, 3},
  {{ &setup, &copy_reg_adjacent_x1_ilp4, &teardown }, "LDR/STR (one register, unpredicated)", "reg-adjacent", "FEAT_SME2", "copy", 1, -1, 4},
  {{ &setup, &copy_reg_adjacent_x1_ilp5, &teardown }, "LDR/STR (one register, unpredicated)", "reg-adjacent", "FEAT_SME2", "copy", 1, -1, 5},
  {{ &setup, &copy_reg_adjacent_x1_ilp6, &teardown }, "LDR/STR (one register, unpredicated)", "reg-adjacent", "FEAT_SME2", "copy", 1, -1, 6},
  {{ &setup, &copy_reg_adjacent_x1_ilp7, &teardown }, "LDR/STR (one register, unpredicated)", "reg-adjacent", "FEAT_SME2", "copy", 1, -1, 7},
  {{ &setup, &copy_reg_adjacent_x1_ilp8, &teardown }, "LDR/STR (one register, unpredicated)", "reg-adjacent", "FEAT_SME2", "copy", 1, -1, 8},
  {{ &setup, &load_reg_adjacent_x2_ilp1, &teardown }, "LD1W (two register, adjacent, predicated)", "reg-adjacent", "FEAT_SME2", "load", 2, 32, 1},
  {{ &setup, &load_reg_adjacent_x2_ilp2, &teardown }, "LD1W (two register, adjacent, predicated)", "reg-adjacent", "FEAT_SME2", "load", 2, 32, 2},
  {{ &setup, &load_reg_adjacent_x2_ilp3, &teardown }, "LD1W (two register, adjacent, predicated)", "reg-adjacent", "FEAT_SME2", "load", 2, 32, 3},
  {{ &setup, &load_reg_adjacent_x2_ilp4, &teardown }, "LD1W (two register, adjacent, predicated)", "reg-adjacent", "FEAT_SME2", "load", 2, 32, 4},
  {{ &setup, &load_reg_adjacent_x2_ilp5, &teardown }, "LD1W (two register, adjacent, predicated)", "reg-adjacent", "FEAT_SME2", "load", 2, 32, 5},
  {{ &setup, &load_reg_adjacent_x2_ilp6, &teardown }, "LD1W (two register, adjacent, predicated)", "reg-adjacent", "FEAT_SME2", "load", 2, 32, 6},
  {{ &setup, &load_reg_adjacent_x2_ilp7, &teardown }, "LD1W (two register, adjacent, predicated)", "reg-adjacent", "FEAT_SME2", "load", 2, 32, 7},
  {{ &setup, &load_reg_adjacent_x2_ilp8, &teardown }, "LD1W (two register, adjacent, predicated)", "reg-adjacent", "FEAT_SME2", "load", 2, 32, 8},
  {{ &setup, &store_reg_adjacent_x2_ilp1, &teardown }, "ST1W (two register, adjacent, predicated)", "reg-adjacent", "FEAT_SME2", "store", 2, 32, 1},
  {{ &setup, &store_reg_adjacent_x2_ilp2, &teardown }, "ST1W (two register, adjacent, predicated)", "reg-adjacent", "FEAT_SME2", "store", 2, 32, 2},
  {{ &setup, &store_reg_adjacent_x2_ilp3, &teardown }, "ST1W (two register, adjacent, predicated)", "reg-adjacent", "FEAT_SME2", "store", 2, 32, 3},
  {{ &setup, &store_reg_adjacent_x2_ilp4, &teardown }, "ST1W (two register, adjacent, predicated)", "reg-adjacent", "FEAT_SME2", "store", 2, 32, 4},
  {{ &setup, &store_reg_adjacent_x2_ilp5, &teardown }, "ST1W (two register, adjacent, predicated)", "reg-adjacent", "FEAT_SME2", "store", 2, 32, 5},
  {{ &setup, &store_reg_adjacent_x2_ilp6, &teardown }, "ST1W (two register, adjacent, predicated)", "reg-adjacent", "FEAT_SME2", "store", 2, 32, 6},
  {{ &setup, &store_reg_adjacent_x2_ilp7, &teardown }, "ST1W (two register, adjacent, predicated)", "reg-adjacent", "FEAT_SME2", "store", 2, 32, 7},
  {{ &setup, &store_reg_adjacent_x2_ilp8, &teardown }, "ST1W (two register, adjacent, predicated)", "reg-adjacent", "FEAT_SME2", "store", 2, 32, 8},
  {{ &setup, &copy_reg_adjacent_x2_ilp1, &teardown }, "LD1W/ST1W (two register, adjacent, predicated)", "reg-adjacent", "FEAT_SME2", "copy", 2, 32, 1},
  {{ &setup, &copy_reg_adjacent_x2_ilp2, &teardown }, "LD1W/ST1W (two register, adjacent, predicated)", "reg-adjacent", "FEAT_SME2", "copy", 2, 32, 2},
  {{ &setup, &copy_reg_adjacent_x2_ilp3, &teardown }, "LD1W/ST1W (two register, adjacent, predicated)", "reg-adjacent", "FEAT_SME2", "copy", 2, 32, 3},
  {{ &setup, &copy_reg_adjacent_x2_ilp4, &teardown }, "LD1W/ST1W (two register, adjacent, predicated)", "reg-adjacent", "FEAT_SME2", "copy", 2, 32, 4},
  {{ &setup, &copy_reg_adjacent_x2_ilp5, &teardown }, "LD1W/ST1W (two register, adjacent, predicated)", "reg-adjacent", "FEAT_SME2", "copy", 2, 32, 5},
  {{ &setup, &copy_reg_adjacent_x2_ilp6, &teardown }, "LD1W/ST1W (two register, adjacent, predicated)", "reg-adjacent", "FEAT_SME2", "copy", 2, 32, 6},
  {{ &setup, &copy_reg_adjacent_x2_ilp7, &teardown }, "LD1W/ST1W (two register, adjacent, predicated)", "reg-adjacent", "FEAT_SME2", "copy", 2, 32, 7},
  {{ &setup, &copy_reg_adjacent_x2_ilp8, &teardown }, "LD1W/ST1W (two register, adjacent, predicated)", "reg-adjacent", "FEAT_SME2", "copy", 2, 32, 8},
  {{ &setup, &load_reg_adjacent_x4_ilp1, &teardown }, "LD1W (four register, adjacent, predicated)", "reg-adjacent", "FEAT_SME2", "load", 4, 32, 1},
  {{ &setup, &load_reg_adjacent_x4_ilp2, &teardown }, "LD1W (four register, adjacent, predicated)", "reg-adjacent", "FEAT_SME2", "load", 4, 32, 2},
  {{ &setup, &load_reg_adjacent_x4_ilp3, &teardown }, "LD1W (four register, adjacent, predicated)", "reg-adjacent", "FEAT_SME2", "load", 4, 32, 3},
  {{ &setup, &load_reg_adjacent_x4_ilp4, &teardown }, "LD1W (four register, adjacent, predicated)", "reg-adjacent", "FEAT_SME2", "load", 4, 32, 4},
  {{ &setup, &load_reg_adjacent_x4_ilp5, &teardown }, "LD1W (four register, adjacent, predicated)", "reg-adjacent", "FEAT_SME2", "load", 4, 32, 5},
  {{ &setup, &load_reg_adjacent_x4_ilp6, &teardown }, "LD1W (four register, adjacent, predicated)", "reg-adjacent", "FEAT_SME2", "load", 4, 32, 6},
  {{ &setup, &load_reg_adjacent_x4_ilp7, &teardown }, "LD1W (four register, adjacent, predicated)", "reg-adjacent", "FEAT_SME2", "load", 4, 32, 7},
  {{ &setup, &load_reg_adjacent_x4_ilp8, &teardown }, "LD1W (four register, adjacent, predicated)", "reg-adjacent", "FEAT_SME2", "load", 4, 32, 8},
  {{ &setup, &store_reg_adjacent_x4_ilp1, &teardown }, "ST1W (four register, adjacent, predicated)", "reg-adjacent", "FEAT_SME2", "store", 4, 32, 1},
  {{ &setup, &store_reg_adjacent_x4_ilp2, &teardown }, "ST1W (four register, adjacent, predicated)", "reg-adjacent", "FEAT_SME2", "store", 4, 32, 2},
  {{ &setup, &store_reg_adjacent_x4_ilp3, &teardown }, "ST1W (four register, adjacent, predicated)", "reg-adjacent", "FEAT_SME2", "store", 4, 32, 3},
  {{ &setup, &store_reg_adjacent_x4_ilp4, &teardown }, "ST1W (four register, adjacent, predicated)", "reg-adjacent", "FEAT_SME2", "store", 4, 32, 4},
  {{ &setup, &store_reg_adjacent_x4_ilp5, &teardown }, "ST1W (four register, adjacent, predicated)", "reg-adjacent", "FEAT_SME2", "store", 4, 32, 5},
  {{ &setup, &store_reg_adjacent_x4_ilp6, &teardown }, "ST1W (four register, adjacent, predicated)", "reg-adjacent", "FEAT_SME2", "store", 4, 32, 6},
  {{ &setup, &store_reg_adjacent_x4_ilp7, &teardown }, "ST1W (four register, adjacent, predicated)", "reg-adjacent", "FEAT_SME2", "store", 4, 32, 7},
  {{ &setup, &store_reg_adjacent_x4_ilp8, &teardown }, "ST1W (four register, adjacent, predicated)", "reg-adjacent", "FEAT_SME2", "store", 4, 32, 8},
  {{ &setup, &copy_reg_adjacent_x4_ilp1, &teardown }, "LD1W/ST1W (four register, adjacent, predicated)", "reg-adjacent", "FEAT_SME2", "copy", 4, 32, 1},
  {{ &setup, &copy_reg_adjacent_x4_ilp2, &teardown }, "LD1W/ST1W (four register, adjacent, predicated)", "reg-adjacent", "FEAT_SME2", "copy", 4, 32, 2},
  {{ &setup, &copy_reg_adjacent_x4_ilp3, &teardown }, "LD1W/ST1W (four register, adjacent, predicated)", "reg-adjacent", "FEAT_SME2", "copy", 4, 32, 3},
  {{ &setup, &copy_reg_adjacent_x4_ilp4, &teardown }, "LD1W/ST1W (four register, adjacent, predicated)", "reg-adjacent", "FEAT_SME2", "copy", 4, 32, 4},
  {{ &setup, &copy_reg_adjacent_x4_ilp5, &teardown }, "LD1W/ST1W (four register, adjacent, predicated)", "reg-adjacent", "FEAT_SME2", "copy", 4, 32, 5},
  {{ &setup, &copy_reg_adjacent_x4_ilp6, &teardown }, "LD1W/ST1W (four register, adjacent, predicated)", "reg-adjacent", "FEAT_SME2", "copy", 4, 32, 6},
  {{ &setup, &copy_reg_adjacent_x4_ilp7, &teardown }, "LD1W/ST1W (four register, adjacent, predicated)", "reg-adjacent", "FEAT_SME2", "copy", 4, 32, 7},
  {{ &setup, &copy_reg_adjacent_x4_ilp8, &teardown }, "LD1W/ST1W (four register, adjacent, predicated)", "reg-adjacent", "FEAT_SME2", "copy", 4, 32, 8},
  {{ &setup, &load_reg_strided_x2_ilp1, &teardown }, "LD1W (two register, strided, predicated)", "reg-strided", "FEAT_SME2", "load", 2, 32, 1},
  {{ &setup, &load_reg_strided_x2_ilp2, &teardown }, "LD1W (two register, strided, predicated)", "reg-strided", "FEAT_SME2", "load", 2, 32, 2},
  {{ &setup, &load_reg_strided_x2_ilp3, &teardown }, "LD1W (two register, strided, predicated)", "reg-strided", "FEAT_SME2", "load", 2, 32, 3},
  {{ &setup, &load_reg_strided_x2_ilp4, &teardown }, "LD1W (two register, strided, predicated)", "reg-strided", "FEAT_SME2", "load", 2, 32, 4},
  {{ &setup, &load_reg_strided_x2_ilp5, &teardown }, "LD1W (two register, strided, predicated)", "reg-strided", "FEAT_SME2", "load", 2, 32, 5},
  {{ &setup, &load_reg_strided_x2_ilp6, &teardown }, "LD1W (two register, strided, predicated)", "reg-strided", "FEAT_SME2", "load", 2, 32, 6},
  {{ &setup, &load_reg_strided_x2_ilp7, &teardown }, "LD1W (two register, strided, predicated)", "reg-strided", "FEAT_SME2", "load", 2, 32, 7},
  {{ &setup, &load_reg_strided_x2_ilp8, &teardown }, "LD1W (two register, strided, predicated)", "reg-strided", "FEAT_SME2", "load", 2, 32, 8},
  {{ &setup, &store_reg_strided_x2_ilp1, &teardown }, "ST1W (two register, strided, predicated)", "reg-strided", "FEAT_SME2", "store", 2, 32, 1},
  {{ &setup, &store_reg_strided_x2_ilp2, &teardown }, "ST1W (two register, strided, predicated)", "reg-strided", "FEAT_SME2", "store", 2, 32, 2},
  {{ &setup, &store_reg_strided_x2_ilp3, &teardown }, "ST1W (two register, strided, predicated)", "reg-strided", "FEAT_SME2", "store", 2, 32, 3},
  {{ &setup, &store_reg_strided_x2_ilp4, &teardown }, "ST1W (two register, strided, predicated)", "reg-strided", "FEAT_SME2", "store", 2, 32, 4},
  {{ &setup, &store_reg_strided_x2_ilp5, &teardown }, "ST1W (two register, strided, predicated)", "reg-strided", "FEAT_SME2", "store", 2, 32, 5},
  {{ &setup, &store_reg_strided_x2_ilp6, &teardown }, "ST1W (two register, strided, predicated)", "reg-strided", "FEAT_SME2", "store", 2, 32, 6},
  {{ &setup, &store_reg_strided_x2_ilp7, &teardown }, "ST1W (two register, strided, predicated)", "reg-strided", "FEAT_SME2", "store", 2, 32, 7},
  {{ &setup, &store_reg_strided_x2_ilp8, &teardown }, "ST1W (two register, strided, predicated)", "reg-strided", "FEAT_SME2", "store", 2, 32, 8},
  {{ &setup, &copy_reg_strided_x2_ilp1, &teardown }, "LD1W/ST1W (two register, strided, predicated)", "reg-strided", "FEAT_SME2", "copy", 2, 32, 1},
  {{ &setup, &copy_reg_strided_x2_ilp2, &teardown }, "LD1W/ST1W (two register, strided, predicated)", "reg-strided", "FEAT_SME2", "copy", 2, 32, 2},
  {{ &setup, &copy_reg_strided_x2_ilp3, &teardown }, "LD1W/ST1W (two register, strided, predicated)", "reg-strided", "FEAT_SME2", "copy", 2, 32, 3},
  {{ &setup, &copy_reg_strided_x2_ilp4, &teardown }, "LD1W/ST1W (two register, strided, predicated)", "reg-strided", "FEAT_SME2", "copy", 2, 32, 4},
  {{ &setup, &copy_reg_strided_x2_ilp5, &teardown }, "LD1W/ST1W (two register, strided, predicated)", "reg-strided", "FEAT_SME2", "copy", 2, 32, 5},
  {{ &setup, &copy_reg_strided_x2_ilp6, &teardown }, "LD1W/ST1W (two register, strided, predicated)", "reg-strided", "FEAT_SME2", "copy", 2, 32, 6},
  {{ &setup, &copy_reg_strided_x2_ilp7, &teardown }, "LD1W/ST1W (two register, strided, predicated)", "reg-strided", "FEAT_SME2", "copy", 2, 32, 7},
  {{ &setup, &copy_reg_strided_x2_ilp8, &teardown }, "LD1W/ST1W (two register, strided, predicated)", "reg-strided", "FEAT_SME2", "copy", 2, 32, 8},
  {{ &setup, &load_reg_strided_x4_ilp1, &teardown }, "LD1W (four register, strided, predicated)", "reg-strided", "FEAT_SME2", "load", 4, 32, 1},
  {{ &setup, &load_reg_strided_x4_ilp2, &teardown }, "LD1W (four register, strided, predicated)", "reg-strided", "FEAT_SME2", "load", 4, 32, 2},
  {{ &setup, &load_reg_strided_x4_ilp3, &teardown }, "LD1W (four register, strided, predicated)", "reg-strided", "FEAT_SME2", "load", 4, 32, 3},
  {{ &setup, &load_reg_strided_x4_ilp4, &teardown }, "LD1W (four register, strided, predicated)", "reg-strided", "FEAT_SME2", "load", 4, 32, 4},
  {{ &setup, &load_reg_strided_x4_ilp5, &teardown }, "LD1W (four register, strided, predicated)", "reg-strided", "FEAT_SME2", "load", 4, 32, 5},
  {{ &setup, &load_reg_strided_x4_ilp6, &teardown }, "LD1W (four register, strided, predicated)", "reg-strided", "FEAT_SME2", "load", 4, 32, 6},
  {{ &setup, &load_reg_strided_x4_ilp7, &teardown }, "LD1W (four register, strided, predicated)", "reg-strided", "FEAT_SME2", "load", 4, 32, 7},
  {{ &setup, &load_reg_strided_x4_ilp8, &teardown }, "LD1W (four register, strided, predicated)", "reg-strided", "FEAT_SME2", "load", 4, 32, 8},
  {{ &setup, &store_reg_strided_x4_ilp1, &teardown }, "ST1W (four register, strided, predicated)", "reg-strided", "FEAT_SME2", "store", 4, 32, 1},
  {{ &setup, &store_reg_strided_x4_ilp2, &teardown }, "ST1W (four register, strided, predicated)", "reg-strided", "FEAT_SME2", "store", 4, 32, 2},
  {{ &setup, &store_reg_strided_x4_ilp3, &teardown }, "ST1W (four register, strided, predicated)", "reg-strided", "FEAT_SME2", "store", 4, 32, 3},
  {{ &setup, &store_reg_strided_x4_ilp4, &teardown }, "ST1W (four register, strided, predicated)", "reg-strided", "FEAT_SME2", "store", 4, 32, 4},
  {{ &setup, &store_reg_strided_x4_ilp5, &teardown }, "ST1W (four register, strided, predicated)", "reg-strided", "FEAT_SME2", "store", 4, 32, 5},
  {{ &setup, &store_reg_strided_x4_ilp6, &teardown }, "ST1W (four register, strided, predicated)", "reg-strided", "FEAT_SME2", "store", 4, 32, 6},
  {{ &setup, &store_reg_strided_x4_ilp7, &teardown }, "ST1W (four register, strided, predicated)", "reg-strided", "FEAT_SME2", "store", 4, 32, 7},
  {{ &setup, &store_reg_strided_x4_ilp8, &teardown }, "ST1W (four register, strided, predicated)", "reg-strided", "FEAT_SME2", "store", 4, 32, 8},
  {{ &setup, &copy_reg_strided_x4_ilp1, &teardown }, "LD1W/ST1W (four register, strided, predicated)", "reg-strided", "FEAT_SME2", "copy", 4, 32, 1},
  {{ &setup, &copy_reg_strided_x4_ilp2, &teardown }, "LD1W/ST1W (four register, strided, predicated)", "reg-strided", "FEAT_SME2", "copy", 4, 32, 2},
  {{ &setup, &copy_reg_strided_x4_ilp3, &teardown }, "LD1W/ST1W (four register, strided, predicated)", "reg-strided", "FEAT_SME2", "copy", 4, 32, 3},
  {{ &setup, &copy_reg_strided_x4_ilp4, &teardown }, "LD1W/ST1W (four register, strided, predicated)", "reg-strided", "FEAT_SME2", "copy", 4, 32, 4},
  {{ &setup, &copy_reg_strided_x4_ilp5, &teardown }, "LD1W/ST1W (four register, strided, predicated)", "reg-strided", "FEAT_SME2", "copy", 4, 32, 5},
  {{ &setup, &copy_reg_strided_x4_ilp6, &teardown }, "LD1W/ST1W (four register, strided, predicated)", "reg-strided", "FEAT_SME2", "copy", 4, 32, 6},
  {{ &setup, &copy_reg_strided_x4_ilp7, &teardown }, "LD1W/ST1W (four register, strided, predicated)", "reg-strided", "FEAT_SME2", "copy", 4, 32, 7},
  {{ &setup, &copy_reg_strided_x4_ilp8, &teardown }, "LD1W/ST1W (four register, strided, predicated)", "reg-strided", "FEAT_SME2", "copy", 4, 32, 8}
};

CONST_PTR(mem_benchmark_t) mem_benchmarks = benchmarks;
const size_t mem_benchmarks_count = sizeof(benchmarks)/sizeof(benchmarks[0]);

