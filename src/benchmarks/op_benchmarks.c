// generated by tools/gen_op_benchmarks.py, do not edit!
#include <assert.h>
#include "bench.h"

// Number of iterations
static const size_t N_ITERATIONS = 8000000;

// benchmark functions

static double fdot_f32_f16_ilp1(const void*) {
  // FDOT (FP16 to FP32, 2-way, one vector), Dot Product (floating-point)
  //
  // Each instruction: (32x f16, 32x f16) → 16x f32 (64 OPs)
  // Total of 64 OPs per loop iteration, ILP = 1
  size_t n_iterations = N_ITERATIONS;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  fdot z0.s, z0.h, z0.h                                     \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*1.0*(double)n_iterations;
}


static double fdot_f32_f16_ilp2(const void*) {
  // FDOT (FP16 to FP32, 2-way, one vector), Dot Product (floating-point)
  //
  // Each instruction: (32x f16, 32x f16) → 16x f32 (64 OPs)
  // Total of 128 OPs per loop iteration, ILP = 2
  size_t n_iterations = N_ITERATIONS/2;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  fdot z0.s, z0.h, z0.h                                     \n"
    "  fdot z1.s, z1.h, z1.h                                     \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*2.0*(double)n_iterations;
}


static double fdot_f32_f16_ilp3(const void*) {
  // FDOT (FP16 to FP32, 2-way, one vector), Dot Product (floating-point)
  //
  // Each instruction: (32x f16, 32x f16) → 16x f32 (64 OPs)
  // Total of 192 OPs per loop iteration, ILP = 3
  size_t n_iterations = N_ITERATIONS/3;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  fdot z0.s, z0.h, z0.h                                     \n"
    "  fdot z1.s, z1.h, z1.h                                     \n"
    "  fdot z2.s, z2.h, z2.h                                     \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*3.0*(double)n_iterations;
}


static double fdot_f32_f16_ilp4(const void*) {
  // FDOT (FP16 to FP32, 2-way, one vector), Dot Product (floating-point)
  //
  // Each instruction: (32x f16, 32x f16) → 16x f32 (64 OPs)
  // Total of 256 OPs per loop iteration, ILP = 4
  size_t n_iterations = N_ITERATIONS/4;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  fdot z0.s, z0.h, z0.h                                     \n"
    "  fdot z1.s, z1.h, z1.h                                     \n"
    "  fdot z2.s, z2.h, z2.h                                     \n"
    "  fdot z3.s, z3.h, z3.h                                     \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*4.0*(double)n_iterations;
}


static double fdot_f32_f16_ilp5(const void*) {
  // FDOT (FP16 to FP32, 2-way, one vector), Dot Product (floating-point)
  //
  // Each instruction: (32x f16, 32x f16) → 16x f32 (64 OPs)
  // Total of 320 OPs per loop iteration, ILP = 5
  size_t n_iterations = N_ITERATIONS/5;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  fdot z0.s, z0.h, z0.h                                     \n"
    "  fdot z1.s, z1.h, z1.h                                     \n"
    "  fdot z2.s, z2.h, z2.h                                     \n"
    "  fdot z3.s, z3.h, z3.h                                     \n"
    "  fdot z4.s, z4.h, z4.h                                     \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*5.0*(double)n_iterations;
}


static double fdot_f32_f16_ilp6(const void*) {
  // FDOT (FP16 to FP32, 2-way, one vector), Dot Product (floating-point)
  //
  // Each instruction: (32x f16, 32x f16) → 16x f32 (64 OPs)
  // Total of 384 OPs per loop iteration, ILP = 6
  size_t n_iterations = N_ITERATIONS/6;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  fdot z0.s, z0.h, z0.h                                     \n"
    "  fdot z1.s, z1.h, z1.h                                     \n"
    "  fdot z2.s, z2.h, z2.h                                     \n"
    "  fdot z3.s, z3.h, z3.h                                     \n"
    "  fdot z4.s, z4.h, z4.h                                     \n"
    "  fdot z5.s, z5.h, z5.h                                     \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*6.0*(double)n_iterations;
}


static double fdot_f32_f16_ilp7(const void*) {
  // FDOT (FP16 to FP32, 2-way, one vector), Dot Product (floating-point)
  //
  // Each instruction: (32x f16, 32x f16) → 16x f32 (64 OPs)
  // Total of 448 OPs per loop iteration, ILP = 7
  size_t n_iterations = N_ITERATIONS/7;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  fdot z0.s, z0.h, z0.h                                     \n"
    "  fdot z1.s, z1.h, z1.h                                     \n"
    "  fdot z2.s, z2.h, z2.h                                     \n"
    "  fdot z3.s, z3.h, z3.h                                     \n"
    "  fdot z4.s, z4.h, z4.h                                     \n"
    "  fdot z5.s, z5.h, z5.h                                     \n"
    "  fdot z6.s, z6.h, z6.h                                     \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*7.0*(double)n_iterations;
}


static double fdot_f32_f16_ilp8(const void*) {
  // FDOT (FP16 to FP32, 2-way, one vector), Dot Product (floating-point)
  //
  // Each instruction: (32x f16, 32x f16) → 16x f32 (64 OPs)
  // Total of 512 OPs per loop iteration, ILP = 8
  size_t n_iterations = N_ITERATIONS/8;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  fdot z0.s, z0.h, z0.h                                     \n"
    "  fdot z1.s, z1.h, z1.h                                     \n"
    "  fdot z2.s, z2.h, z2.h                                     \n"
    "  fdot z3.s, z3.h, z3.h                                     \n"
    "  fdot z4.s, z4.h, z4.h                                     \n"
    "  fdot z5.s, z5.h, z5.h                                     \n"
    "  fdot z6.s, z6.h, z6.h                                     \n"
    "  fdot z7.s, z7.h, z7.h                                     \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*8.0*(double)n_iterations;
}


static double fdot_f32_f16_ilp9(const void*) {
  // FDOT (FP16 to FP32, 2-way, one vector), Dot Product (floating-point)
  //
  // Each instruction: (32x f16, 32x f16) → 16x f32 (64 OPs)
  // Total of 576 OPs per loop iteration, ILP = 9
  size_t n_iterations = N_ITERATIONS/9;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  fdot z0.s, z0.h, z0.h                                     \n"
    "  fdot z1.s, z1.h, z1.h                                     \n"
    "  fdot z2.s, z2.h, z2.h                                     \n"
    "  fdot z3.s, z3.h, z3.h                                     \n"
    "  fdot z4.s, z4.h, z4.h                                     \n"
    "  fdot z5.s, z5.h, z5.h                                     \n"
    "  fdot z6.s, z6.h, z6.h                                     \n"
    "  fdot z7.s, z7.h, z7.h                                     \n"
    "  fdot z8.s, z8.h, z8.h                                     \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*9.0*(double)n_iterations;
}


static double fdot_f32_f16_ilp10(const void*) {
  // FDOT (FP16 to FP32, 2-way, one vector), Dot Product (floating-point)
  //
  // Each instruction: (32x f16, 32x f16) → 16x f32 (64 OPs)
  // Total of 640 OPs per loop iteration, ILP = 10
  size_t n_iterations = N_ITERATIONS/10;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  fdot z0.s, z0.h, z0.h                                     \n"
    "  fdot z1.s, z1.h, z1.h                                     \n"
    "  fdot z2.s, z2.h, z2.h                                     \n"
    "  fdot z3.s, z3.h, z3.h                                     \n"
    "  fdot z4.s, z4.h, z4.h                                     \n"
    "  fdot z5.s, z5.h, z5.h                                     \n"
    "  fdot z6.s, z6.h, z6.h                                     \n"
    "  fdot z7.s, z7.h, z7.h                                     \n"
    "  fdot z8.s, z8.h, z8.h                                     \n"
    "  fdot z9.s, z9.h, z9.h                                     \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*10.0*(double)n_iterations;
}


static double fdot_f32_f16_ilp11(const void*) {
  // FDOT (FP16 to FP32, 2-way, one vector), Dot Product (floating-point)
  //
  // Each instruction: (32x f16, 32x f16) → 16x f32 (64 OPs)
  // Total of 704 OPs per loop iteration, ILP = 11
  size_t n_iterations = N_ITERATIONS/11;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  fdot z0.s, z0.h, z0.h                                     \n"
    "  fdot z1.s, z1.h, z1.h                                     \n"
    "  fdot z2.s, z2.h, z2.h                                     \n"
    "  fdot z3.s, z3.h, z3.h                                     \n"
    "  fdot z4.s, z4.h, z4.h                                     \n"
    "  fdot z5.s, z5.h, z5.h                                     \n"
    "  fdot z6.s, z6.h, z6.h                                     \n"
    "  fdot z7.s, z7.h, z7.h                                     \n"
    "  fdot z8.s, z8.h, z8.h                                     \n"
    "  fdot z9.s, z9.h, z9.h                                     \n"
    "  fdot z10.s, z10.h, z10.h                                  \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*11.0*(double)n_iterations;
}


static double fdot_f32_f16_ilp12(const void*) {
  // FDOT (FP16 to FP32, 2-way, one vector), Dot Product (floating-point)
  //
  // Each instruction: (32x f16, 32x f16) → 16x f32 (64 OPs)
  // Total of 768 OPs per loop iteration, ILP = 12
  size_t n_iterations = N_ITERATIONS/12;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  fdot z0.s, z0.h, z0.h                                     \n"
    "  fdot z1.s, z1.h, z1.h                                     \n"
    "  fdot z2.s, z2.h, z2.h                                     \n"
    "  fdot z3.s, z3.h, z3.h                                     \n"
    "  fdot z4.s, z4.h, z4.h                                     \n"
    "  fdot z5.s, z5.h, z5.h                                     \n"
    "  fdot z6.s, z6.h, z6.h                                     \n"
    "  fdot z7.s, z7.h, z7.h                                     \n"
    "  fdot z8.s, z8.h, z8.h                                     \n"
    "  fdot z9.s, z9.h, z9.h                                     \n"
    "  fdot z10.s, z10.h, z10.h                                  \n"
    "  fdot z11.s, z11.h, z11.h                                  \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*12.0*(double)n_iterations;
}


static double fdot_f32_f16_ilp13(const void*) {
  // FDOT (FP16 to FP32, 2-way, one vector), Dot Product (floating-point)
  //
  // Each instruction: (32x f16, 32x f16) → 16x f32 (64 OPs)
  // Total of 832 OPs per loop iteration, ILP = 13
  size_t n_iterations = N_ITERATIONS/13;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  fdot z0.s, z0.h, z0.h                                     \n"
    "  fdot z1.s, z1.h, z1.h                                     \n"
    "  fdot z2.s, z2.h, z2.h                                     \n"
    "  fdot z3.s, z3.h, z3.h                                     \n"
    "  fdot z4.s, z4.h, z4.h                                     \n"
    "  fdot z5.s, z5.h, z5.h                                     \n"
    "  fdot z6.s, z6.h, z6.h                                     \n"
    "  fdot z7.s, z7.h, z7.h                                     \n"
    "  fdot z8.s, z8.h, z8.h                                     \n"
    "  fdot z9.s, z9.h, z9.h                                     \n"
    "  fdot z10.s, z10.h, z10.h                                  \n"
    "  fdot z11.s, z11.h, z11.h                                  \n"
    "  fdot z12.s, z12.h, z12.h                                  \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*13.0*(double)n_iterations;
}


static double fdot_f32_f16_ilp14(const void*) {
  // FDOT (FP16 to FP32, 2-way, one vector), Dot Product (floating-point)
  //
  // Each instruction: (32x f16, 32x f16) → 16x f32 (64 OPs)
  // Total of 896 OPs per loop iteration, ILP = 14
  size_t n_iterations = N_ITERATIONS/14;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  fdot z0.s, z0.h, z0.h                                     \n"
    "  fdot z1.s, z1.h, z1.h                                     \n"
    "  fdot z2.s, z2.h, z2.h                                     \n"
    "  fdot z3.s, z3.h, z3.h                                     \n"
    "  fdot z4.s, z4.h, z4.h                                     \n"
    "  fdot z5.s, z5.h, z5.h                                     \n"
    "  fdot z6.s, z6.h, z6.h                                     \n"
    "  fdot z7.s, z7.h, z7.h                                     \n"
    "  fdot z8.s, z8.h, z8.h                                     \n"
    "  fdot z9.s, z9.h, z9.h                                     \n"
    "  fdot z10.s, z10.h, z10.h                                  \n"
    "  fdot z11.s, z11.h, z11.h                                  \n"
    "  fdot z12.s, z12.h, z12.h                                  \n"
    "  fdot z13.s, z13.h, z13.h                                  \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*14.0*(double)n_iterations;
}


static double fdot_f32_f16_ilp15(const void*) {
  // FDOT (FP16 to FP32, 2-way, one vector), Dot Product (floating-point)
  //
  // Each instruction: (32x f16, 32x f16) → 16x f32 (64 OPs)
  // Total of 960 OPs per loop iteration, ILP = 15
  size_t n_iterations = N_ITERATIONS/15;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  fdot z0.s, z0.h, z0.h                                     \n"
    "  fdot z1.s, z1.h, z1.h                                     \n"
    "  fdot z2.s, z2.h, z2.h                                     \n"
    "  fdot z3.s, z3.h, z3.h                                     \n"
    "  fdot z4.s, z4.h, z4.h                                     \n"
    "  fdot z5.s, z5.h, z5.h                                     \n"
    "  fdot z6.s, z6.h, z6.h                                     \n"
    "  fdot z7.s, z7.h, z7.h                                     \n"
    "  fdot z8.s, z8.h, z8.h                                     \n"
    "  fdot z9.s, z9.h, z9.h                                     \n"
    "  fdot z10.s, z10.h, z10.h                                  \n"
    "  fdot z11.s, z11.h, z11.h                                  \n"
    "  fdot z12.s, z12.h, z12.h                                  \n"
    "  fdot z13.s, z13.h, z13.h                                  \n"
    "  fdot z14.s, z14.h, z14.h                                  \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*15.0*(double)n_iterations;
}


static double fdot_f32_f16_ilp16(const void*) {
  // FDOT (FP16 to FP32, 2-way, one vector), Dot Product (floating-point)
  //
  // Each instruction: (32x f16, 32x f16) → 16x f32 (64 OPs)
  // Total of 1024 OPs per loop iteration, ILP = 16
  size_t n_iterations = N_ITERATIONS/16;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  fdot z0.s, z0.h, z0.h                                     \n"
    "  fdot z1.s, z1.h, z1.h                                     \n"
    "  fdot z2.s, z2.h, z2.h                                     \n"
    "  fdot z3.s, z3.h, z3.h                                     \n"
    "  fdot z4.s, z4.h, z4.h                                     \n"
    "  fdot z5.s, z5.h, z5.h                                     \n"
    "  fdot z6.s, z6.h, z6.h                                     \n"
    "  fdot z7.s, z7.h, z7.h                                     \n"
    "  fdot z8.s, z8.h, z8.h                                     \n"
    "  fdot z9.s, z9.h, z9.h                                     \n"
    "  fdot z10.s, z10.h, z10.h                                  \n"
    "  fdot z11.s, z11.h, z11.h                                  \n"
    "  fdot z12.s, z12.h, z12.h                                  \n"
    "  fdot z13.s, z13.h, z13.h                                  \n"
    "  fdot z14.s, z14.h, z14.h                                  \n"
    "  fdot z15.s, z15.h, z15.h                                  \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*16.0*(double)n_iterations;
}


static double bfdot_f32_b16_ilp1(const void*) {
  // BFDOT (BF16 to FP32, 2-way, one vector), Dot Product (floating-point)
  //
  // Each instruction: (32x b16, 32x b16) → 16x f32 (64 OPs)
  // Total of 64 OPs per loop iteration, ILP = 1
  size_t n_iterations = N_ITERATIONS;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  bfdot z0.s, z0.h, z0.h                                    \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*1.0*(double)n_iterations;
}


static double bfdot_f32_b16_ilp2(const void*) {
  // BFDOT (BF16 to FP32, 2-way, one vector), Dot Product (floating-point)
  //
  // Each instruction: (32x b16, 32x b16) → 16x f32 (64 OPs)
  // Total of 128 OPs per loop iteration, ILP = 2
  size_t n_iterations = N_ITERATIONS/2;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  bfdot z0.s, z0.h, z0.h                                    \n"
    "  bfdot z1.s, z1.h, z1.h                                    \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*2.0*(double)n_iterations;
}


static double bfdot_f32_b16_ilp3(const void*) {
  // BFDOT (BF16 to FP32, 2-way, one vector), Dot Product (floating-point)
  //
  // Each instruction: (32x b16, 32x b16) → 16x f32 (64 OPs)
  // Total of 192 OPs per loop iteration, ILP = 3
  size_t n_iterations = N_ITERATIONS/3;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  bfdot z0.s, z0.h, z0.h                                    \n"
    "  bfdot z1.s, z1.h, z1.h                                    \n"
    "  bfdot z2.s, z2.h, z2.h                                    \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*3.0*(double)n_iterations;
}


static double bfdot_f32_b16_ilp4(const void*) {
  // BFDOT (BF16 to FP32, 2-way, one vector), Dot Product (floating-point)
  //
  // Each instruction: (32x b16, 32x b16) → 16x f32 (64 OPs)
  // Total of 256 OPs per loop iteration, ILP = 4
  size_t n_iterations = N_ITERATIONS/4;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  bfdot z0.s, z0.h, z0.h                                    \n"
    "  bfdot z1.s, z1.h, z1.h                                    \n"
    "  bfdot z2.s, z2.h, z2.h                                    \n"
    "  bfdot z3.s, z3.h, z3.h                                    \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*4.0*(double)n_iterations;
}


static double bfdot_f32_b16_ilp5(const void*) {
  // BFDOT (BF16 to FP32, 2-way, one vector), Dot Product (floating-point)
  //
  // Each instruction: (32x b16, 32x b16) → 16x f32 (64 OPs)
  // Total of 320 OPs per loop iteration, ILP = 5
  size_t n_iterations = N_ITERATIONS/5;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  bfdot z0.s, z0.h, z0.h                                    \n"
    "  bfdot z1.s, z1.h, z1.h                                    \n"
    "  bfdot z2.s, z2.h, z2.h                                    \n"
    "  bfdot z3.s, z3.h, z3.h                                    \n"
    "  bfdot z4.s, z4.h, z4.h                                    \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*5.0*(double)n_iterations;
}


static double bfdot_f32_b16_ilp6(const void*) {
  // BFDOT (BF16 to FP32, 2-way, one vector), Dot Product (floating-point)
  //
  // Each instruction: (32x b16, 32x b16) → 16x f32 (64 OPs)
  // Total of 384 OPs per loop iteration, ILP = 6
  size_t n_iterations = N_ITERATIONS/6;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  bfdot z0.s, z0.h, z0.h                                    \n"
    "  bfdot z1.s, z1.h, z1.h                                    \n"
    "  bfdot z2.s, z2.h, z2.h                                    \n"
    "  bfdot z3.s, z3.h, z3.h                                    \n"
    "  bfdot z4.s, z4.h, z4.h                                    \n"
    "  bfdot z5.s, z5.h, z5.h                                    \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*6.0*(double)n_iterations;
}


static double bfdot_f32_b16_ilp7(const void*) {
  // BFDOT (BF16 to FP32, 2-way, one vector), Dot Product (floating-point)
  //
  // Each instruction: (32x b16, 32x b16) → 16x f32 (64 OPs)
  // Total of 448 OPs per loop iteration, ILP = 7
  size_t n_iterations = N_ITERATIONS/7;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  bfdot z0.s, z0.h, z0.h                                    \n"
    "  bfdot z1.s, z1.h, z1.h                                    \n"
    "  bfdot z2.s, z2.h, z2.h                                    \n"
    "  bfdot z3.s, z3.h, z3.h                                    \n"
    "  bfdot z4.s, z4.h, z4.h                                    \n"
    "  bfdot z5.s, z5.h, z5.h                                    \n"
    "  bfdot z6.s, z6.h, z6.h                                    \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*7.0*(double)n_iterations;
}


static double bfdot_f32_b16_ilp8(const void*) {
  // BFDOT (BF16 to FP32, 2-way, one vector), Dot Product (floating-point)
  //
  // Each instruction: (32x b16, 32x b16) → 16x f32 (64 OPs)
  // Total of 512 OPs per loop iteration, ILP = 8
  size_t n_iterations = N_ITERATIONS/8;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  bfdot z0.s, z0.h, z0.h                                    \n"
    "  bfdot z1.s, z1.h, z1.h                                    \n"
    "  bfdot z2.s, z2.h, z2.h                                    \n"
    "  bfdot z3.s, z3.h, z3.h                                    \n"
    "  bfdot z4.s, z4.h, z4.h                                    \n"
    "  bfdot z5.s, z5.h, z5.h                                    \n"
    "  bfdot z6.s, z6.h, z6.h                                    \n"
    "  bfdot z7.s, z7.h, z7.h                                    \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*8.0*(double)n_iterations;
}


static double bfdot_f32_b16_ilp9(const void*) {
  // BFDOT (BF16 to FP32, 2-way, one vector), Dot Product (floating-point)
  //
  // Each instruction: (32x b16, 32x b16) → 16x f32 (64 OPs)
  // Total of 576 OPs per loop iteration, ILP = 9
  size_t n_iterations = N_ITERATIONS/9;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  bfdot z0.s, z0.h, z0.h                                    \n"
    "  bfdot z1.s, z1.h, z1.h                                    \n"
    "  bfdot z2.s, z2.h, z2.h                                    \n"
    "  bfdot z3.s, z3.h, z3.h                                    \n"
    "  bfdot z4.s, z4.h, z4.h                                    \n"
    "  bfdot z5.s, z5.h, z5.h                                    \n"
    "  bfdot z6.s, z6.h, z6.h                                    \n"
    "  bfdot z7.s, z7.h, z7.h                                    \n"
    "  bfdot z8.s, z8.h, z8.h                                    \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*9.0*(double)n_iterations;
}


static double bfdot_f32_b16_ilp10(const void*) {
  // BFDOT (BF16 to FP32, 2-way, one vector), Dot Product (floating-point)
  //
  // Each instruction: (32x b16, 32x b16) → 16x f32 (64 OPs)
  // Total of 640 OPs per loop iteration, ILP = 10
  size_t n_iterations = N_ITERATIONS/10;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  bfdot z0.s, z0.h, z0.h                                    \n"
    "  bfdot z1.s, z1.h, z1.h                                    \n"
    "  bfdot z2.s, z2.h, z2.h                                    \n"
    "  bfdot z3.s, z3.h, z3.h                                    \n"
    "  bfdot z4.s, z4.h, z4.h                                    \n"
    "  bfdot z5.s, z5.h, z5.h                                    \n"
    "  bfdot z6.s, z6.h, z6.h                                    \n"
    "  bfdot z7.s, z7.h, z7.h                                    \n"
    "  bfdot z8.s, z8.h, z8.h                                    \n"
    "  bfdot z9.s, z9.h, z9.h                                    \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*10.0*(double)n_iterations;
}


static double bfdot_f32_b16_ilp11(const void*) {
  // BFDOT (BF16 to FP32, 2-way, one vector), Dot Product (floating-point)
  //
  // Each instruction: (32x b16, 32x b16) → 16x f32 (64 OPs)
  // Total of 704 OPs per loop iteration, ILP = 11
  size_t n_iterations = N_ITERATIONS/11;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  bfdot z0.s, z0.h, z0.h                                    \n"
    "  bfdot z1.s, z1.h, z1.h                                    \n"
    "  bfdot z2.s, z2.h, z2.h                                    \n"
    "  bfdot z3.s, z3.h, z3.h                                    \n"
    "  bfdot z4.s, z4.h, z4.h                                    \n"
    "  bfdot z5.s, z5.h, z5.h                                    \n"
    "  bfdot z6.s, z6.h, z6.h                                    \n"
    "  bfdot z7.s, z7.h, z7.h                                    \n"
    "  bfdot z8.s, z8.h, z8.h                                    \n"
    "  bfdot z9.s, z9.h, z9.h                                    \n"
    "  bfdot z10.s, z10.h, z10.h                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*11.0*(double)n_iterations;
}


static double bfdot_f32_b16_ilp12(const void*) {
  // BFDOT (BF16 to FP32, 2-way, one vector), Dot Product (floating-point)
  //
  // Each instruction: (32x b16, 32x b16) → 16x f32 (64 OPs)
  // Total of 768 OPs per loop iteration, ILP = 12
  size_t n_iterations = N_ITERATIONS/12;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  bfdot z0.s, z0.h, z0.h                                    \n"
    "  bfdot z1.s, z1.h, z1.h                                    \n"
    "  bfdot z2.s, z2.h, z2.h                                    \n"
    "  bfdot z3.s, z3.h, z3.h                                    \n"
    "  bfdot z4.s, z4.h, z4.h                                    \n"
    "  bfdot z5.s, z5.h, z5.h                                    \n"
    "  bfdot z6.s, z6.h, z6.h                                    \n"
    "  bfdot z7.s, z7.h, z7.h                                    \n"
    "  bfdot z8.s, z8.h, z8.h                                    \n"
    "  bfdot z9.s, z9.h, z9.h                                    \n"
    "  bfdot z10.s, z10.h, z10.h                                 \n"
    "  bfdot z11.s, z11.h, z11.h                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*12.0*(double)n_iterations;
}


static double bfdot_f32_b16_ilp13(const void*) {
  // BFDOT (BF16 to FP32, 2-way, one vector), Dot Product (floating-point)
  //
  // Each instruction: (32x b16, 32x b16) → 16x f32 (64 OPs)
  // Total of 832 OPs per loop iteration, ILP = 13
  size_t n_iterations = N_ITERATIONS/13;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  bfdot z0.s, z0.h, z0.h                                    \n"
    "  bfdot z1.s, z1.h, z1.h                                    \n"
    "  bfdot z2.s, z2.h, z2.h                                    \n"
    "  bfdot z3.s, z3.h, z3.h                                    \n"
    "  bfdot z4.s, z4.h, z4.h                                    \n"
    "  bfdot z5.s, z5.h, z5.h                                    \n"
    "  bfdot z6.s, z6.h, z6.h                                    \n"
    "  bfdot z7.s, z7.h, z7.h                                    \n"
    "  bfdot z8.s, z8.h, z8.h                                    \n"
    "  bfdot z9.s, z9.h, z9.h                                    \n"
    "  bfdot z10.s, z10.h, z10.h                                 \n"
    "  bfdot z11.s, z11.h, z11.h                                 \n"
    "  bfdot z12.s, z12.h, z12.h                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*13.0*(double)n_iterations;
}


static double bfdot_f32_b16_ilp14(const void*) {
  // BFDOT (BF16 to FP32, 2-way, one vector), Dot Product (floating-point)
  //
  // Each instruction: (32x b16, 32x b16) → 16x f32 (64 OPs)
  // Total of 896 OPs per loop iteration, ILP = 14
  size_t n_iterations = N_ITERATIONS/14;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  bfdot z0.s, z0.h, z0.h                                    \n"
    "  bfdot z1.s, z1.h, z1.h                                    \n"
    "  bfdot z2.s, z2.h, z2.h                                    \n"
    "  bfdot z3.s, z3.h, z3.h                                    \n"
    "  bfdot z4.s, z4.h, z4.h                                    \n"
    "  bfdot z5.s, z5.h, z5.h                                    \n"
    "  bfdot z6.s, z6.h, z6.h                                    \n"
    "  bfdot z7.s, z7.h, z7.h                                    \n"
    "  bfdot z8.s, z8.h, z8.h                                    \n"
    "  bfdot z9.s, z9.h, z9.h                                    \n"
    "  bfdot z10.s, z10.h, z10.h                                 \n"
    "  bfdot z11.s, z11.h, z11.h                                 \n"
    "  bfdot z12.s, z12.h, z12.h                                 \n"
    "  bfdot z13.s, z13.h, z13.h                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*14.0*(double)n_iterations;
}


static double bfdot_f32_b16_ilp15(const void*) {
  // BFDOT (BF16 to FP32, 2-way, one vector), Dot Product (floating-point)
  //
  // Each instruction: (32x b16, 32x b16) → 16x f32 (64 OPs)
  // Total of 960 OPs per loop iteration, ILP = 15
  size_t n_iterations = N_ITERATIONS/15;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  bfdot z0.s, z0.h, z0.h                                    \n"
    "  bfdot z1.s, z1.h, z1.h                                    \n"
    "  bfdot z2.s, z2.h, z2.h                                    \n"
    "  bfdot z3.s, z3.h, z3.h                                    \n"
    "  bfdot z4.s, z4.h, z4.h                                    \n"
    "  bfdot z5.s, z5.h, z5.h                                    \n"
    "  bfdot z6.s, z6.h, z6.h                                    \n"
    "  bfdot z7.s, z7.h, z7.h                                    \n"
    "  bfdot z8.s, z8.h, z8.h                                    \n"
    "  bfdot z9.s, z9.h, z9.h                                    \n"
    "  bfdot z10.s, z10.h, z10.h                                 \n"
    "  bfdot z11.s, z11.h, z11.h                                 \n"
    "  bfdot z12.s, z12.h, z12.h                                 \n"
    "  bfdot z13.s, z13.h, z13.h                                 \n"
    "  bfdot z14.s, z14.h, z14.h                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*15.0*(double)n_iterations;
}


static double bfdot_f32_b16_ilp16(const void*) {
  // BFDOT (BF16 to FP32, 2-way, one vector), Dot Product (floating-point)
  //
  // Each instruction: (32x b16, 32x b16) → 16x f32 (64 OPs)
  // Total of 1024 OPs per loop iteration, ILP = 16
  size_t n_iterations = N_ITERATIONS/16;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  bfdot z0.s, z0.h, z0.h                                    \n"
    "  bfdot z1.s, z1.h, z1.h                                    \n"
    "  bfdot z2.s, z2.h, z2.h                                    \n"
    "  bfdot z3.s, z3.h, z3.h                                    \n"
    "  bfdot z4.s, z4.h, z4.h                                    \n"
    "  bfdot z5.s, z5.h, z5.h                                    \n"
    "  bfdot z6.s, z6.h, z6.h                                    \n"
    "  bfdot z7.s, z7.h, z7.h                                    \n"
    "  bfdot z8.s, z8.h, z8.h                                    \n"
    "  bfdot z9.s, z9.h, z9.h                                    \n"
    "  bfdot z10.s, z10.h, z10.h                                 \n"
    "  bfdot z11.s, z11.h, z11.h                                 \n"
    "  bfdot z12.s, z12.h, z12.h                                 \n"
    "  bfdot z13.s, z13.h, z13.h                                 \n"
    "  bfdot z14.s, z14.h, z14.h                                 \n"
    "  bfdot z15.s, z15.h, z15.h                                 \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*16.0*(double)n_iterations;
}


static double fdot_za_f32_f16_vgx2_ilp1(const void*) {
  // FDOT (FP16 to FP32, 2-way, two vectors), Dot Product (floating-point)
  //
  // Each instruction: (64x f16, 64x f16) → 32x f32 (128 OPs)
  // Total of 128 OPs per loop iteration, ILP = 1
  size_t n_iterations = N_ITERATIONS;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fdot za.s[w8, 0, VGx2], {z0.h-z1.h}, {z0.h-z1.h}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*1.0*(double)n_iterations;
}


static double fdot_za_f32_f16_vgx2_ilp2(const void*) {
  // FDOT (FP16 to FP32, 2-way, two vectors), Dot Product (floating-point)
  //
  // Each instruction: (64x f16, 64x f16) → 32x f32 (128 OPs)
  // Total of 256 OPs per loop iteration, ILP = 2
  size_t n_iterations = N_ITERATIONS/2;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fdot za.s[w8, 0, VGx2], {z0.h-z1.h}, {z0.h-z1.h}          \n"
    "  fdot za.s[w8, 1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*2.0*(double)n_iterations;
}


static double fdot_za_f32_f16_vgx2_ilp3(const void*) {
  // FDOT (FP16 to FP32, 2-way, two vectors), Dot Product (floating-point)
  //
  // Each instruction: (64x f16, 64x f16) → 32x f32 (128 OPs)
  // Total of 384 OPs per loop iteration, ILP = 3
  size_t n_iterations = N_ITERATIONS/3;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fdot za.s[w8, 0, VGx2], {z0.h-z1.h}, {z0.h-z1.h}          \n"
    "  fdot za.s[w8, 1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}          \n"
    "  fdot za.s[w8, 2, VGx2], {z2.h-z3.h}, {z2.h-z3.h}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*3.0*(double)n_iterations;
}


static double fdot_za_f32_f16_vgx2_ilp4(const void*) {
  // FDOT (FP16 to FP32, 2-way, two vectors), Dot Product (floating-point)
  //
  // Each instruction: (64x f16, 64x f16) → 32x f32 (128 OPs)
  // Total of 512 OPs per loop iteration, ILP = 4
  size_t n_iterations = N_ITERATIONS/4;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fdot za.s[w8, 0, VGx2], {z0.h-z1.h}, {z0.h-z1.h}          \n"
    "  fdot za.s[w8, 1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}          \n"
    "  fdot za.s[w8, 2, VGx2], {z2.h-z3.h}, {z2.h-z3.h}          \n"
    "  fdot za.s[w8, 3, VGx2], {z2.h-z3.h}, {z2.h-z3.h}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*4.0*(double)n_iterations;
}


static double fdot_za_f32_f16_vgx2_ilp5(const void*) {
  // FDOT (FP16 to FP32, 2-way, two vectors), Dot Product (floating-point)
  //
  // Each instruction: (64x f16, 64x f16) → 32x f32 (128 OPs)
  // Total of 640 OPs per loop iteration, ILP = 5
  size_t n_iterations = N_ITERATIONS/5;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fdot za.s[w8, 0, VGx2], {z0.h-z1.h}, {z0.h-z1.h}          \n"
    "  fdot za.s[w8, 1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}          \n"
    "  fdot za.s[w8, 2, VGx2], {z2.h-z3.h}, {z2.h-z3.h}          \n"
    "  fdot za.s[w8, 3, VGx2], {z2.h-z3.h}, {z2.h-z3.h}          \n"
    "  fdot za.s[w8, 4, VGx2], {z4.h-z5.h}, {z4.h-z5.h}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*5.0*(double)n_iterations;
}


static double fdot_za_f32_f16_vgx2_ilp6(const void*) {
  // FDOT (FP16 to FP32, 2-way, two vectors), Dot Product (floating-point)
  //
  // Each instruction: (64x f16, 64x f16) → 32x f32 (128 OPs)
  // Total of 768 OPs per loop iteration, ILP = 6
  size_t n_iterations = N_ITERATIONS/6;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fdot za.s[w8, 0, VGx2], {z0.h-z1.h}, {z0.h-z1.h}          \n"
    "  fdot za.s[w8, 1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}          \n"
    "  fdot za.s[w8, 2, VGx2], {z2.h-z3.h}, {z2.h-z3.h}          \n"
    "  fdot za.s[w8, 3, VGx2], {z2.h-z3.h}, {z2.h-z3.h}          \n"
    "  fdot za.s[w8, 4, VGx2], {z4.h-z5.h}, {z4.h-z5.h}          \n"
    "  fdot za.s[w8, 5, VGx2], {z4.h-z5.h}, {z4.h-z5.h}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*6.0*(double)n_iterations;
}


static double fdot_za_f32_f16_vgx2_ilp7(const void*) {
  // FDOT (FP16 to FP32, 2-way, two vectors), Dot Product (floating-point)
  //
  // Each instruction: (64x f16, 64x f16) → 32x f32 (128 OPs)
  // Total of 896 OPs per loop iteration, ILP = 7
  size_t n_iterations = N_ITERATIONS/7;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fdot za.s[w8, 0, VGx2], {z0.h-z1.h}, {z0.h-z1.h}          \n"
    "  fdot za.s[w8, 1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}          \n"
    "  fdot za.s[w8, 2, VGx2], {z2.h-z3.h}, {z2.h-z3.h}          \n"
    "  fdot za.s[w8, 3, VGx2], {z2.h-z3.h}, {z2.h-z3.h}          \n"
    "  fdot za.s[w8, 4, VGx2], {z4.h-z5.h}, {z4.h-z5.h}          \n"
    "  fdot za.s[w8, 5, VGx2], {z4.h-z5.h}, {z4.h-z5.h}          \n"
    "  fdot za.s[w8, 6, VGx2], {z6.h-z7.h}, {z6.h-z7.h}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*7.0*(double)n_iterations;
}


static double fdot_za_f32_f16_vgx2_ilp8(const void*) {
  // FDOT (FP16 to FP32, 2-way, two vectors), Dot Product (floating-point)
  //
  // Each instruction: (64x f16, 64x f16) → 32x f32 (128 OPs)
  // Total of 1024 OPs per loop iteration, ILP = 8
  size_t n_iterations = N_ITERATIONS/8;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fdot za.s[w8, 0, VGx2], {z0.h-z1.h}, {z0.h-z1.h}          \n"
    "  fdot za.s[w8, 1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}          \n"
    "  fdot za.s[w8, 2, VGx2], {z2.h-z3.h}, {z2.h-z3.h}          \n"
    "  fdot za.s[w8, 3, VGx2], {z2.h-z3.h}, {z2.h-z3.h}          \n"
    "  fdot za.s[w8, 4, VGx2], {z4.h-z5.h}, {z4.h-z5.h}          \n"
    "  fdot za.s[w8, 5, VGx2], {z4.h-z5.h}, {z4.h-z5.h}          \n"
    "  fdot za.s[w8, 6, VGx2], {z6.h-z7.h}, {z6.h-z7.h}          \n"
    "  fdot za.s[w8, 7, VGx2], {z6.h-z7.h}, {z6.h-z7.h}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*8.0*(double)n_iterations;
}


static double fdot_za_f32_f16_vgx2_ilp9(const void*) {
  // FDOT (FP16 to FP32, 2-way, two vectors), Dot Product (floating-point)
  //
  // Each instruction: (64x f16, 64x f16) → 32x f32 (128 OPs)
  // Total of 1152 OPs per loop iteration, ILP = 9
  size_t n_iterations = N_ITERATIONS/9;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fdot za.s[w8, 0, VGx2], {z0.h-z1.h}, {z0.h-z1.h}          \n"
    "  fdot za.s[w8, 1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}          \n"
    "  fdot za.s[w8, 2, VGx2], {z2.h-z3.h}, {z2.h-z3.h}          \n"
    "  fdot za.s[w8, 3, VGx2], {z2.h-z3.h}, {z2.h-z3.h}          \n"
    "  fdot za.s[w8, 4, VGx2], {z4.h-z5.h}, {z4.h-z5.h}          \n"
    "  fdot za.s[w8, 5, VGx2], {z4.h-z5.h}, {z4.h-z5.h}          \n"
    "  fdot za.s[w8, 6, VGx2], {z6.h-z7.h}, {z6.h-z7.h}          \n"
    "  fdot za.s[w8, 7, VGx2], {z6.h-z7.h}, {z6.h-z7.h}          \n"
    "  fdot za.s[w9, 0, VGx2], {z8.h-z9.h}, {z8.h-z9.h}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*9.0*(double)n_iterations;
}


static double fdot_za_f32_f16_vgx2_ilp10(const void*) {
  // FDOT (FP16 to FP32, 2-way, two vectors), Dot Product (floating-point)
  //
  // Each instruction: (64x f16, 64x f16) → 32x f32 (128 OPs)
  // Total of 1280 OPs per loop iteration, ILP = 10
  size_t n_iterations = N_ITERATIONS/10;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fdot za.s[w8, 0, VGx2], {z0.h-z1.h}, {z0.h-z1.h}          \n"
    "  fdot za.s[w8, 1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}          \n"
    "  fdot za.s[w8, 2, VGx2], {z2.h-z3.h}, {z2.h-z3.h}          \n"
    "  fdot za.s[w8, 3, VGx2], {z2.h-z3.h}, {z2.h-z3.h}          \n"
    "  fdot za.s[w8, 4, VGx2], {z4.h-z5.h}, {z4.h-z5.h}          \n"
    "  fdot za.s[w8, 5, VGx2], {z4.h-z5.h}, {z4.h-z5.h}          \n"
    "  fdot za.s[w8, 6, VGx2], {z6.h-z7.h}, {z6.h-z7.h}          \n"
    "  fdot za.s[w8, 7, VGx2], {z6.h-z7.h}, {z6.h-z7.h}          \n"
    "  fdot za.s[w9, 0, VGx2], {z8.h-z9.h}, {z8.h-z9.h}          \n"
    "  fdot za.s[w9, 1, VGx2], {z8.h-z9.h}, {z8.h-z9.h}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*10.0*(double)n_iterations;
}


static double fdot_za_f32_f16_vgx2_ilp11(const void*) {
  // FDOT (FP16 to FP32, 2-way, two vectors), Dot Product (floating-point)
  //
  // Each instruction: (64x f16, 64x f16) → 32x f32 (128 OPs)
  // Total of 1408 OPs per loop iteration, ILP = 11
  size_t n_iterations = N_ITERATIONS/11;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fdot za.s[w8, 0, VGx2], {z0.h-z1.h}, {z0.h-z1.h}          \n"
    "  fdot za.s[w8, 1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}          \n"
    "  fdot za.s[w8, 2, VGx2], {z2.h-z3.h}, {z2.h-z3.h}          \n"
    "  fdot za.s[w8, 3, VGx2], {z2.h-z3.h}, {z2.h-z3.h}          \n"
    "  fdot za.s[w8, 4, VGx2], {z4.h-z5.h}, {z4.h-z5.h}          \n"
    "  fdot za.s[w8, 5, VGx2], {z4.h-z5.h}, {z4.h-z5.h}          \n"
    "  fdot za.s[w8, 6, VGx2], {z6.h-z7.h}, {z6.h-z7.h}          \n"
    "  fdot za.s[w8, 7, VGx2], {z6.h-z7.h}, {z6.h-z7.h}          \n"
    "  fdot za.s[w9, 0, VGx2], {z8.h-z9.h}, {z8.h-z9.h}          \n"
    "  fdot za.s[w9, 1, VGx2], {z8.h-z9.h}, {z8.h-z9.h}          \n"
    "  fdot za.s[w9, 2, VGx2], {z10.h-z11.h}, {z10.h-z11.h}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*11.0*(double)n_iterations;
}


static double fdot_za_f32_f16_vgx2_ilp12(const void*) {
  // FDOT (FP16 to FP32, 2-way, two vectors), Dot Product (floating-point)
  //
  // Each instruction: (64x f16, 64x f16) → 32x f32 (128 OPs)
  // Total of 1536 OPs per loop iteration, ILP = 12
  size_t n_iterations = N_ITERATIONS/12;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fdot za.s[w8, 0, VGx2], {z0.h-z1.h}, {z0.h-z1.h}          \n"
    "  fdot za.s[w8, 1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}          \n"
    "  fdot za.s[w8, 2, VGx2], {z2.h-z3.h}, {z2.h-z3.h}          \n"
    "  fdot za.s[w8, 3, VGx2], {z2.h-z3.h}, {z2.h-z3.h}          \n"
    "  fdot za.s[w8, 4, VGx2], {z4.h-z5.h}, {z4.h-z5.h}          \n"
    "  fdot za.s[w8, 5, VGx2], {z4.h-z5.h}, {z4.h-z5.h}          \n"
    "  fdot za.s[w8, 6, VGx2], {z6.h-z7.h}, {z6.h-z7.h}          \n"
    "  fdot za.s[w8, 7, VGx2], {z6.h-z7.h}, {z6.h-z7.h}          \n"
    "  fdot za.s[w9, 0, VGx2], {z8.h-z9.h}, {z8.h-z9.h}          \n"
    "  fdot za.s[w9, 1, VGx2], {z8.h-z9.h}, {z8.h-z9.h}          \n"
    "  fdot za.s[w9, 2, VGx2], {z10.h-z11.h}, {z10.h-z11.h}      \n"
    "  fdot za.s[w9, 3, VGx2], {z10.h-z11.h}, {z10.h-z11.h}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*12.0*(double)n_iterations;
}


static double fdot_za_f32_f16_vgx2_ilp13(const void*) {
  // FDOT (FP16 to FP32, 2-way, two vectors), Dot Product (floating-point)
  //
  // Each instruction: (64x f16, 64x f16) → 32x f32 (128 OPs)
  // Total of 1664 OPs per loop iteration, ILP = 13
  size_t n_iterations = N_ITERATIONS/13;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fdot za.s[w8, 0, VGx2], {z0.h-z1.h}, {z0.h-z1.h}          \n"
    "  fdot za.s[w8, 1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}          \n"
    "  fdot za.s[w8, 2, VGx2], {z2.h-z3.h}, {z2.h-z3.h}          \n"
    "  fdot za.s[w8, 3, VGx2], {z2.h-z3.h}, {z2.h-z3.h}          \n"
    "  fdot za.s[w8, 4, VGx2], {z4.h-z5.h}, {z4.h-z5.h}          \n"
    "  fdot za.s[w8, 5, VGx2], {z4.h-z5.h}, {z4.h-z5.h}          \n"
    "  fdot za.s[w8, 6, VGx2], {z6.h-z7.h}, {z6.h-z7.h}          \n"
    "  fdot za.s[w8, 7, VGx2], {z6.h-z7.h}, {z6.h-z7.h}          \n"
    "  fdot za.s[w9, 0, VGx2], {z8.h-z9.h}, {z8.h-z9.h}          \n"
    "  fdot za.s[w9, 1, VGx2], {z8.h-z9.h}, {z8.h-z9.h}          \n"
    "  fdot za.s[w9, 2, VGx2], {z10.h-z11.h}, {z10.h-z11.h}      \n"
    "  fdot za.s[w9, 3, VGx2], {z10.h-z11.h}, {z10.h-z11.h}      \n"
    "  fdot za.s[w9, 4, VGx2], {z12.h-z13.h}, {z12.h-z13.h}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*13.0*(double)n_iterations;
}


static double fdot_za_f32_f16_vgx2_ilp14(const void*) {
  // FDOT (FP16 to FP32, 2-way, two vectors), Dot Product (floating-point)
  //
  // Each instruction: (64x f16, 64x f16) → 32x f32 (128 OPs)
  // Total of 1792 OPs per loop iteration, ILP = 14
  size_t n_iterations = N_ITERATIONS/14;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fdot za.s[w8, 0, VGx2], {z0.h-z1.h}, {z0.h-z1.h}          \n"
    "  fdot za.s[w8, 1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}          \n"
    "  fdot za.s[w8, 2, VGx2], {z2.h-z3.h}, {z2.h-z3.h}          \n"
    "  fdot za.s[w8, 3, VGx2], {z2.h-z3.h}, {z2.h-z3.h}          \n"
    "  fdot za.s[w8, 4, VGx2], {z4.h-z5.h}, {z4.h-z5.h}          \n"
    "  fdot za.s[w8, 5, VGx2], {z4.h-z5.h}, {z4.h-z5.h}          \n"
    "  fdot za.s[w8, 6, VGx2], {z6.h-z7.h}, {z6.h-z7.h}          \n"
    "  fdot za.s[w8, 7, VGx2], {z6.h-z7.h}, {z6.h-z7.h}          \n"
    "  fdot za.s[w9, 0, VGx2], {z8.h-z9.h}, {z8.h-z9.h}          \n"
    "  fdot za.s[w9, 1, VGx2], {z8.h-z9.h}, {z8.h-z9.h}          \n"
    "  fdot za.s[w9, 2, VGx2], {z10.h-z11.h}, {z10.h-z11.h}      \n"
    "  fdot za.s[w9, 3, VGx2], {z10.h-z11.h}, {z10.h-z11.h}      \n"
    "  fdot za.s[w9, 4, VGx2], {z12.h-z13.h}, {z12.h-z13.h}      \n"
    "  fdot za.s[w9, 5, VGx2], {z12.h-z13.h}, {z12.h-z13.h}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*14.0*(double)n_iterations;
}


static double fdot_za_f32_f16_vgx2_ilp15(const void*) {
  // FDOT (FP16 to FP32, 2-way, two vectors), Dot Product (floating-point)
  //
  // Each instruction: (64x f16, 64x f16) → 32x f32 (128 OPs)
  // Total of 1920 OPs per loop iteration, ILP = 15
  size_t n_iterations = N_ITERATIONS/15;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fdot za.s[w8, 0, VGx2], {z0.h-z1.h}, {z0.h-z1.h}          \n"
    "  fdot za.s[w8, 1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}          \n"
    "  fdot za.s[w8, 2, VGx2], {z2.h-z3.h}, {z2.h-z3.h}          \n"
    "  fdot za.s[w8, 3, VGx2], {z2.h-z3.h}, {z2.h-z3.h}          \n"
    "  fdot za.s[w8, 4, VGx2], {z4.h-z5.h}, {z4.h-z5.h}          \n"
    "  fdot za.s[w8, 5, VGx2], {z4.h-z5.h}, {z4.h-z5.h}          \n"
    "  fdot za.s[w8, 6, VGx2], {z6.h-z7.h}, {z6.h-z7.h}          \n"
    "  fdot za.s[w8, 7, VGx2], {z6.h-z7.h}, {z6.h-z7.h}          \n"
    "  fdot za.s[w9, 0, VGx2], {z8.h-z9.h}, {z8.h-z9.h}          \n"
    "  fdot za.s[w9, 1, VGx2], {z8.h-z9.h}, {z8.h-z9.h}          \n"
    "  fdot za.s[w9, 2, VGx2], {z10.h-z11.h}, {z10.h-z11.h}      \n"
    "  fdot za.s[w9, 3, VGx2], {z10.h-z11.h}, {z10.h-z11.h}      \n"
    "  fdot za.s[w9, 4, VGx2], {z12.h-z13.h}, {z12.h-z13.h}      \n"
    "  fdot za.s[w9, 5, VGx2], {z12.h-z13.h}, {z12.h-z13.h}      \n"
    "  fdot za.s[w9, 6, VGx2], {z14.h-z15.h}, {z14.h-z15.h}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*15.0*(double)n_iterations;
}


static double fdot_za_f32_f16_vgx2_ilp16(const void*) {
  // FDOT (FP16 to FP32, 2-way, two vectors), Dot Product (floating-point)
  //
  // Each instruction: (64x f16, 64x f16) → 32x f32 (128 OPs)
  // Total of 2048 OPs per loop iteration, ILP = 16
  size_t n_iterations = N_ITERATIONS/16;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fdot za.s[w8, 0, VGx2], {z0.h-z1.h}, {z0.h-z1.h}          \n"
    "  fdot za.s[w8, 1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}          \n"
    "  fdot za.s[w8, 2, VGx2], {z2.h-z3.h}, {z2.h-z3.h}          \n"
    "  fdot za.s[w8, 3, VGx2], {z2.h-z3.h}, {z2.h-z3.h}          \n"
    "  fdot za.s[w8, 4, VGx2], {z4.h-z5.h}, {z4.h-z5.h}          \n"
    "  fdot za.s[w8, 5, VGx2], {z4.h-z5.h}, {z4.h-z5.h}          \n"
    "  fdot za.s[w8, 6, VGx2], {z6.h-z7.h}, {z6.h-z7.h}          \n"
    "  fdot za.s[w8, 7, VGx2], {z6.h-z7.h}, {z6.h-z7.h}          \n"
    "  fdot za.s[w9, 0, VGx2], {z8.h-z9.h}, {z8.h-z9.h}          \n"
    "  fdot za.s[w9, 1, VGx2], {z8.h-z9.h}, {z8.h-z9.h}          \n"
    "  fdot za.s[w9, 2, VGx2], {z10.h-z11.h}, {z10.h-z11.h}      \n"
    "  fdot za.s[w9, 3, VGx2], {z10.h-z11.h}, {z10.h-z11.h}      \n"
    "  fdot za.s[w9, 4, VGx2], {z12.h-z13.h}, {z12.h-z13.h}      \n"
    "  fdot za.s[w9, 5, VGx2], {z12.h-z13.h}, {z12.h-z13.h}      \n"
    "  fdot za.s[w9, 6, VGx2], {z14.h-z15.h}, {z14.h-z15.h}      \n"
    "  fdot za.s[w9, 7, VGx2], {z14.h-z15.h}, {z14.h-z15.h}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*16.0*(double)n_iterations;
}


static double fdot_za_f32_f16_vgx4_ilp1(const void*) {
  // FDOT (FP16 to FP32, 2-way, four vectors), Dot Product (floating-point)
  //
  // Each instruction: (128x f16, 128x f16) → 64x f32 (256 OPs)
  // Total of 256 OPs per loop iteration, ILP = 1
  size_t n_iterations = N_ITERATIONS;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fdot za.s[w8, 0, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*1.0*(double)n_iterations;
}


static double fdot_za_f32_f16_vgx4_ilp2(const void*) {
  // FDOT (FP16 to FP32, 2-way, four vectors), Dot Product (floating-point)
  //
  // Each instruction: (128x f16, 128x f16) → 64x f32 (256 OPs)
  // Total of 512 OPs per loop iteration, ILP = 2
  size_t n_iterations = N_ITERATIONS/2;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fdot za.s[w8, 0, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  fdot za.s[w8, 1, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*2.0*(double)n_iterations;
}


static double fdot_za_f32_f16_vgx4_ilp3(const void*) {
  // FDOT (FP16 to FP32, 2-way, four vectors), Dot Product (floating-point)
  //
  // Each instruction: (128x f16, 128x f16) → 64x f32 (256 OPs)
  // Total of 768 OPs per loop iteration, ILP = 3
  size_t n_iterations = N_ITERATIONS/3;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fdot za.s[w8, 0, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  fdot za.s[w8, 1, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  fdot za.s[w8, 2, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*3.0*(double)n_iterations;
}


static double fdot_za_f32_f16_vgx4_ilp4(const void*) {
  // FDOT (FP16 to FP32, 2-way, four vectors), Dot Product (floating-point)
  //
  // Each instruction: (128x f16, 128x f16) → 64x f32 (256 OPs)
  // Total of 1024 OPs per loop iteration, ILP = 4
  size_t n_iterations = N_ITERATIONS/4;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fdot za.s[w8, 0, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  fdot za.s[w8, 1, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  fdot za.s[w8, 2, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  fdot za.s[w8, 3, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*4.0*(double)n_iterations;
}


static double fdot_za_f32_f16_vgx4_ilp5(const void*) {
  // FDOT (FP16 to FP32, 2-way, four vectors), Dot Product (floating-point)
  //
  // Each instruction: (128x f16, 128x f16) → 64x f32 (256 OPs)
  // Total of 1280 OPs per loop iteration, ILP = 5
  size_t n_iterations = N_ITERATIONS/5;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fdot za.s[w8, 0, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  fdot za.s[w8, 1, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  fdot za.s[w8, 2, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  fdot za.s[w8, 3, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  fdot za.s[w8, 4, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*5.0*(double)n_iterations;
}


static double fdot_za_f32_f16_vgx4_ilp6(const void*) {
  // FDOT (FP16 to FP32, 2-way, four vectors), Dot Product (floating-point)
  //
  // Each instruction: (128x f16, 128x f16) → 64x f32 (256 OPs)
  // Total of 1536 OPs per loop iteration, ILP = 6
  size_t n_iterations = N_ITERATIONS/6;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fdot za.s[w8, 0, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  fdot za.s[w8, 1, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  fdot za.s[w8, 2, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  fdot za.s[w8, 3, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  fdot za.s[w8, 4, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  fdot za.s[w8, 5, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*6.0*(double)n_iterations;
}


static double fdot_za_f32_f16_vgx4_ilp7(const void*) {
  // FDOT (FP16 to FP32, 2-way, four vectors), Dot Product (floating-point)
  //
  // Each instruction: (128x f16, 128x f16) → 64x f32 (256 OPs)
  // Total of 1792 OPs per loop iteration, ILP = 7
  size_t n_iterations = N_ITERATIONS/7;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fdot za.s[w8, 0, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  fdot za.s[w8, 1, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  fdot za.s[w8, 2, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  fdot za.s[w8, 3, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  fdot za.s[w8, 4, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  fdot za.s[w8, 5, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  fdot za.s[w8, 6, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*7.0*(double)n_iterations;
}


static double fdot_za_f32_f16_vgx4_ilp8(const void*) {
  // FDOT (FP16 to FP32, 2-way, four vectors), Dot Product (floating-point)
  //
  // Each instruction: (128x f16, 128x f16) → 64x f32 (256 OPs)
  // Total of 2048 OPs per loop iteration, ILP = 8
  size_t n_iterations = N_ITERATIONS/8;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fdot za.s[w8, 0, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  fdot za.s[w8, 1, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  fdot za.s[w8, 2, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  fdot za.s[w8, 3, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  fdot za.s[w8, 4, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  fdot za.s[w8, 5, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  fdot za.s[w8, 6, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  fdot za.s[w8, 7, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*8.0*(double)n_iterations;
}


static double fdot_za_f32_f16_vgx4_ilp9(const void*) {
  // FDOT (FP16 to FP32, 2-way, four vectors), Dot Product (floating-point)
  //
  // Each instruction: (128x f16, 128x f16) → 64x f32 (256 OPs)
  // Total of 2304 OPs per loop iteration, ILP = 9
  size_t n_iterations = N_ITERATIONS/9;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fdot za.s[w8, 0, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  fdot za.s[w8, 1, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  fdot za.s[w8, 2, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  fdot za.s[w8, 3, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  fdot za.s[w8, 4, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  fdot za.s[w8, 5, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  fdot za.s[w8, 6, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  fdot za.s[w8, 7, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  fdot za.s[w9, 0, VGx4], {z8.h-z11.h}, {z8.h-z11.h}        \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*9.0*(double)n_iterations;
}


static double fdot_za_f32_f16_vgx4_ilp10(const void*) {
  // FDOT (FP16 to FP32, 2-way, four vectors), Dot Product (floating-point)
  //
  // Each instruction: (128x f16, 128x f16) → 64x f32 (256 OPs)
  // Total of 2560 OPs per loop iteration, ILP = 10
  size_t n_iterations = N_ITERATIONS/10;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fdot za.s[w8, 0, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  fdot za.s[w8, 1, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  fdot za.s[w8, 2, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  fdot za.s[w8, 3, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  fdot za.s[w8, 4, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  fdot za.s[w8, 5, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  fdot za.s[w8, 6, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  fdot za.s[w8, 7, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  fdot za.s[w9, 0, VGx4], {z8.h-z11.h}, {z8.h-z11.h}        \n"
    "  fdot za.s[w9, 1, VGx4], {z8.h-z11.h}, {z8.h-z11.h}        \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*10.0*(double)n_iterations;
}


static double fdot_za_f32_f16_vgx4_ilp11(const void*) {
  // FDOT (FP16 to FP32, 2-way, four vectors), Dot Product (floating-point)
  //
  // Each instruction: (128x f16, 128x f16) → 64x f32 (256 OPs)
  // Total of 2816 OPs per loop iteration, ILP = 11
  size_t n_iterations = N_ITERATIONS/11;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fdot za.s[w8, 0, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  fdot za.s[w8, 1, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  fdot za.s[w8, 2, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  fdot za.s[w8, 3, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  fdot za.s[w8, 4, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  fdot za.s[w8, 5, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  fdot za.s[w8, 6, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  fdot za.s[w8, 7, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  fdot za.s[w9, 0, VGx4], {z8.h-z11.h}, {z8.h-z11.h}        \n"
    "  fdot za.s[w9, 1, VGx4], {z8.h-z11.h}, {z8.h-z11.h}        \n"
    "  fdot za.s[w9, 2, VGx4], {z8.h-z11.h}, {z8.h-z11.h}        \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*11.0*(double)n_iterations;
}


static double fdot_za_f32_f16_vgx4_ilp12(const void*) {
  // FDOT (FP16 to FP32, 2-way, four vectors), Dot Product (floating-point)
  //
  // Each instruction: (128x f16, 128x f16) → 64x f32 (256 OPs)
  // Total of 3072 OPs per loop iteration, ILP = 12
  size_t n_iterations = N_ITERATIONS/12;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fdot za.s[w8, 0, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  fdot za.s[w8, 1, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  fdot za.s[w8, 2, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  fdot za.s[w8, 3, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  fdot za.s[w8, 4, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  fdot za.s[w8, 5, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  fdot za.s[w8, 6, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  fdot za.s[w8, 7, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  fdot za.s[w9, 0, VGx4], {z8.h-z11.h}, {z8.h-z11.h}        \n"
    "  fdot za.s[w9, 1, VGx4], {z8.h-z11.h}, {z8.h-z11.h}        \n"
    "  fdot za.s[w9, 2, VGx4], {z8.h-z11.h}, {z8.h-z11.h}        \n"
    "  fdot za.s[w9, 3, VGx4], {z8.h-z11.h}, {z8.h-z11.h}        \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*12.0*(double)n_iterations;
}


static double fdot_za_f32_f16_vgx4_ilp13(const void*) {
  // FDOT (FP16 to FP32, 2-way, four vectors), Dot Product (floating-point)
  //
  // Each instruction: (128x f16, 128x f16) → 64x f32 (256 OPs)
  // Total of 3328 OPs per loop iteration, ILP = 13
  size_t n_iterations = N_ITERATIONS/13;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fdot za.s[w8, 0, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  fdot za.s[w8, 1, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  fdot za.s[w8, 2, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  fdot za.s[w8, 3, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  fdot za.s[w8, 4, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  fdot za.s[w8, 5, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  fdot za.s[w8, 6, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  fdot za.s[w8, 7, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  fdot za.s[w9, 0, VGx4], {z8.h-z11.h}, {z8.h-z11.h}        \n"
    "  fdot za.s[w9, 1, VGx4], {z8.h-z11.h}, {z8.h-z11.h}        \n"
    "  fdot za.s[w9, 2, VGx4], {z8.h-z11.h}, {z8.h-z11.h}        \n"
    "  fdot za.s[w9, 3, VGx4], {z8.h-z11.h}, {z8.h-z11.h}        \n"
    "  fdot za.s[w9, 4, VGx4], {z12.h-z15.h}, {z12.h-z15.h}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*13.0*(double)n_iterations;
}


static double fdot_za_f32_f16_vgx4_ilp14(const void*) {
  // FDOT (FP16 to FP32, 2-way, four vectors), Dot Product (floating-point)
  //
  // Each instruction: (128x f16, 128x f16) → 64x f32 (256 OPs)
  // Total of 3584 OPs per loop iteration, ILP = 14
  size_t n_iterations = N_ITERATIONS/14;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fdot za.s[w8, 0, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  fdot za.s[w8, 1, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  fdot za.s[w8, 2, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  fdot za.s[w8, 3, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  fdot za.s[w8, 4, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  fdot za.s[w8, 5, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  fdot za.s[w8, 6, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  fdot za.s[w8, 7, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  fdot za.s[w9, 0, VGx4], {z8.h-z11.h}, {z8.h-z11.h}        \n"
    "  fdot za.s[w9, 1, VGx4], {z8.h-z11.h}, {z8.h-z11.h}        \n"
    "  fdot za.s[w9, 2, VGx4], {z8.h-z11.h}, {z8.h-z11.h}        \n"
    "  fdot za.s[w9, 3, VGx4], {z8.h-z11.h}, {z8.h-z11.h}        \n"
    "  fdot za.s[w9, 4, VGx4], {z12.h-z15.h}, {z12.h-z15.h}      \n"
    "  fdot za.s[w9, 5, VGx4], {z12.h-z15.h}, {z12.h-z15.h}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*14.0*(double)n_iterations;
}


static double fdot_za_f32_f16_vgx4_ilp15(const void*) {
  // FDOT (FP16 to FP32, 2-way, four vectors), Dot Product (floating-point)
  //
  // Each instruction: (128x f16, 128x f16) → 64x f32 (256 OPs)
  // Total of 3840 OPs per loop iteration, ILP = 15
  size_t n_iterations = N_ITERATIONS/15;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fdot za.s[w8, 0, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  fdot za.s[w8, 1, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  fdot za.s[w8, 2, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  fdot za.s[w8, 3, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  fdot za.s[w8, 4, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  fdot za.s[w8, 5, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  fdot za.s[w8, 6, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  fdot za.s[w8, 7, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  fdot za.s[w9, 0, VGx4], {z8.h-z11.h}, {z8.h-z11.h}        \n"
    "  fdot za.s[w9, 1, VGx4], {z8.h-z11.h}, {z8.h-z11.h}        \n"
    "  fdot za.s[w9, 2, VGx4], {z8.h-z11.h}, {z8.h-z11.h}        \n"
    "  fdot za.s[w9, 3, VGx4], {z8.h-z11.h}, {z8.h-z11.h}        \n"
    "  fdot za.s[w9, 4, VGx4], {z12.h-z15.h}, {z12.h-z15.h}      \n"
    "  fdot za.s[w9, 5, VGx4], {z12.h-z15.h}, {z12.h-z15.h}      \n"
    "  fdot za.s[w9, 6, VGx4], {z12.h-z15.h}, {z12.h-z15.h}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*15.0*(double)n_iterations;
}


static double fdot_za_f32_f16_vgx4_ilp16(const void*) {
  // FDOT (FP16 to FP32, 2-way, four vectors), Dot Product (floating-point)
  //
  // Each instruction: (128x f16, 128x f16) → 64x f32 (256 OPs)
  // Total of 4096 OPs per loop iteration, ILP = 16
  size_t n_iterations = N_ITERATIONS/16;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fdot za.s[w8, 0, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  fdot za.s[w8, 1, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  fdot za.s[w8, 2, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  fdot za.s[w8, 3, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  fdot za.s[w8, 4, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  fdot za.s[w8, 5, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  fdot za.s[w8, 6, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  fdot za.s[w8, 7, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  fdot za.s[w9, 0, VGx4], {z8.h-z11.h}, {z8.h-z11.h}        \n"
    "  fdot za.s[w9, 1, VGx4], {z8.h-z11.h}, {z8.h-z11.h}        \n"
    "  fdot za.s[w9, 2, VGx4], {z8.h-z11.h}, {z8.h-z11.h}        \n"
    "  fdot za.s[w9, 3, VGx4], {z8.h-z11.h}, {z8.h-z11.h}        \n"
    "  fdot za.s[w9, 4, VGx4], {z12.h-z15.h}, {z12.h-z15.h}      \n"
    "  fdot za.s[w9, 5, VGx4], {z12.h-z15.h}, {z12.h-z15.h}      \n"
    "  fdot za.s[w9, 6, VGx4], {z12.h-z15.h}, {z12.h-z15.h}      \n"
    "  fdot za.s[w9, 7, VGx4], {z12.h-z15.h}, {z12.h-z15.h}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*16.0*(double)n_iterations;
}


static double bfdot_za_f32_b16_vgx2_ilp1(const void*) {
  // BFDOT (BF16 to FP32, 2-way, two vectors), Dot Product (floating-point)
  //
  // Each instruction: (64x b16, 64x b16) → 32x f32 (128 OPs)
  // Total of 128 OPs per loop iteration, ILP = 1
  size_t n_iterations = N_ITERATIONS;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  bfdot za.s[w8, 0, VGx2], {z0.h-z1.h}, {z0.h-z1.h}         \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*1.0*(double)n_iterations;
}


static double bfdot_za_f32_b16_vgx2_ilp2(const void*) {
  // BFDOT (BF16 to FP32, 2-way, two vectors), Dot Product (floating-point)
  //
  // Each instruction: (64x b16, 64x b16) → 32x f32 (128 OPs)
  // Total of 256 OPs per loop iteration, ILP = 2
  size_t n_iterations = N_ITERATIONS/2;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  bfdot za.s[w8, 0, VGx2], {z0.h-z1.h}, {z0.h-z1.h}         \n"
    "  bfdot za.s[w8, 1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}         \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*2.0*(double)n_iterations;
}


static double bfdot_za_f32_b16_vgx2_ilp3(const void*) {
  // BFDOT (BF16 to FP32, 2-way, two vectors), Dot Product (floating-point)
  //
  // Each instruction: (64x b16, 64x b16) → 32x f32 (128 OPs)
  // Total of 384 OPs per loop iteration, ILP = 3
  size_t n_iterations = N_ITERATIONS/3;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  bfdot za.s[w8, 0, VGx2], {z0.h-z1.h}, {z0.h-z1.h}         \n"
    "  bfdot za.s[w8, 1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}         \n"
    "  bfdot za.s[w8, 2, VGx2], {z2.h-z3.h}, {z2.h-z3.h}         \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*3.0*(double)n_iterations;
}


static double bfdot_za_f32_b16_vgx2_ilp4(const void*) {
  // BFDOT (BF16 to FP32, 2-way, two vectors), Dot Product (floating-point)
  //
  // Each instruction: (64x b16, 64x b16) → 32x f32 (128 OPs)
  // Total of 512 OPs per loop iteration, ILP = 4
  size_t n_iterations = N_ITERATIONS/4;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  bfdot za.s[w8, 0, VGx2], {z0.h-z1.h}, {z0.h-z1.h}         \n"
    "  bfdot za.s[w8, 1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}         \n"
    "  bfdot za.s[w8, 2, VGx2], {z2.h-z3.h}, {z2.h-z3.h}         \n"
    "  bfdot za.s[w8, 3, VGx2], {z2.h-z3.h}, {z2.h-z3.h}         \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*4.0*(double)n_iterations;
}


static double bfdot_za_f32_b16_vgx2_ilp5(const void*) {
  // BFDOT (BF16 to FP32, 2-way, two vectors), Dot Product (floating-point)
  //
  // Each instruction: (64x b16, 64x b16) → 32x f32 (128 OPs)
  // Total of 640 OPs per loop iteration, ILP = 5
  size_t n_iterations = N_ITERATIONS/5;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  bfdot za.s[w8, 0, VGx2], {z0.h-z1.h}, {z0.h-z1.h}         \n"
    "  bfdot za.s[w8, 1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}         \n"
    "  bfdot za.s[w8, 2, VGx2], {z2.h-z3.h}, {z2.h-z3.h}         \n"
    "  bfdot za.s[w8, 3, VGx2], {z2.h-z3.h}, {z2.h-z3.h}         \n"
    "  bfdot za.s[w8, 4, VGx2], {z4.h-z5.h}, {z4.h-z5.h}         \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*5.0*(double)n_iterations;
}


static double bfdot_za_f32_b16_vgx2_ilp6(const void*) {
  // BFDOT (BF16 to FP32, 2-way, two vectors), Dot Product (floating-point)
  //
  // Each instruction: (64x b16, 64x b16) → 32x f32 (128 OPs)
  // Total of 768 OPs per loop iteration, ILP = 6
  size_t n_iterations = N_ITERATIONS/6;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  bfdot za.s[w8, 0, VGx2], {z0.h-z1.h}, {z0.h-z1.h}         \n"
    "  bfdot za.s[w8, 1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}         \n"
    "  bfdot za.s[w8, 2, VGx2], {z2.h-z3.h}, {z2.h-z3.h}         \n"
    "  bfdot za.s[w8, 3, VGx2], {z2.h-z3.h}, {z2.h-z3.h}         \n"
    "  bfdot za.s[w8, 4, VGx2], {z4.h-z5.h}, {z4.h-z5.h}         \n"
    "  bfdot za.s[w8, 5, VGx2], {z4.h-z5.h}, {z4.h-z5.h}         \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*6.0*(double)n_iterations;
}


static double bfdot_za_f32_b16_vgx2_ilp7(const void*) {
  // BFDOT (BF16 to FP32, 2-way, two vectors), Dot Product (floating-point)
  //
  // Each instruction: (64x b16, 64x b16) → 32x f32 (128 OPs)
  // Total of 896 OPs per loop iteration, ILP = 7
  size_t n_iterations = N_ITERATIONS/7;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  bfdot za.s[w8, 0, VGx2], {z0.h-z1.h}, {z0.h-z1.h}         \n"
    "  bfdot za.s[w8, 1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}         \n"
    "  bfdot za.s[w8, 2, VGx2], {z2.h-z3.h}, {z2.h-z3.h}         \n"
    "  bfdot za.s[w8, 3, VGx2], {z2.h-z3.h}, {z2.h-z3.h}         \n"
    "  bfdot za.s[w8, 4, VGx2], {z4.h-z5.h}, {z4.h-z5.h}         \n"
    "  bfdot za.s[w8, 5, VGx2], {z4.h-z5.h}, {z4.h-z5.h}         \n"
    "  bfdot za.s[w8, 6, VGx2], {z6.h-z7.h}, {z6.h-z7.h}         \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*7.0*(double)n_iterations;
}


static double bfdot_za_f32_b16_vgx2_ilp8(const void*) {
  // BFDOT (BF16 to FP32, 2-way, two vectors), Dot Product (floating-point)
  //
  // Each instruction: (64x b16, 64x b16) → 32x f32 (128 OPs)
  // Total of 1024 OPs per loop iteration, ILP = 8
  size_t n_iterations = N_ITERATIONS/8;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  bfdot za.s[w8, 0, VGx2], {z0.h-z1.h}, {z0.h-z1.h}         \n"
    "  bfdot za.s[w8, 1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}         \n"
    "  bfdot za.s[w8, 2, VGx2], {z2.h-z3.h}, {z2.h-z3.h}         \n"
    "  bfdot za.s[w8, 3, VGx2], {z2.h-z3.h}, {z2.h-z3.h}         \n"
    "  bfdot za.s[w8, 4, VGx2], {z4.h-z5.h}, {z4.h-z5.h}         \n"
    "  bfdot za.s[w8, 5, VGx2], {z4.h-z5.h}, {z4.h-z5.h}         \n"
    "  bfdot za.s[w8, 6, VGx2], {z6.h-z7.h}, {z6.h-z7.h}         \n"
    "  bfdot za.s[w8, 7, VGx2], {z6.h-z7.h}, {z6.h-z7.h}         \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*8.0*(double)n_iterations;
}


static double bfdot_za_f32_b16_vgx2_ilp9(const void*) {
  // BFDOT (BF16 to FP32, 2-way, two vectors), Dot Product (floating-point)
  //
  // Each instruction: (64x b16, 64x b16) → 32x f32 (128 OPs)
  // Total of 1152 OPs per loop iteration, ILP = 9
  size_t n_iterations = N_ITERATIONS/9;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  bfdot za.s[w8, 0, VGx2], {z0.h-z1.h}, {z0.h-z1.h}         \n"
    "  bfdot za.s[w8, 1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}         \n"
    "  bfdot za.s[w8, 2, VGx2], {z2.h-z3.h}, {z2.h-z3.h}         \n"
    "  bfdot za.s[w8, 3, VGx2], {z2.h-z3.h}, {z2.h-z3.h}         \n"
    "  bfdot za.s[w8, 4, VGx2], {z4.h-z5.h}, {z4.h-z5.h}         \n"
    "  bfdot za.s[w8, 5, VGx2], {z4.h-z5.h}, {z4.h-z5.h}         \n"
    "  bfdot za.s[w8, 6, VGx2], {z6.h-z7.h}, {z6.h-z7.h}         \n"
    "  bfdot za.s[w8, 7, VGx2], {z6.h-z7.h}, {z6.h-z7.h}         \n"
    "  bfdot za.s[w9, 0, VGx2], {z8.h-z9.h}, {z8.h-z9.h}         \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*9.0*(double)n_iterations;
}


static double bfdot_za_f32_b16_vgx2_ilp10(const void*) {
  // BFDOT (BF16 to FP32, 2-way, two vectors), Dot Product (floating-point)
  //
  // Each instruction: (64x b16, 64x b16) → 32x f32 (128 OPs)
  // Total of 1280 OPs per loop iteration, ILP = 10
  size_t n_iterations = N_ITERATIONS/10;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  bfdot za.s[w8, 0, VGx2], {z0.h-z1.h}, {z0.h-z1.h}         \n"
    "  bfdot za.s[w8, 1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}         \n"
    "  bfdot za.s[w8, 2, VGx2], {z2.h-z3.h}, {z2.h-z3.h}         \n"
    "  bfdot za.s[w8, 3, VGx2], {z2.h-z3.h}, {z2.h-z3.h}         \n"
    "  bfdot za.s[w8, 4, VGx2], {z4.h-z5.h}, {z4.h-z5.h}         \n"
    "  bfdot za.s[w8, 5, VGx2], {z4.h-z5.h}, {z4.h-z5.h}         \n"
    "  bfdot za.s[w8, 6, VGx2], {z6.h-z7.h}, {z6.h-z7.h}         \n"
    "  bfdot za.s[w8, 7, VGx2], {z6.h-z7.h}, {z6.h-z7.h}         \n"
    "  bfdot za.s[w9, 0, VGx2], {z8.h-z9.h}, {z8.h-z9.h}         \n"
    "  bfdot za.s[w9, 1, VGx2], {z8.h-z9.h}, {z8.h-z9.h}         \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*10.0*(double)n_iterations;
}


static double bfdot_za_f32_b16_vgx2_ilp11(const void*) {
  // BFDOT (BF16 to FP32, 2-way, two vectors), Dot Product (floating-point)
  //
  // Each instruction: (64x b16, 64x b16) → 32x f32 (128 OPs)
  // Total of 1408 OPs per loop iteration, ILP = 11
  size_t n_iterations = N_ITERATIONS/11;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  bfdot za.s[w8, 0, VGx2], {z0.h-z1.h}, {z0.h-z1.h}         \n"
    "  bfdot za.s[w8, 1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}         \n"
    "  bfdot za.s[w8, 2, VGx2], {z2.h-z3.h}, {z2.h-z3.h}         \n"
    "  bfdot za.s[w8, 3, VGx2], {z2.h-z3.h}, {z2.h-z3.h}         \n"
    "  bfdot za.s[w8, 4, VGx2], {z4.h-z5.h}, {z4.h-z5.h}         \n"
    "  bfdot za.s[w8, 5, VGx2], {z4.h-z5.h}, {z4.h-z5.h}         \n"
    "  bfdot za.s[w8, 6, VGx2], {z6.h-z7.h}, {z6.h-z7.h}         \n"
    "  bfdot za.s[w8, 7, VGx2], {z6.h-z7.h}, {z6.h-z7.h}         \n"
    "  bfdot za.s[w9, 0, VGx2], {z8.h-z9.h}, {z8.h-z9.h}         \n"
    "  bfdot za.s[w9, 1, VGx2], {z8.h-z9.h}, {z8.h-z9.h}         \n"
    "  bfdot za.s[w9, 2, VGx2], {z10.h-z11.h}, {z10.h-z11.h}     \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*11.0*(double)n_iterations;
}


static double bfdot_za_f32_b16_vgx2_ilp12(const void*) {
  // BFDOT (BF16 to FP32, 2-way, two vectors), Dot Product (floating-point)
  //
  // Each instruction: (64x b16, 64x b16) → 32x f32 (128 OPs)
  // Total of 1536 OPs per loop iteration, ILP = 12
  size_t n_iterations = N_ITERATIONS/12;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  bfdot za.s[w8, 0, VGx2], {z0.h-z1.h}, {z0.h-z1.h}         \n"
    "  bfdot za.s[w8, 1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}         \n"
    "  bfdot za.s[w8, 2, VGx2], {z2.h-z3.h}, {z2.h-z3.h}         \n"
    "  bfdot za.s[w8, 3, VGx2], {z2.h-z3.h}, {z2.h-z3.h}         \n"
    "  bfdot za.s[w8, 4, VGx2], {z4.h-z5.h}, {z4.h-z5.h}         \n"
    "  bfdot za.s[w8, 5, VGx2], {z4.h-z5.h}, {z4.h-z5.h}         \n"
    "  bfdot za.s[w8, 6, VGx2], {z6.h-z7.h}, {z6.h-z7.h}         \n"
    "  bfdot za.s[w8, 7, VGx2], {z6.h-z7.h}, {z6.h-z7.h}         \n"
    "  bfdot za.s[w9, 0, VGx2], {z8.h-z9.h}, {z8.h-z9.h}         \n"
    "  bfdot za.s[w9, 1, VGx2], {z8.h-z9.h}, {z8.h-z9.h}         \n"
    "  bfdot za.s[w9, 2, VGx2], {z10.h-z11.h}, {z10.h-z11.h}     \n"
    "  bfdot za.s[w9, 3, VGx2], {z10.h-z11.h}, {z10.h-z11.h}     \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*12.0*(double)n_iterations;
}


static double bfdot_za_f32_b16_vgx2_ilp13(const void*) {
  // BFDOT (BF16 to FP32, 2-way, two vectors), Dot Product (floating-point)
  //
  // Each instruction: (64x b16, 64x b16) → 32x f32 (128 OPs)
  // Total of 1664 OPs per loop iteration, ILP = 13
  size_t n_iterations = N_ITERATIONS/13;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  bfdot za.s[w8, 0, VGx2], {z0.h-z1.h}, {z0.h-z1.h}         \n"
    "  bfdot za.s[w8, 1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}         \n"
    "  bfdot za.s[w8, 2, VGx2], {z2.h-z3.h}, {z2.h-z3.h}         \n"
    "  bfdot za.s[w8, 3, VGx2], {z2.h-z3.h}, {z2.h-z3.h}         \n"
    "  bfdot za.s[w8, 4, VGx2], {z4.h-z5.h}, {z4.h-z5.h}         \n"
    "  bfdot za.s[w8, 5, VGx2], {z4.h-z5.h}, {z4.h-z5.h}         \n"
    "  bfdot za.s[w8, 6, VGx2], {z6.h-z7.h}, {z6.h-z7.h}         \n"
    "  bfdot za.s[w8, 7, VGx2], {z6.h-z7.h}, {z6.h-z7.h}         \n"
    "  bfdot za.s[w9, 0, VGx2], {z8.h-z9.h}, {z8.h-z9.h}         \n"
    "  bfdot za.s[w9, 1, VGx2], {z8.h-z9.h}, {z8.h-z9.h}         \n"
    "  bfdot za.s[w9, 2, VGx2], {z10.h-z11.h}, {z10.h-z11.h}     \n"
    "  bfdot za.s[w9, 3, VGx2], {z10.h-z11.h}, {z10.h-z11.h}     \n"
    "  bfdot za.s[w9, 4, VGx2], {z12.h-z13.h}, {z12.h-z13.h}     \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*13.0*(double)n_iterations;
}


static double bfdot_za_f32_b16_vgx2_ilp14(const void*) {
  // BFDOT (BF16 to FP32, 2-way, two vectors), Dot Product (floating-point)
  //
  // Each instruction: (64x b16, 64x b16) → 32x f32 (128 OPs)
  // Total of 1792 OPs per loop iteration, ILP = 14
  size_t n_iterations = N_ITERATIONS/14;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  bfdot za.s[w8, 0, VGx2], {z0.h-z1.h}, {z0.h-z1.h}         \n"
    "  bfdot za.s[w8, 1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}         \n"
    "  bfdot za.s[w8, 2, VGx2], {z2.h-z3.h}, {z2.h-z3.h}         \n"
    "  bfdot za.s[w8, 3, VGx2], {z2.h-z3.h}, {z2.h-z3.h}         \n"
    "  bfdot za.s[w8, 4, VGx2], {z4.h-z5.h}, {z4.h-z5.h}         \n"
    "  bfdot za.s[w8, 5, VGx2], {z4.h-z5.h}, {z4.h-z5.h}         \n"
    "  bfdot za.s[w8, 6, VGx2], {z6.h-z7.h}, {z6.h-z7.h}         \n"
    "  bfdot za.s[w8, 7, VGx2], {z6.h-z7.h}, {z6.h-z7.h}         \n"
    "  bfdot za.s[w9, 0, VGx2], {z8.h-z9.h}, {z8.h-z9.h}         \n"
    "  bfdot za.s[w9, 1, VGx2], {z8.h-z9.h}, {z8.h-z9.h}         \n"
    "  bfdot za.s[w9, 2, VGx2], {z10.h-z11.h}, {z10.h-z11.h}     \n"
    "  bfdot za.s[w9, 3, VGx2], {z10.h-z11.h}, {z10.h-z11.h}     \n"
    "  bfdot za.s[w9, 4, VGx2], {z12.h-z13.h}, {z12.h-z13.h}     \n"
    "  bfdot za.s[w9, 5, VGx2], {z12.h-z13.h}, {z12.h-z13.h}     \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*14.0*(double)n_iterations;
}


static double bfdot_za_f32_b16_vgx2_ilp15(const void*) {
  // BFDOT (BF16 to FP32, 2-way, two vectors), Dot Product (floating-point)
  //
  // Each instruction: (64x b16, 64x b16) → 32x f32 (128 OPs)
  // Total of 1920 OPs per loop iteration, ILP = 15
  size_t n_iterations = N_ITERATIONS/15;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  bfdot za.s[w8, 0, VGx2], {z0.h-z1.h}, {z0.h-z1.h}         \n"
    "  bfdot za.s[w8, 1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}         \n"
    "  bfdot za.s[w8, 2, VGx2], {z2.h-z3.h}, {z2.h-z3.h}         \n"
    "  bfdot za.s[w8, 3, VGx2], {z2.h-z3.h}, {z2.h-z3.h}         \n"
    "  bfdot za.s[w8, 4, VGx2], {z4.h-z5.h}, {z4.h-z5.h}         \n"
    "  bfdot za.s[w8, 5, VGx2], {z4.h-z5.h}, {z4.h-z5.h}         \n"
    "  bfdot za.s[w8, 6, VGx2], {z6.h-z7.h}, {z6.h-z7.h}         \n"
    "  bfdot za.s[w8, 7, VGx2], {z6.h-z7.h}, {z6.h-z7.h}         \n"
    "  bfdot za.s[w9, 0, VGx2], {z8.h-z9.h}, {z8.h-z9.h}         \n"
    "  bfdot za.s[w9, 1, VGx2], {z8.h-z9.h}, {z8.h-z9.h}         \n"
    "  bfdot za.s[w9, 2, VGx2], {z10.h-z11.h}, {z10.h-z11.h}     \n"
    "  bfdot za.s[w9, 3, VGx2], {z10.h-z11.h}, {z10.h-z11.h}     \n"
    "  bfdot za.s[w9, 4, VGx2], {z12.h-z13.h}, {z12.h-z13.h}     \n"
    "  bfdot za.s[w9, 5, VGx2], {z12.h-z13.h}, {z12.h-z13.h}     \n"
    "  bfdot za.s[w9, 6, VGx2], {z14.h-z15.h}, {z14.h-z15.h}     \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*15.0*(double)n_iterations;
}


static double bfdot_za_f32_b16_vgx2_ilp16(const void*) {
  // BFDOT (BF16 to FP32, 2-way, two vectors), Dot Product (floating-point)
  //
  // Each instruction: (64x b16, 64x b16) → 32x f32 (128 OPs)
  // Total of 2048 OPs per loop iteration, ILP = 16
  size_t n_iterations = N_ITERATIONS/16;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  bfdot za.s[w8, 0, VGx2], {z0.h-z1.h}, {z0.h-z1.h}         \n"
    "  bfdot za.s[w8, 1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}         \n"
    "  bfdot za.s[w8, 2, VGx2], {z2.h-z3.h}, {z2.h-z3.h}         \n"
    "  bfdot za.s[w8, 3, VGx2], {z2.h-z3.h}, {z2.h-z3.h}         \n"
    "  bfdot za.s[w8, 4, VGx2], {z4.h-z5.h}, {z4.h-z5.h}         \n"
    "  bfdot za.s[w8, 5, VGx2], {z4.h-z5.h}, {z4.h-z5.h}         \n"
    "  bfdot za.s[w8, 6, VGx2], {z6.h-z7.h}, {z6.h-z7.h}         \n"
    "  bfdot za.s[w8, 7, VGx2], {z6.h-z7.h}, {z6.h-z7.h}         \n"
    "  bfdot za.s[w9, 0, VGx2], {z8.h-z9.h}, {z8.h-z9.h}         \n"
    "  bfdot za.s[w9, 1, VGx2], {z8.h-z9.h}, {z8.h-z9.h}         \n"
    "  bfdot za.s[w9, 2, VGx2], {z10.h-z11.h}, {z10.h-z11.h}     \n"
    "  bfdot za.s[w9, 3, VGx2], {z10.h-z11.h}, {z10.h-z11.h}     \n"
    "  bfdot za.s[w9, 4, VGx2], {z12.h-z13.h}, {z12.h-z13.h}     \n"
    "  bfdot za.s[w9, 5, VGx2], {z12.h-z13.h}, {z12.h-z13.h}     \n"
    "  bfdot za.s[w9, 6, VGx2], {z14.h-z15.h}, {z14.h-z15.h}     \n"
    "  bfdot za.s[w9, 7, VGx2], {z14.h-z15.h}, {z14.h-z15.h}     \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*16.0*(double)n_iterations;
}


static double bfdot_za_f32_b16_vgx4_ilp1(const void*) {
  // BFDOT (BF16 to FP32, 2-way, two vectors), Dot Product (floating-point)
  //
  // Each instruction: (128x b16, 128x b16) → 64x f32 (256 OPs)
  // Total of 256 OPs per loop iteration, ILP = 1
  size_t n_iterations = N_ITERATIONS;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  bfdot za.s[w8, 0, VGx4], {z0.h-z3.h}, {z0.h-z3.h}         \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*1.0*(double)n_iterations;
}


static double bfdot_za_f32_b16_vgx4_ilp2(const void*) {
  // BFDOT (BF16 to FP32, 2-way, two vectors), Dot Product (floating-point)
  //
  // Each instruction: (128x b16, 128x b16) → 64x f32 (256 OPs)
  // Total of 512 OPs per loop iteration, ILP = 2
  size_t n_iterations = N_ITERATIONS/2;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  bfdot za.s[w8, 0, VGx4], {z0.h-z3.h}, {z0.h-z3.h}         \n"
    "  bfdot za.s[w8, 1, VGx4], {z0.h-z3.h}, {z0.h-z3.h}         \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*2.0*(double)n_iterations;
}


static double bfdot_za_f32_b16_vgx4_ilp3(const void*) {
  // BFDOT (BF16 to FP32, 2-way, two vectors), Dot Product (floating-point)
  //
  // Each instruction: (128x b16, 128x b16) → 64x f32 (256 OPs)
  // Total of 768 OPs per loop iteration, ILP = 3
  size_t n_iterations = N_ITERATIONS/3;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  bfdot za.s[w8, 0, VGx4], {z0.h-z3.h}, {z0.h-z3.h}         \n"
    "  bfdot za.s[w8, 1, VGx4], {z0.h-z3.h}, {z0.h-z3.h}         \n"
    "  bfdot za.s[w8, 2, VGx4], {z0.h-z3.h}, {z0.h-z3.h}         \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*3.0*(double)n_iterations;
}


static double bfdot_za_f32_b16_vgx4_ilp4(const void*) {
  // BFDOT (BF16 to FP32, 2-way, two vectors), Dot Product (floating-point)
  //
  // Each instruction: (128x b16, 128x b16) → 64x f32 (256 OPs)
  // Total of 1024 OPs per loop iteration, ILP = 4
  size_t n_iterations = N_ITERATIONS/4;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  bfdot za.s[w8, 0, VGx4], {z0.h-z3.h}, {z0.h-z3.h}         \n"
    "  bfdot za.s[w8, 1, VGx4], {z0.h-z3.h}, {z0.h-z3.h}         \n"
    "  bfdot za.s[w8, 2, VGx4], {z0.h-z3.h}, {z0.h-z3.h}         \n"
    "  bfdot za.s[w8, 3, VGx4], {z0.h-z3.h}, {z0.h-z3.h}         \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*4.0*(double)n_iterations;
}


static double bfdot_za_f32_b16_vgx4_ilp5(const void*) {
  // BFDOT (BF16 to FP32, 2-way, two vectors), Dot Product (floating-point)
  //
  // Each instruction: (128x b16, 128x b16) → 64x f32 (256 OPs)
  // Total of 1280 OPs per loop iteration, ILP = 5
  size_t n_iterations = N_ITERATIONS/5;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  bfdot za.s[w8, 0, VGx4], {z0.h-z3.h}, {z0.h-z3.h}         \n"
    "  bfdot za.s[w8, 1, VGx4], {z0.h-z3.h}, {z0.h-z3.h}         \n"
    "  bfdot za.s[w8, 2, VGx4], {z0.h-z3.h}, {z0.h-z3.h}         \n"
    "  bfdot za.s[w8, 3, VGx4], {z0.h-z3.h}, {z0.h-z3.h}         \n"
    "  bfdot za.s[w8, 4, VGx4], {z4.h-z7.h}, {z4.h-z7.h}         \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*5.0*(double)n_iterations;
}


static double bfdot_za_f32_b16_vgx4_ilp6(const void*) {
  // BFDOT (BF16 to FP32, 2-way, two vectors), Dot Product (floating-point)
  //
  // Each instruction: (128x b16, 128x b16) → 64x f32 (256 OPs)
  // Total of 1536 OPs per loop iteration, ILP = 6
  size_t n_iterations = N_ITERATIONS/6;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  bfdot za.s[w8, 0, VGx4], {z0.h-z3.h}, {z0.h-z3.h}         \n"
    "  bfdot za.s[w8, 1, VGx4], {z0.h-z3.h}, {z0.h-z3.h}         \n"
    "  bfdot za.s[w8, 2, VGx4], {z0.h-z3.h}, {z0.h-z3.h}         \n"
    "  bfdot za.s[w8, 3, VGx4], {z0.h-z3.h}, {z0.h-z3.h}         \n"
    "  bfdot za.s[w8, 4, VGx4], {z4.h-z7.h}, {z4.h-z7.h}         \n"
    "  bfdot za.s[w8, 5, VGx4], {z4.h-z7.h}, {z4.h-z7.h}         \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*6.0*(double)n_iterations;
}


static double bfdot_za_f32_b16_vgx4_ilp7(const void*) {
  // BFDOT (BF16 to FP32, 2-way, two vectors), Dot Product (floating-point)
  //
  // Each instruction: (128x b16, 128x b16) → 64x f32 (256 OPs)
  // Total of 1792 OPs per loop iteration, ILP = 7
  size_t n_iterations = N_ITERATIONS/7;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  bfdot za.s[w8, 0, VGx4], {z0.h-z3.h}, {z0.h-z3.h}         \n"
    "  bfdot za.s[w8, 1, VGx4], {z0.h-z3.h}, {z0.h-z3.h}         \n"
    "  bfdot za.s[w8, 2, VGx4], {z0.h-z3.h}, {z0.h-z3.h}         \n"
    "  bfdot za.s[w8, 3, VGx4], {z0.h-z3.h}, {z0.h-z3.h}         \n"
    "  bfdot za.s[w8, 4, VGx4], {z4.h-z7.h}, {z4.h-z7.h}         \n"
    "  bfdot za.s[w8, 5, VGx4], {z4.h-z7.h}, {z4.h-z7.h}         \n"
    "  bfdot za.s[w8, 6, VGx4], {z4.h-z7.h}, {z4.h-z7.h}         \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*7.0*(double)n_iterations;
}


static double bfdot_za_f32_b16_vgx4_ilp8(const void*) {
  // BFDOT (BF16 to FP32, 2-way, two vectors), Dot Product (floating-point)
  //
  // Each instruction: (128x b16, 128x b16) → 64x f32 (256 OPs)
  // Total of 2048 OPs per loop iteration, ILP = 8
  size_t n_iterations = N_ITERATIONS/8;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  bfdot za.s[w8, 0, VGx4], {z0.h-z3.h}, {z0.h-z3.h}         \n"
    "  bfdot za.s[w8, 1, VGx4], {z0.h-z3.h}, {z0.h-z3.h}         \n"
    "  bfdot za.s[w8, 2, VGx4], {z0.h-z3.h}, {z0.h-z3.h}         \n"
    "  bfdot za.s[w8, 3, VGx4], {z0.h-z3.h}, {z0.h-z3.h}         \n"
    "  bfdot za.s[w8, 4, VGx4], {z4.h-z7.h}, {z4.h-z7.h}         \n"
    "  bfdot za.s[w8, 5, VGx4], {z4.h-z7.h}, {z4.h-z7.h}         \n"
    "  bfdot za.s[w8, 6, VGx4], {z4.h-z7.h}, {z4.h-z7.h}         \n"
    "  bfdot za.s[w8, 7, VGx4], {z4.h-z7.h}, {z4.h-z7.h}         \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*8.0*(double)n_iterations;
}


static double bfdot_za_f32_b16_vgx4_ilp9(const void*) {
  // BFDOT (BF16 to FP32, 2-way, two vectors), Dot Product (floating-point)
  //
  // Each instruction: (128x b16, 128x b16) → 64x f32 (256 OPs)
  // Total of 2304 OPs per loop iteration, ILP = 9
  size_t n_iterations = N_ITERATIONS/9;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  bfdot za.s[w8, 0, VGx4], {z0.h-z3.h}, {z0.h-z3.h}         \n"
    "  bfdot za.s[w8, 1, VGx4], {z0.h-z3.h}, {z0.h-z3.h}         \n"
    "  bfdot za.s[w8, 2, VGx4], {z0.h-z3.h}, {z0.h-z3.h}         \n"
    "  bfdot za.s[w8, 3, VGx4], {z0.h-z3.h}, {z0.h-z3.h}         \n"
    "  bfdot za.s[w8, 4, VGx4], {z4.h-z7.h}, {z4.h-z7.h}         \n"
    "  bfdot za.s[w8, 5, VGx4], {z4.h-z7.h}, {z4.h-z7.h}         \n"
    "  bfdot za.s[w8, 6, VGx4], {z4.h-z7.h}, {z4.h-z7.h}         \n"
    "  bfdot za.s[w8, 7, VGx4], {z4.h-z7.h}, {z4.h-z7.h}         \n"
    "  bfdot za.s[w9, 0, VGx4], {z8.h-z11.h}, {z8.h-z11.h}       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*9.0*(double)n_iterations;
}


static double bfdot_za_f32_b16_vgx4_ilp10(const void*) {
  // BFDOT (BF16 to FP32, 2-way, two vectors), Dot Product (floating-point)
  //
  // Each instruction: (128x b16, 128x b16) → 64x f32 (256 OPs)
  // Total of 2560 OPs per loop iteration, ILP = 10
  size_t n_iterations = N_ITERATIONS/10;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  bfdot za.s[w8, 0, VGx4], {z0.h-z3.h}, {z0.h-z3.h}         \n"
    "  bfdot za.s[w8, 1, VGx4], {z0.h-z3.h}, {z0.h-z3.h}         \n"
    "  bfdot za.s[w8, 2, VGx4], {z0.h-z3.h}, {z0.h-z3.h}         \n"
    "  bfdot za.s[w8, 3, VGx4], {z0.h-z3.h}, {z0.h-z3.h}         \n"
    "  bfdot za.s[w8, 4, VGx4], {z4.h-z7.h}, {z4.h-z7.h}         \n"
    "  bfdot za.s[w8, 5, VGx4], {z4.h-z7.h}, {z4.h-z7.h}         \n"
    "  bfdot za.s[w8, 6, VGx4], {z4.h-z7.h}, {z4.h-z7.h}         \n"
    "  bfdot za.s[w8, 7, VGx4], {z4.h-z7.h}, {z4.h-z7.h}         \n"
    "  bfdot za.s[w9, 0, VGx4], {z8.h-z11.h}, {z8.h-z11.h}       \n"
    "  bfdot za.s[w9, 1, VGx4], {z8.h-z11.h}, {z8.h-z11.h}       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*10.0*(double)n_iterations;
}


static double bfdot_za_f32_b16_vgx4_ilp11(const void*) {
  // BFDOT (BF16 to FP32, 2-way, two vectors), Dot Product (floating-point)
  //
  // Each instruction: (128x b16, 128x b16) → 64x f32 (256 OPs)
  // Total of 2816 OPs per loop iteration, ILP = 11
  size_t n_iterations = N_ITERATIONS/11;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  bfdot za.s[w8, 0, VGx4], {z0.h-z3.h}, {z0.h-z3.h}         \n"
    "  bfdot za.s[w8, 1, VGx4], {z0.h-z3.h}, {z0.h-z3.h}         \n"
    "  bfdot za.s[w8, 2, VGx4], {z0.h-z3.h}, {z0.h-z3.h}         \n"
    "  bfdot za.s[w8, 3, VGx4], {z0.h-z3.h}, {z0.h-z3.h}         \n"
    "  bfdot za.s[w8, 4, VGx4], {z4.h-z7.h}, {z4.h-z7.h}         \n"
    "  bfdot za.s[w8, 5, VGx4], {z4.h-z7.h}, {z4.h-z7.h}         \n"
    "  bfdot za.s[w8, 6, VGx4], {z4.h-z7.h}, {z4.h-z7.h}         \n"
    "  bfdot za.s[w8, 7, VGx4], {z4.h-z7.h}, {z4.h-z7.h}         \n"
    "  bfdot za.s[w9, 0, VGx4], {z8.h-z11.h}, {z8.h-z11.h}       \n"
    "  bfdot za.s[w9, 1, VGx4], {z8.h-z11.h}, {z8.h-z11.h}       \n"
    "  bfdot za.s[w9, 2, VGx4], {z8.h-z11.h}, {z8.h-z11.h}       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*11.0*(double)n_iterations;
}


static double bfdot_za_f32_b16_vgx4_ilp12(const void*) {
  // BFDOT (BF16 to FP32, 2-way, two vectors), Dot Product (floating-point)
  //
  // Each instruction: (128x b16, 128x b16) → 64x f32 (256 OPs)
  // Total of 3072 OPs per loop iteration, ILP = 12
  size_t n_iterations = N_ITERATIONS/12;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  bfdot za.s[w8, 0, VGx4], {z0.h-z3.h}, {z0.h-z3.h}         \n"
    "  bfdot za.s[w8, 1, VGx4], {z0.h-z3.h}, {z0.h-z3.h}         \n"
    "  bfdot za.s[w8, 2, VGx4], {z0.h-z3.h}, {z0.h-z3.h}         \n"
    "  bfdot za.s[w8, 3, VGx4], {z0.h-z3.h}, {z0.h-z3.h}         \n"
    "  bfdot za.s[w8, 4, VGx4], {z4.h-z7.h}, {z4.h-z7.h}         \n"
    "  bfdot za.s[w8, 5, VGx4], {z4.h-z7.h}, {z4.h-z7.h}         \n"
    "  bfdot za.s[w8, 6, VGx4], {z4.h-z7.h}, {z4.h-z7.h}         \n"
    "  bfdot za.s[w8, 7, VGx4], {z4.h-z7.h}, {z4.h-z7.h}         \n"
    "  bfdot za.s[w9, 0, VGx4], {z8.h-z11.h}, {z8.h-z11.h}       \n"
    "  bfdot za.s[w9, 1, VGx4], {z8.h-z11.h}, {z8.h-z11.h}       \n"
    "  bfdot za.s[w9, 2, VGx4], {z8.h-z11.h}, {z8.h-z11.h}       \n"
    "  bfdot za.s[w9, 3, VGx4], {z8.h-z11.h}, {z8.h-z11.h}       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*12.0*(double)n_iterations;
}


static double bfdot_za_f32_b16_vgx4_ilp13(const void*) {
  // BFDOT (BF16 to FP32, 2-way, two vectors), Dot Product (floating-point)
  //
  // Each instruction: (128x b16, 128x b16) → 64x f32 (256 OPs)
  // Total of 3328 OPs per loop iteration, ILP = 13
  size_t n_iterations = N_ITERATIONS/13;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  bfdot za.s[w8, 0, VGx4], {z0.h-z3.h}, {z0.h-z3.h}         \n"
    "  bfdot za.s[w8, 1, VGx4], {z0.h-z3.h}, {z0.h-z3.h}         \n"
    "  bfdot za.s[w8, 2, VGx4], {z0.h-z3.h}, {z0.h-z3.h}         \n"
    "  bfdot za.s[w8, 3, VGx4], {z0.h-z3.h}, {z0.h-z3.h}         \n"
    "  bfdot za.s[w8, 4, VGx4], {z4.h-z7.h}, {z4.h-z7.h}         \n"
    "  bfdot za.s[w8, 5, VGx4], {z4.h-z7.h}, {z4.h-z7.h}         \n"
    "  bfdot za.s[w8, 6, VGx4], {z4.h-z7.h}, {z4.h-z7.h}         \n"
    "  bfdot za.s[w8, 7, VGx4], {z4.h-z7.h}, {z4.h-z7.h}         \n"
    "  bfdot za.s[w9, 0, VGx4], {z8.h-z11.h}, {z8.h-z11.h}       \n"
    "  bfdot za.s[w9, 1, VGx4], {z8.h-z11.h}, {z8.h-z11.h}       \n"
    "  bfdot za.s[w9, 2, VGx4], {z8.h-z11.h}, {z8.h-z11.h}       \n"
    "  bfdot za.s[w9, 3, VGx4], {z8.h-z11.h}, {z8.h-z11.h}       \n"
    "  bfdot za.s[w9, 4, VGx4], {z12.h-z15.h}, {z12.h-z15.h}     \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*13.0*(double)n_iterations;
}


static double bfdot_za_f32_b16_vgx4_ilp14(const void*) {
  // BFDOT (BF16 to FP32, 2-way, two vectors), Dot Product (floating-point)
  //
  // Each instruction: (128x b16, 128x b16) → 64x f32 (256 OPs)
  // Total of 3584 OPs per loop iteration, ILP = 14
  size_t n_iterations = N_ITERATIONS/14;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  bfdot za.s[w8, 0, VGx4], {z0.h-z3.h}, {z0.h-z3.h}         \n"
    "  bfdot za.s[w8, 1, VGx4], {z0.h-z3.h}, {z0.h-z3.h}         \n"
    "  bfdot za.s[w8, 2, VGx4], {z0.h-z3.h}, {z0.h-z3.h}         \n"
    "  bfdot za.s[w8, 3, VGx4], {z0.h-z3.h}, {z0.h-z3.h}         \n"
    "  bfdot za.s[w8, 4, VGx4], {z4.h-z7.h}, {z4.h-z7.h}         \n"
    "  bfdot za.s[w8, 5, VGx4], {z4.h-z7.h}, {z4.h-z7.h}         \n"
    "  bfdot za.s[w8, 6, VGx4], {z4.h-z7.h}, {z4.h-z7.h}         \n"
    "  bfdot za.s[w8, 7, VGx4], {z4.h-z7.h}, {z4.h-z7.h}         \n"
    "  bfdot za.s[w9, 0, VGx4], {z8.h-z11.h}, {z8.h-z11.h}       \n"
    "  bfdot za.s[w9, 1, VGx4], {z8.h-z11.h}, {z8.h-z11.h}       \n"
    "  bfdot za.s[w9, 2, VGx4], {z8.h-z11.h}, {z8.h-z11.h}       \n"
    "  bfdot za.s[w9, 3, VGx4], {z8.h-z11.h}, {z8.h-z11.h}       \n"
    "  bfdot za.s[w9, 4, VGx4], {z12.h-z15.h}, {z12.h-z15.h}     \n"
    "  bfdot za.s[w9, 5, VGx4], {z12.h-z15.h}, {z12.h-z15.h}     \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*14.0*(double)n_iterations;
}


static double bfdot_za_f32_b16_vgx4_ilp15(const void*) {
  // BFDOT (BF16 to FP32, 2-way, two vectors), Dot Product (floating-point)
  //
  // Each instruction: (128x b16, 128x b16) → 64x f32 (256 OPs)
  // Total of 3840 OPs per loop iteration, ILP = 15
  size_t n_iterations = N_ITERATIONS/15;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  bfdot za.s[w8, 0, VGx4], {z0.h-z3.h}, {z0.h-z3.h}         \n"
    "  bfdot za.s[w8, 1, VGx4], {z0.h-z3.h}, {z0.h-z3.h}         \n"
    "  bfdot za.s[w8, 2, VGx4], {z0.h-z3.h}, {z0.h-z3.h}         \n"
    "  bfdot za.s[w8, 3, VGx4], {z0.h-z3.h}, {z0.h-z3.h}         \n"
    "  bfdot za.s[w8, 4, VGx4], {z4.h-z7.h}, {z4.h-z7.h}         \n"
    "  bfdot za.s[w8, 5, VGx4], {z4.h-z7.h}, {z4.h-z7.h}         \n"
    "  bfdot za.s[w8, 6, VGx4], {z4.h-z7.h}, {z4.h-z7.h}         \n"
    "  bfdot za.s[w8, 7, VGx4], {z4.h-z7.h}, {z4.h-z7.h}         \n"
    "  bfdot za.s[w9, 0, VGx4], {z8.h-z11.h}, {z8.h-z11.h}       \n"
    "  bfdot za.s[w9, 1, VGx4], {z8.h-z11.h}, {z8.h-z11.h}       \n"
    "  bfdot za.s[w9, 2, VGx4], {z8.h-z11.h}, {z8.h-z11.h}       \n"
    "  bfdot za.s[w9, 3, VGx4], {z8.h-z11.h}, {z8.h-z11.h}       \n"
    "  bfdot za.s[w9, 4, VGx4], {z12.h-z15.h}, {z12.h-z15.h}     \n"
    "  bfdot za.s[w9, 5, VGx4], {z12.h-z15.h}, {z12.h-z15.h}     \n"
    "  bfdot za.s[w9, 6, VGx4], {z12.h-z15.h}, {z12.h-z15.h}     \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*15.0*(double)n_iterations;
}


static double bfdot_za_f32_b16_vgx4_ilp16(const void*) {
  // BFDOT (BF16 to FP32, 2-way, two vectors), Dot Product (floating-point)
  //
  // Each instruction: (128x b16, 128x b16) → 64x f32 (256 OPs)
  // Total of 4096 OPs per loop iteration, ILP = 16
  size_t n_iterations = N_ITERATIONS/16;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  bfdot za.s[w8, 0, VGx4], {z0.h-z3.h}, {z0.h-z3.h}         \n"
    "  bfdot za.s[w8, 1, VGx4], {z0.h-z3.h}, {z0.h-z3.h}         \n"
    "  bfdot za.s[w8, 2, VGx4], {z0.h-z3.h}, {z0.h-z3.h}         \n"
    "  bfdot za.s[w8, 3, VGx4], {z0.h-z3.h}, {z0.h-z3.h}         \n"
    "  bfdot za.s[w8, 4, VGx4], {z4.h-z7.h}, {z4.h-z7.h}         \n"
    "  bfdot za.s[w8, 5, VGx4], {z4.h-z7.h}, {z4.h-z7.h}         \n"
    "  bfdot za.s[w8, 6, VGx4], {z4.h-z7.h}, {z4.h-z7.h}         \n"
    "  bfdot za.s[w8, 7, VGx4], {z4.h-z7.h}, {z4.h-z7.h}         \n"
    "  bfdot za.s[w9, 0, VGx4], {z8.h-z11.h}, {z8.h-z11.h}       \n"
    "  bfdot za.s[w9, 1, VGx4], {z8.h-z11.h}, {z8.h-z11.h}       \n"
    "  bfdot za.s[w9, 2, VGx4], {z8.h-z11.h}, {z8.h-z11.h}       \n"
    "  bfdot za.s[w9, 3, VGx4], {z8.h-z11.h}, {z8.h-z11.h}       \n"
    "  bfdot za.s[w9, 4, VGx4], {z12.h-z15.h}, {z12.h-z15.h}     \n"
    "  bfdot za.s[w9, 5, VGx4], {z12.h-z15.h}, {z12.h-z15.h}     \n"
    "  bfdot za.s[w9, 6, VGx4], {z12.h-z15.h}, {z12.h-z15.h}     \n"
    "  bfdot za.s[w9, 7, VGx4], {z12.h-z15.h}, {z12.h-z15.h}     \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*16.0*(double)n_iterations;
}


static double sdot_i32_i16_ilp1(const void*) {
  // SDOT (I16 to I32, 2-way, one vector), Dot Product (integer)
  //
  // Each instruction: (32x i16, 32x i16) → 16x i32 (64 OPs)
  // Total of 64 OPs per loop iteration, ILP = 1
  size_t n_iterations = N_ITERATIONS;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  sdot z0.s, z0.h, z0.h                                     \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*1.0*(double)n_iterations;
}


static double sdot_i32_i16_ilp2(const void*) {
  // SDOT (I16 to I32, 2-way, one vector), Dot Product (integer)
  //
  // Each instruction: (32x i16, 32x i16) → 16x i32 (64 OPs)
  // Total of 128 OPs per loop iteration, ILP = 2
  size_t n_iterations = N_ITERATIONS/2;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  sdot z0.s, z0.h, z0.h                                     \n"
    "  sdot z1.s, z1.h, z1.h                                     \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*2.0*(double)n_iterations;
}


static double sdot_i32_i16_ilp3(const void*) {
  // SDOT (I16 to I32, 2-way, one vector), Dot Product (integer)
  //
  // Each instruction: (32x i16, 32x i16) → 16x i32 (64 OPs)
  // Total of 192 OPs per loop iteration, ILP = 3
  size_t n_iterations = N_ITERATIONS/3;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  sdot z0.s, z0.h, z0.h                                     \n"
    "  sdot z1.s, z1.h, z1.h                                     \n"
    "  sdot z2.s, z2.h, z2.h                                     \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*3.0*(double)n_iterations;
}


static double sdot_i32_i16_ilp4(const void*) {
  // SDOT (I16 to I32, 2-way, one vector), Dot Product (integer)
  //
  // Each instruction: (32x i16, 32x i16) → 16x i32 (64 OPs)
  // Total of 256 OPs per loop iteration, ILP = 4
  size_t n_iterations = N_ITERATIONS/4;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  sdot z0.s, z0.h, z0.h                                     \n"
    "  sdot z1.s, z1.h, z1.h                                     \n"
    "  sdot z2.s, z2.h, z2.h                                     \n"
    "  sdot z3.s, z3.h, z3.h                                     \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*4.0*(double)n_iterations;
}


static double sdot_i32_i16_ilp5(const void*) {
  // SDOT (I16 to I32, 2-way, one vector), Dot Product (integer)
  //
  // Each instruction: (32x i16, 32x i16) → 16x i32 (64 OPs)
  // Total of 320 OPs per loop iteration, ILP = 5
  size_t n_iterations = N_ITERATIONS/5;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  sdot z0.s, z0.h, z0.h                                     \n"
    "  sdot z1.s, z1.h, z1.h                                     \n"
    "  sdot z2.s, z2.h, z2.h                                     \n"
    "  sdot z3.s, z3.h, z3.h                                     \n"
    "  sdot z4.s, z4.h, z4.h                                     \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*5.0*(double)n_iterations;
}


static double sdot_i32_i16_ilp6(const void*) {
  // SDOT (I16 to I32, 2-way, one vector), Dot Product (integer)
  //
  // Each instruction: (32x i16, 32x i16) → 16x i32 (64 OPs)
  // Total of 384 OPs per loop iteration, ILP = 6
  size_t n_iterations = N_ITERATIONS/6;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  sdot z0.s, z0.h, z0.h                                     \n"
    "  sdot z1.s, z1.h, z1.h                                     \n"
    "  sdot z2.s, z2.h, z2.h                                     \n"
    "  sdot z3.s, z3.h, z3.h                                     \n"
    "  sdot z4.s, z4.h, z4.h                                     \n"
    "  sdot z5.s, z5.h, z5.h                                     \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*6.0*(double)n_iterations;
}


static double sdot_i32_i16_ilp7(const void*) {
  // SDOT (I16 to I32, 2-way, one vector), Dot Product (integer)
  //
  // Each instruction: (32x i16, 32x i16) → 16x i32 (64 OPs)
  // Total of 448 OPs per loop iteration, ILP = 7
  size_t n_iterations = N_ITERATIONS/7;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  sdot z0.s, z0.h, z0.h                                     \n"
    "  sdot z1.s, z1.h, z1.h                                     \n"
    "  sdot z2.s, z2.h, z2.h                                     \n"
    "  sdot z3.s, z3.h, z3.h                                     \n"
    "  sdot z4.s, z4.h, z4.h                                     \n"
    "  sdot z5.s, z5.h, z5.h                                     \n"
    "  sdot z6.s, z6.h, z6.h                                     \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*7.0*(double)n_iterations;
}


static double sdot_i32_i16_ilp8(const void*) {
  // SDOT (I16 to I32, 2-way, one vector), Dot Product (integer)
  //
  // Each instruction: (32x i16, 32x i16) → 16x i32 (64 OPs)
  // Total of 512 OPs per loop iteration, ILP = 8
  size_t n_iterations = N_ITERATIONS/8;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  sdot z0.s, z0.h, z0.h                                     \n"
    "  sdot z1.s, z1.h, z1.h                                     \n"
    "  sdot z2.s, z2.h, z2.h                                     \n"
    "  sdot z3.s, z3.h, z3.h                                     \n"
    "  sdot z4.s, z4.h, z4.h                                     \n"
    "  sdot z5.s, z5.h, z5.h                                     \n"
    "  sdot z6.s, z6.h, z6.h                                     \n"
    "  sdot z7.s, z7.h, z7.h                                     \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*8.0*(double)n_iterations;
}


static double sdot_i32_i16_ilp9(const void*) {
  // SDOT (I16 to I32, 2-way, one vector), Dot Product (integer)
  //
  // Each instruction: (32x i16, 32x i16) → 16x i32 (64 OPs)
  // Total of 576 OPs per loop iteration, ILP = 9
  size_t n_iterations = N_ITERATIONS/9;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  sdot z0.s, z0.h, z0.h                                     \n"
    "  sdot z1.s, z1.h, z1.h                                     \n"
    "  sdot z2.s, z2.h, z2.h                                     \n"
    "  sdot z3.s, z3.h, z3.h                                     \n"
    "  sdot z4.s, z4.h, z4.h                                     \n"
    "  sdot z5.s, z5.h, z5.h                                     \n"
    "  sdot z6.s, z6.h, z6.h                                     \n"
    "  sdot z7.s, z7.h, z7.h                                     \n"
    "  sdot z8.s, z8.h, z8.h                                     \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*9.0*(double)n_iterations;
}


static double sdot_i32_i16_ilp10(const void*) {
  // SDOT (I16 to I32, 2-way, one vector), Dot Product (integer)
  //
  // Each instruction: (32x i16, 32x i16) → 16x i32 (64 OPs)
  // Total of 640 OPs per loop iteration, ILP = 10
  size_t n_iterations = N_ITERATIONS/10;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  sdot z0.s, z0.h, z0.h                                     \n"
    "  sdot z1.s, z1.h, z1.h                                     \n"
    "  sdot z2.s, z2.h, z2.h                                     \n"
    "  sdot z3.s, z3.h, z3.h                                     \n"
    "  sdot z4.s, z4.h, z4.h                                     \n"
    "  sdot z5.s, z5.h, z5.h                                     \n"
    "  sdot z6.s, z6.h, z6.h                                     \n"
    "  sdot z7.s, z7.h, z7.h                                     \n"
    "  sdot z8.s, z8.h, z8.h                                     \n"
    "  sdot z9.s, z9.h, z9.h                                     \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*10.0*(double)n_iterations;
}


static double sdot_i32_i16_ilp11(const void*) {
  // SDOT (I16 to I32, 2-way, one vector), Dot Product (integer)
  //
  // Each instruction: (32x i16, 32x i16) → 16x i32 (64 OPs)
  // Total of 704 OPs per loop iteration, ILP = 11
  size_t n_iterations = N_ITERATIONS/11;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  sdot z0.s, z0.h, z0.h                                     \n"
    "  sdot z1.s, z1.h, z1.h                                     \n"
    "  sdot z2.s, z2.h, z2.h                                     \n"
    "  sdot z3.s, z3.h, z3.h                                     \n"
    "  sdot z4.s, z4.h, z4.h                                     \n"
    "  sdot z5.s, z5.h, z5.h                                     \n"
    "  sdot z6.s, z6.h, z6.h                                     \n"
    "  sdot z7.s, z7.h, z7.h                                     \n"
    "  sdot z8.s, z8.h, z8.h                                     \n"
    "  sdot z9.s, z9.h, z9.h                                     \n"
    "  sdot z10.s, z10.h, z10.h                                  \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*11.0*(double)n_iterations;
}


static double sdot_i32_i16_ilp12(const void*) {
  // SDOT (I16 to I32, 2-way, one vector), Dot Product (integer)
  //
  // Each instruction: (32x i16, 32x i16) → 16x i32 (64 OPs)
  // Total of 768 OPs per loop iteration, ILP = 12
  size_t n_iterations = N_ITERATIONS/12;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  sdot z0.s, z0.h, z0.h                                     \n"
    "  sdot z1.s, z1.h, z1.h                                     \n"
    "  sdot z2.s, z2.h, z2.h                                     \n"
    "  sdot z3.s, z3.h, z3.h                                     \n"
    "  sdot z4.s, z4.h, z4.h                                     \n"
    "  sdot z5.s, z5.h, z5.h                                     \n"
    "  sdot z6.s, z6.h, z6.h                                     \n"
    "  sdot z7.s, z7.h, z7.h                                     \n"
    "  sdot z8.s, z8.h, z8.h                                     \n"
    "  sdot z9.s, z9.h, z9.h                                     \n"
    "  sdot z10.s, z10.h, z10.h                                  \n"
    "  sdot z11.s, z11.h, z11.h                                  \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*12.0*(double)n_iterations;
}


static double sdot_i32_i16_ilp13(const void*) {
  // SDOT (I16 to I32, 2-way, one vector), Dot Product (integer)
  //
  // Each instruction: (32x i16, 32x i16) → 16x i32 (64 OPs)
  // Total of 832 OPs per loop iteration, ILP = 13
  size_t n_iterations = N_ITERATIONS/13;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  sdot z0.s, z0.h, z0.h                                     \n"
    "  sdot z1.s, z1.h, z1.h                                     \n"
    "  sdot z2.s, z2.h, z2.h                                     \n"
    "  sdot z3.s, z3.h, z3.h                                     \n"
    "  sdot z4.s, z4.h, z4.h                                     \n"
    "  sdot z5.s, z5.h, z5.h                                     \n"
    "  sdot z6.s, z6.h, z6.h                                     \n"
    "  sdot z7.s, z7.h, z7.h                                     \n"
    "  sdot z8.s, z8.h, z8.h                                     \n"
    "  sdot z9.s, z9.h, z9.h                                     \n"
    "  sdot z10.s, z10.h, z10.h                                  \n"
    "  sdot z11.s, z11.h, z11.h                                  \n"
    "  sdot z12.s, z12.h, z12.h                                  \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*13.0*(double)n_iterations;
}


static double sdot_i32_i16_ilp14(const void*) {
  // SDOT (I16 to I32, 2-way, one vector), Dot Product (integer)
  //
  // Each instruction: (32x i16, 32x i16) → 16x i32 (64 OPs)
  // Total of 896 OPs per loop iteration, ILP = 14
  size_t n_iterations = N_ITERATIONS/14;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  sdot z0.s, z0.h, z0.h                                     \n"
    "  sdot z1.s, z1.h, z1.h                                     \n"
    "  sdot z2.s, z2.h, z2.h                                     \n"
    "  sdot z3.s, z3.h, z3.h                                     \n"
    "  sdot z4.s, z4.h, z4.h                                     \n"
    "  sdot z5.s, z5.h, z5.h                                     \n"
    "  sdot z6.s, z6.h, z6.h                                     \n"
    "  sdot z7.s, z7.h, z7.h                                     \n"
    "  sdot z8.s, z8.h, z8.h                                     \n"
    "  sdot z9.s, z9.h, z9.h                                     \n"
    "  sdot z10.s, z10.h, z10.h                                  \n"
    "  sdot z11.s, z11.h, z11.h                                  \n"
    "  sdot z12.s, z12.h, z12.h                                  \n"
    "  sdot z13.s, z13.h, z13.h                                  \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*14.0*(double)n_iterations;
}


static double sdot_i32_i16_ilp15(const void*) {
  // SDOT (I16 to I32, 2-way, one vector), Dot Product (integer)
  //
  // Each instruction: (32x i16, 32x i16) → 16x i32 (64 OPs)
  // Total of 960 OPs per loop iteration, ILP = 15
  size_t n_iterations = N_ITERATIONS/15;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  sdot z0.s, z0.h, z0.h                                     \n"
    "  sdot z1.s, z1.h, z1.h                                     \n"
    "  sdot z2.s, z2.h, z2.h                                     \n"
    "  sdot z3.s, z3.h, z3.h                                     \n"
    "  sdot z4.s, z4.h, z4.h                                     \n"
    "  sdot z5.s, z5.h, z5.h                                     \n"
    "  sdot z6.s, z6.h, z6.h                                     \n"
    "  sdot z7.s, z7.h, z7.h                                     \n"
    "  sdot z8.s, z8.h, z8.h                                     \n"
    "  sdot z9.s, z9.h, z9.h                                     \n"
    "  sdot z10.s, z10.h, z10.h                                  \n"
    "  sdot z11.s, z11.h, z11.h                                  \n"
    "  sdot z12.s, z12.h, z12.h                                  \n"
    "  sdot z13.s, z13.h, z13.h                                  \n"
    "  sdot z14.s, z14.h, z14.h                                  \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*15.0*(double)n_iterations;
}


static double sdot_i32_i16_ilp16(const void*) {
  // SDOT (I16 to I32, 2-way, one vector), Dot Product (integer)
  //
  // Each instruction: (32x i16, 32x i16) → 16x i32 (64 OPs)
  // Total of 1024 OPs per loop iteration, ILP = 16
  size_t n_iterations = N_ITERATIONS/16;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  sdot z0.s, z0.h, z0.h                                     \n"
    "  sdot z1.s, z1.h, z1.h                                     \n"
    "  sdot z2.s, z2.h, z2.h                                     \n"
    "  sdot z3.s, z3.h, z3.h                                     \n"
    "  sdot z4.s, z4.h, z4.h                                     \n"
    "  sdot z5.s, z5.h, z5.h                                     \n"
    "  sdot z6.s, z6.h, z6.h                                     \n"
    "  sdot z7.s, z7.h, z7.h                                     \n"
    "  sdot z8.s, z8.h, z8.h                                     \n"
    "  sdot z9.s, z9.h, z9.h                                     \n"
    "  sdot z10.s, z10.h, z10.h                                  \n"
    "  sdot z11.s, z11.h, z11.h                                  \n"
    "  sdot z12.s, z12.h, z12.h                                  \n"
    "  sdot z13.s, z13.h, z13.h                                  \n"
    "  sdot z14.s, z14.h, z14.h                                  \n"
    "  sdot z15.s, z15.h, z15.h                                  \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*16.0*(double)n_iterations;
}


static double sdot_i32_i8_ilp1(const void*) {
  // SDOT (I8 to I32, 4-way, one vector), Dot Product (integer)
  //
  // Each instruction: (64x i8, 64x i8) → 16x i32 (128 OPs)
  // Total of 128 OPs per loop iteration, ILP = 1
  size_t n_iterations = N_ITERATIONS;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  sdot z0.s, z0.b, z0.b                                     \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*1.0*(double)n_iterations;
}


static double sdot_i32_i8_ilp2(const void*) {
  // SDOT (I8 to I32, 4-way, one vector), Dot Product (integer)
  //
  // Each instruction: (64x i8, 64x i8) → 16x i32 (128 OPs)
  // Total of 256 OPs per loop iteration, ILP = 2
  size_t n_iterations = N_ITERATIONS/2;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  sdot z0.s, z0.b, z0.b                                     \n"
    "  sdot z1.s, z1.b, z1.b                                     \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*2.0*(double)n_iterations;
}


static double sdot_i32_i8_ilp3(const void*) {
  // SDOT (I8 to I32, 4-way, one vector), Dot Product (integer)
  //
  // Each instruction: (64x i8, 64x i8) → 16x i32 (128 OPs)
  // Total of 384 OPs per loop iteration, ILP = 3
  size_t n_iterations = N_ITERATIONS/3;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  sdot z0.s, z0.b, z0.b                                     \n"
    "  sdot z1.s, z1.b, z1.b                                     \n"
    "  sdot z2.s, z2.b, z2.b                                     \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*3.0*(double)n_iterations;
}


static double sdot_i32_i8_ilp4(const void*) {
  // SDOT (I8 to I32, 4-way, one vector), Dot Product (integer)
  //
  // Each instruction: (64x i8, 64x i8) → 16x i32 (128 OPs)
  // Total of 512 OPs per loop iteration, ILP = 4
  size_t n_iterations = N_ITERATIONS/4;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  sdot z0.s, z0.b, z0.b                                     \n"
    "  sdot z1.s, z1.b, z1.b                                     \n"
    "  sdot z2.s, z2.b, z2.b                                     \n"
    "  sdot z3.s, z3.b, z3.b                                     \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*4.0*(double)n_iterations;
}


static double sdot_i32_i8_ilp5(const void*) {
  // SDOT (I8 to I32, 4-way, one vector), Dot Product (integer)
  //
  // Each instruction: (64x i8, 64x i8) → 16x i32 (128 OPs)
  // Total of 640 OPs per loop iteration, ILP = 5
  size_t n_iterations = N_ITERATIONS/5;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  sdot z0.s, z0.b, z0.b                                     \n"
    "  sdot z1.s, z1.b, z1.b                                     \n"
    "  sdot z2.s, z2.b, z2.b                                     \n"
    "  sdot z3.s, z3.b, z3.b                                     \n"
    "  sdot z4.s, z4.b, z4.b                                     \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*5.0*(double)n_iterations;
}


static double sdot_i32_i8_ilp6(const void*) {
  // SDOT (I8 to I32, 4-way, one vector), Dot Product (integer)
  //
  // Each instruction: (64x i8, 64x i8) → 16x i32 (128 OPs)
  // Total of 768 OPs per loop iteration, ILP = 6
  size_t n_iterations = N_ITERATIONS/6;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  sdot z0.s, z0.b, z0.b                                     \n"
    "  sdot z1.s, z1.b, z1.b                                     \n"
    "  sdot z2.s, z2.b, z2.b                                     \n"
    "  sdot z3.s, z3.b, z3.b                                     \n"
    "  sdot z4.s, z4.b, z4.b                                     \n"
    "  sdot z5.s, z5.b, z5.b                                     \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*6.0*(double)n_iterations;
}


static double sdot_i32_i8_ilp7(const void*) {
  // SDOT (I8 to I32, 4-way, one vector), Dot Product (integer)
  //
  // Each instruction: (64x i8, 64x i8) → 16x i32 (128 OPs)
  // Total of 896 OPs per loop iteration, ILP = 7
  size_t n_iterations = N_ITERATIONS/7;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  sdot z0.s, z0.b, z0.b                                     \n"
    "  sdot z1.s, z1.b, z1.b                                     \n"
    "  sdot z2.s, z2.b, z2.b                                     \n"
    "  sdot z3.s, z3.b, z3.b                                     \n"
    "  sdot z4.s, z4.b, z4.b                                     \n"
    "  sdot z5.s, z5.b, z5.b                                     \n"
    "  sdot z6.s, z6.b, z6.b                                     \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*7.0*(double)n_iterations;
}


static double sdot_i32_i8_ilp8(const void*) {
  // SDOT (I8 to I32, 4-way, one vector), Dot Product (integer)
  //
  // Each instruction: (64x i8, 64x i8) → 16x i32 (128 OPs)
  // Total of 1024 OPs per loop iteration, ILP = 8
  size_t n_iterations = N_ITERATIONS/8;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  sdot z0.s, z0.b, z0.b                                     \n"
    "  sdot z1.s, z1.b, z1.b                                     \n"
    "  sdot z2.s, z2.b, z2.b                                     \n"
    "  sdot z3.s, z3.b, z3.b                                     \n"
    "  sdot z4.s, z4.b, z4.b                                     \n"
    "  sdot z5.s, z5.b, z5.b                                     \n"
    "  sdot z6.s, z6.b, z6.b                                     \n"
    "  sdot z7.s, z7.b, z7.b                                     \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*8.0*(double)n_iterations;
}


static double sdot_i32_i8_ilp9(const void*) {
  // SDOT (I8 to I32, 4-way, one vector), Dot Product (integer)
  //
  // Each instruction: (64x i8, 64x i8) → 16x i32 (128 OPs)
  // Total of 1152 OPs per loop iteration, ILP = 9
  size_t n_iterations = N_ITERATIONS/9;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  sdot z0.s, z0.b, z0.b                                     \n"
    "  sdot z1.s, z1.b, z1.b                                     \n"
    "  sdot z2.s, z2.b, z2.b                                     \n"
    "  sdot z3.s, z3.b, z3.b                                     \n"
    "  sdot z4.s, z4.b, z4.b                                     \n"
    "  sdot z5.s, z5.b, z5.b                                     \n"
    "  sdot z6.s, z6.b, z6.b                                     \n"
    "  sdot z7.s, z7.b, z7.b                                     \n"
    "  sdot z8.s, z8.b, z8.b                                     \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*9.0*(double)n_iterations;
}


static double sdot_i32_i8_ilp10(const void*) {
  // SDOT (I8 to I32, 4-way, one vector), Dot Product (integer)
  //
  // Each instruction: (64x i8, 64x i8) → 16x i32 (128 OPs)
  // Total of 1280 OPs per loop iteration, ILP = 10
  size_t n_iterations = N_ITERATIONS/10;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  sdot z0.s, z0.b, z0.b                                     \n"
    "  sdot z1.s, z1.b, z1.b                                     \n"
    "  sdot z2.s, z2.b, z2.b                                     \n"
    "  sdot z3.s, z3.b, z3.b                                     \n"
    "  sdot z4.s, z4.b, z4.b                                     \n"
    "  sdot z5.s, z5.b, z5.b                                     \n"
    "  sdot z6.s, z6.b, z6.b                                     \n"
    "  sdot z7.s, z7.b, z7.b                                     \n"
    "  sdot z8.s, z8.b, z8.b                                     \n"
    "  sdot z9.s, z9.b, z9.b                                     \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*10.0*(double)n_iterations;
}


static double sdot_i32_i8_ilp11(const void*) {
  // SDOT (I8 to I32, 4-way, one vector), Dot Product (integer)
  //
  // Each instruction: (64x i8, 64x i8) → 16x i32 (128 OPs)
  // Total of 1408 OPs per loop iteration, ILP = 11
  size_t n_iterations = N_ITERATIONS/11;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  sdot z0.s, z0.b, z0.b                                     \n"
    "  sdot z1.s, z1.b, z1.b                                     \n"
    "  sdot z2.s, z2.b, z2.b                                     \n"
    "  sdot z3.s, z3.b, z3.b                                     \n"
    "  sdot z4.s, z4.b, z4.b                                     \n"
    "  sdot z5.s, z5.b, z5.b                                     \n"
    "  sdot z6.s, z6.b, z6.b                                     \n"
    "  sdot z7.s, z7.b, z7.b                                     \n"
    "  sdot z8.s, z8.b, z8.b                                     \n"
    "  sdot z9.s, z9.b, z9.b                                     \n"
    "  sdot z10.s, z10.b, z10.b                                  \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*11.0*(double)n_iterations;
}


static double sdot_i32_i8_ilp12(const void*) {
  // SDOT (I8 to I32, 4-way, one vector), Dot Product (integer)
  //
  // Each instruction: (64x i8, 64x i8) → 16x i32 (128 OPs)
  // Total of 1536 OPs per loop iteration, ILP = 12
  size_t n_iterations = N_ITERATIONS/12;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  sdot z0.s, z0.b, z0.b                                     \n"
    "  sdot z1.s, z1.b, z1.b                                     \n"
    "  sdot z2.s, z2.b, z2.b                                     \n"
    "  sdot z3.s, z3.b, z3.b                                     \n"
    "  sdot z4.s, z4.b, z4.b                                     \n"
    "  sdot z5.s, z5.b, z5.b                                     \n"
    "  sdot z6.s, z6.b, z6.b                                     \n"
    "  sdot z7.s, z7.b, z7.b                                     \n"
    "  sdot z8.s, z8.b, z8.b                                     \n"
    "  sdot z9.s, z9.b, z9.b                                     \n"
    "  sdot z10.s, z10.b, z10.b                                  \n"
    "  sdot z11.s, z11.b, z11.b                                  \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*12.0*(double)n_iterations;
}


static double sdot_i32_i8_ilp13(const void*) {
  // SDOT (I8 to I32, 4-way, one vector), Dot Product (integer)
  //
  // Each instruction: (64x i8, 64x i8) → 16x i32 (128 OPs)
  // Total of 1664 OPs per loop iteration, ILP = 13
  size_t n_iterations = N_ITERATIONS/13;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  sdot z0.s, z0.b, z0.b                                     \n"
    "  sdot z1.s, z1.b, z1.b                                     \n"
    "  sdot z2.s, z2.b, z2.b                                     \n"
    "  sdot z3.s, z3.b, z3.b                                     \n"
    "  sdot z4.s, z4.b, z4.b                                     \n"
    "  sdot z5.s, z5.b, z5.b                                     \n"
    "  sdot z6.s, z6.b, z6.b                                     \n"
    "  sdot z7.s, z7.b, z7.b                                     \n"
    "  sdot z8.s, z8.b, z8.b                                     \n"
    "  sdot z9.s, z9.b, z9.b                                     \n"
    "  sdot z10.s, z10.b, z10.b                                  \n"
    "  sdot z11.s, z11.b, z11.b                                  \n"
    "  sdot z12.s, z12.b, z12.b                                  \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*13.0*(double)n_iterations;
}


static double sdot_i32_i8_ilp14(const void*) {
  // SDOT (I8 to I32, 4-way, one vector), Dot Product (integer)
  //
  // Each instruction: (64x i8, 64x i8) → 16x i32 (128 OPs)
  // Total of 1792 OPs per loop iteration, ILP = 14
  size_t n_iterations = N_ITERATIONS/14;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  sdot z0.s, z0.b, z0.b                                     \n"
    "  sdot z1.s, z1.b, z1.b                                     \n"
    "  sdot z2.s, z2.b, z2.b                                     \n"
    "  sdot z3.s, z3.b, z3.b                                     \n"
    "  sdot z4.s, z4.b, z4.b                                     \n"
    "  sdot z5.s, z5.b, z5.b                                     \n"
    "  sdot z6.s, z6.b, z6.b                                     \n"
    "  sdot z7.s, z7.b, z7.b                                     \n"
    "  sdot z8.s, z8.b, z8.b                                     \n"
    "  sdot z9.s, z9.b, z9.b                                     \n"
    "  sdot z10.s, z10.b, z10.b                                  \n"
    "  sdot z11.s, z11.b, z11.b                                  \n"
    "  sdot z12.s, z12.b, z12.b                                  \n"
    "  sdot z13.s, z13.b, z13.b                                  \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*14.0*(double)n_iterations;
}


static double sdot_i32_i8_ilp15(const void*) {
  // SDOT (I8 to I32, 4-way, one vector), Dot Product (integer)
  //
  // Each instruction: (64x i8, 64x i8) → 16x i32 (128 OPs)
  // Total of 1920 OPs per loop iteration, ILP = 15
  size_t n_iterations = N_ITERATIONS/15;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  sdot z0.s, z0.b, z0.b                                     \n"
    "  sdot z1.s, z1.b, z1.b                                     \n"
    "  sdot z2.s, z2.b, z2.b                                     \n"
    "  sdot z3.s, z3.b, z3.b                                     \n"
    "  sdot z4.s, z4.b, z4.b                                     \n"
    "  sdot z5.s, z5.b, z5.b                                     \n"
    "  sdot z6.s, z6.b, z6.b                                     \n"
    "  sdot z7.s, z7.b, z7.b                                     \n"
    "  sdot z8.s, z8.b, z8.b                                     \n"
    "  sdot z9.s, z9.b, z9.b                                     \n"
    "  sdot z10.s, z10.b, z10.b                                  \n"
    "  sdot z11.s, z11.b, z11.b                                  \n"
    "  sdot z12.s, z12.b, z12.b                                  \n"
    "  sdot z13.s, z13.b, z13.b                                  \n"
    "  sdot z14.s, z14.b, z14.b                                  \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*15.0*(double)n_iterations;
}


static double sdot_i32_i8_ilp16(const void*) {
  // SDOT (I8 to I32, 4-way, one vector), Dot Product (integer)
  //
  // Each instruction: (64x i8, 64x i8) → 16x i32 (128 OPs)
  // Total of 2048 OPs per loop iteration, ILP = 16
  size_t n_iterations = N_ITERATIONS/16;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  sdot z0.s, z0.b, z0.b                                     \n"
    "  sdot z1.s, z1.b, z1.b                                     \n"
    "  sdot z2.s, z2.b, z2.b                                     \n"
    "  sdot z3.s, z3.b, z3.b                                     \n"
    "  sdot z4.s, z4.b, z4.b                                     \n"
    "  sdot z5.s, z5.b, z5.b                                     \n"
    "  sdot z6.s, z6.b, z6.b                                     \n"
    "  sdot z7.s, z7.b, z7.b                                     \n"
    "  sdot z8.s, z8.b, z8.b                                     \n"
    "  sdot z9.s, z9.b, z9.b                                     \n"
    "  sdot z10.s, z10.b, z10.b                                  \n"
    "  sdot z11.s, z11.b, z11.b                                  \n"
    "  sdot z12.s, z12.b, z12.b                                  \n"
    "  sdot z13.s, z13.b, z13.b                                  \n"
    "  sdot z14.s, z14.b, z14.b                                  \n"
    "  sdot z15.s, z15.b, z15.b                                  \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*16.0*(double)n_iterations;
}


static double sdot_i64_i16_ilp1(const void*) {
  // SDOT (I16 to I64, 4-way, one vector), Dot Product (integer)
  //
  // Each instruction: (32x i16, 32x i16) → 8x i64 (64 OPs)
  // Total of 64 OPs per loop iteration, ILP = 1
  size_t n_iterations = N_ITERATIONS;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  sdot z0.d, z0.h, z0.h                                     \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*1.0*(double)n_iterations;
}


static double sdot_i64_i16_ilp2(const void*) {
  // SDOT (I16 to I64, 4-way, one vector), Dot Product (integer)
  //
  // Each instruction: (32x i16, 32x i16) → 8x i64 (64 OPs)
  // Total of 128 OPs per loop iteration, ILP = 2
  size_t n_iterations = N_ITERATIONS/2;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  sdot z0.d, z0.h, z0.h                                     \n"
    "  sdot z1.d, z1.h, z1.h                                     \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*2.0*(double)n_iterations;
}


static double sdot_i64_i16_ilp3(const void*) {
  // SDOT (I16 to I64, 4-way, one vector), Dot Product (integer)
  //
  // Each instruction: (32x i16, 32x i16) → 8x i64 (64 OPs)
  // Total of 192 OPs per loop iteration, ILP = 3
  size_t n_iterations = N_ITERATIONS/3;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  sdot z0.d, z0.h, z0.h                                     \n"
    "  sdot z1.d, z1.h, z1.h                                     \n"
    "  sdot z2.d, z2.h, z2.h                                     \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*3.0*(double)n_iterations;
}


static double sdot_i64_i16_ilp4(const void*) {
  // SDOT (I16 to I64, 4-way, one vector), Dot Product (integer)
  //
  // Each instruction: (32x i16, 32x i16) → 8x i64 (64 OPs)
  // Total of 256 OPs per loop iteration, ILP = 4
  size_t n_iterations = N_ITERATIONS/4;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  sdot z0.d, z0.h, z0.h                                     \n"
    "  sdot z1.d, z1.h, z1.h                                     \n"
    "  sdot z2.d, z2.h, z2.h                                     \n"
    "  sdot z3.d, z3.h, z3.h                                     \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*4.0*(double)n_iterations;
}


static double sdot_i64_i16_ilp5(const void*) {
  // SDOT (I16 to I64, 4-way, one vector), Dot Product (integer)
  //
  // Each instruction: (32x i16, 32x i16) → 8x i64 (64 OPs)
  // Total of 320 OPs per loop iteration, ILP = 5
  size_t n_iterations = N_ITERATIONS/5;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  sdot z0.d, z0.h, z0.h                                     \n"
    "  sdot z1.d, z1.h, z1.h                                     \n"
    "  sdot z2.d, z2.h, z2.h                                     \n"
    "  sdot z3.d, z3.h, z3.h                                     \n"
    "  sdot z4.d, z4.h, z4.h                                     \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*5.0*(double)n_iterations;
}


static double sdot_i64_i16_ilp6(const void*) {
  // SDOT (I16 to I64, 4-way, one vector), Dot Product (integer)
  //
  // Each instruction: (32x i16, 32x i16) → 8x i64 (64 OPs)
  // Total of 384 OPs per loop iteration, ILP = 6
  size_t n_iterations = N_ITERATIONS/6;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  sdot z0.d, z0.h, z0.h                                     \n"
    "  sdot z1.d, z1.h, z1.h                                     \n"
    "  sdot z2.d, z2.h, z2.h                                     \n"
    "  sdot z3.d, z3.h, z3.h                                     \n"
    "  sdot z4.d, z4.h, z4.h                                     \n"
    "  sdot z5.d, z5.h, z5.h                                     \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*6.0*(double)n_iterations;
}


static double sdot_i64_i16_ilp7(const void*) {
  // SDOT (I16 to I64, 4-way, one vector), Dot Product (integer)
  //
  // Each instruction: (32x i16, 32x i16) → 8x i64 (64 OPs)
  // Total of 448 OPs per loop iteration, ILP = 7
  size_t n_iterations = N_ITERATIONS/7;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  sdot z0.d, z0.h, z0.h                                     \n"
    "  sdot z1.d, z1.h, z1.h                                     \n"
    "  sdot z2.d, z2.h, z2.h                                     \n"
    "  sdot z3.d, z3.h, z3.h                                     \n"
    "  sdot z4.d, z4.h, z4.h                                     \n"
    "  sdot z5.d, z5.h, z5.h                                     \n"
    "  sdot z6.d, z6.h, z6.h                                     \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*7.0*(double)n_iterations;
}


static double sdot_i64_i16_ilp8(const void*) {
  // SDOT (I16 to I64, 4-way, one vector), Dot Product (integer)
  //
  // Each instruction: (32x i16, 32x i16) → 8x i64 (64 OPs)
  // Total of 512 OPs per loop iteration, ILP = 8
  size_t n_iterations = N_ITERATIONS/8;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  sdot z0.d, z0.h, z0.h                                     \n"
    "  sdot z1.d, z1.h, z1.h                                     \n"
    "  sdot z2.d, z2.h, z2.h                                     \n"
    "  sdot z3.d, z3.h, z3.h                                     \n"
    "  sdot z4.d, z4.h, z4.h                                     \n"
    "  sdot z5.d, z5.h, z5.h                                     \n"
    "  sdot z6.d, z6.h, z6.h                                     \n"
    "  sdot z7.d, z7.h, z7.h                                     \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*8.0*(double)n_iterations;
}


static double sdot_i64_i16_ilp9(const void*) {
  // SDOT (I16 to I64, 4-way, one vector), Dot Product (integer)
  //
  // Each instruction: (32x i16, 32x i16) → 8x i64 (64 OPs)
  // Total of 576 OPs per loop iteration, ILP = 9
  size_t n_iterations = N_ITERATIONS/9;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  sdot z0.d, z0.h, z0.h                                     \n"
    "  sdot z1.d, z1.h, z1.h                                     \n"
    "  sdot z2.d, z2.h, z2.h                                     \n"
    "  sdot z3.d, z3.h, z3.h                                     \n"
    "  sdot z4.d, z4.h, z4.h                                     \n"
    "  sdot z5.d, z5.h, z5.h                                     \n"
    "  sdot z6.d, z6.h, z6.h                                     \n"
    "  sdot z7.d, z7.h, z7.h                                     \n"
    "  sdot z8.d, z8.h, z8.h                                     \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*9.0*(double)n_iterations;
}


static double sdot_i64_i16_ilp10(const void*) {
  // SDOT (I16 to I64, 4-way, one vector), Dot Product (integer)
  //
  // Each instruction: (32x i16, 32x i16) → 8x i64 (64 OPs)
  // Total of 640 OPs per loop iteration, ILP = 10
  size_t n_iterations = N_ITERATIONS/10;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  sdot z0.d, z0.h, z0.h                                     \n"
    "  sdot z1.d, z1.h, z1.h                                     \n"
    "  sdot z2.d, z2.h, z2.h                                     \n"
    "  sdot z3.d, z3.h, z3.h                                     \n"
    "  sdot z4.d, z4.h, z4.h                                     \n"
    "  sdot z5.d, z5.h, z5.h                                     \n"
    "  sdot z6.d, z6.h, z6.h                                     \n"
    "  sdot z7.d, z7.h, z7.h                                     \n"
    "  sdot z8.d, z8.h, z8.h                                     \n"
    "  sdot z9.d, z9.h, z9.h                                     \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*10.0*(double)n_iterations;
}


static double sdot_i64_i16_ilp11(const void*) {
  // SDOT (I16 to I64, 4-way, one vector), Dot Product (integer)
  //
  // Each instruction: (32x i16, 32x i16) → 8x i64 (64 OPs)
  // Total of 704 OPs per loop iteration, ILP = 11
  size_t n_iterations = N_ITERATIONS/11;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  sdot z0.d, z0.h, z0.h                                     \n"
    "  sdot z1.d, z1.h, z1.h                                     \n"
    "  sdot z2.d, z2.h, z2.h                                     \n"
    "  sdot z3.d, z3.h, z3.h                                     \n"
    "  sdot z4.d, z4.h, z4.h                                     \n"
    "  sdot z5.d, z5.h, z5.h                                     \n"
    "  sdot z6.d, z6.h, z6.h                                     \n"
    "  sdot z7.d, z7.h, z7.h                                     \n"
    "  sdot z8.d, z8.h, z8.h                                     \n"
    "  sdot z9.d, z9.h, z9.h                                     \n"
    "  sdot z10.d, z10.h, z10.h                                  \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*11.0*(double)n_iterations;
}


static double sdot_i64_i16_ilp12(const void*) {
  // SDOT (I16 to I64, 4-way, one vector), Dot Product (integer)
  //
  // Each instruction: (32x i16, 32x i16) → 8x i64 (64 OPs)
  // Total of 768 OPs per loop iteration, ILP = 12
  size_t n_iterations = N_ITERATIONS/12;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  sdot z0.d, z0.h, z0.h                                     \n"
    "  sdot z1.d, z1.h, z1.h                                     \n"
    "  sdot z2.d, z2.h, z2.h                                     \n"
    "  sdot z3.d, z3.h, z3.h                                     \n"
    "  sdot z4.d, z4.h, z4.h                                     \n"
    "  sdot z5.d, z5.h, z5.h                                     \n"
    "  sdot z6.d, z6.h, z6.h                                     \n"
    "  sdot z7.d, z7.h, z7.h                                     \n"
    "  sdot z8.d, z8.h, z8.h                                     \n"
    "  sdot z9.d, z9.h, z9.h                                     \n"
    "  sdot z10.d, z10.h, z10.h                                  \n"
    "  sdot z11.d, z11.h, z11.h                                  \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*12.0*(double)n_iterations;
}


static double sdot_i64_i16_ilp13(const void*) {
  // SDOT (I16 to I64, 4-way, one vector), Dot Product (integer)
  //
  // Each instruction: (32x i16, 32x i16) → 8x i64 (64 OPs)
  // Total of 832 OPs per loop iteration, ILP = 13
  size_t n_iterations = N_ITERATIONS/13;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  sdot z0.d, z0.h, z0.h                                     \n"
    "  sdot z1.d, z1.h, z1.h                                     \n"
    "  sdot z2.d, z2.h, z2.h                                     \n"
    "  sdot z3.d, z3.h, z3.h                                     \n"
    "  sdot z4.d, z4.h, z4.h                                     \n"
    "  sdot z5.d, z5.h, z5.h                                     \n"
    "  sdot z6.d, z6.h, z6.h                                     \n"
    "  sdot z7.d, z7.h, z7.h                                     \n"
    "  sdot z8.d, z8.h, z8.h                                     \n"
    "  sdot z9.d, z9.h, z9.h                                     \n"
    "  sdot z10.d, z10.h, z10.h                                  \n"
    "  sdot z11.d, z11.h, z11.h                                  \n"
    "  sdot z12.d, z12.h, z12.h                                  \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*13.0*(double)n_iterations;
}


static double sdot_i64_i16_ilp14(const void*) {
  // SDOT (I16 to I64, 4-way, one vector), Dot Product (integer)
  //
  // Each instruction: (32x i16, 32x i16) → 8x i64 (64 OPs)
  // Total of 896 OPs per loop iteration, ILP = 14
  size_t n_iterations = N_ITERATIONS/14;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  sdot z0.d, z0.h, z0.h                                     \n"
    "  sdot z1.d, z1.h, z1.h                                     \n"
    "  sdot z2.d, z2.h, z2.h                                     \n"
    "  sdot z3.d, z3.h, z3.h                                     \n"
    "  sdot z4.d, z4.h, z4.h                                     \n"
    "  sdot z5.d, z5.h, z5.h                                     \n"
    "  sdot z6.d, z6.h, z6.h                                     \n"
    "  sdot z7.d, z7.h, z7.h                                     \n"
    "  sdot z8.d, z8.h, z8.h                                     \n"
    "  sdot z9.d, z9.h, z9.h                                     \n"
    "  sdot z10.d, z10.h, z10.h                                  \n"
    "  sdot z11.d, z11.h, z11.h                                  \n"
    "  sdot z12.d, z12.h, z12.h                                  \n"
    "  sdot z13.d, z13.h, z13.h                                  \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*14.0*(double)n_iterations;
}


static double sdot_i64_i16_ilp15(const void*) {
  // SDOT (I16 to I64, 4-way, one vector), Dot Product (integer)
  //
  // Each instruction: (32x i16, 32x i16) → 8x i64 (64 OPs)
  // Total of 960 OPs per loop iteration, ILP = 15
  size_t n_iterations = N_ITERATIONS/15;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  sdot z0.d, z0.h, z0.h                                     \n"
    "  sdot z1.d, z1.h, z1.h                                     \n"
    "  sdot z2.d, z2.h, z2.h                                     \n"
    "  sdot z3.d, z3.h, z3.h                                     \n"
    "  sdot z4.d, z4.h, z4.h                                     \n"
    "  sdot z5.d, z5.h, z5.h                                     \n"
    "  sdot z6.d, z6.h, z6.h                                     \n"
    "  sdot z7.d, z7.h, z7.h                                     \n"
    "  sdot z8.d, z8.h, z8.h                                     \n"
    "  sdot z9.d, z9.h, z9.h                                     \n"
    "  sdot z10.d, z10.h, z10.h                                  \n"
    "  sdot z11.d, z11.h, z11.h                                  \n"
    "  sdot z12.d, z12.h, z12.h                                  \n"
    "  sdot z13.d, z13.h, z13.h                                  \n"
    "  sdot z14.d, z14.h, z14.h                                  \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*15.0*(double)n_iterations;
}


static double sdot_i64_i16_ilp16(const void*) {
  // SDOT (I16 to I64, 4-way, one vector), Dot Product (integer)
  //
  // Each instruction: (32x i16, 32x i16) → 8x i64 (64 OPs)
  // Total of 1024 OPs per loop iteration, ILP = 16
  size_t n_iterations = N_ITERATIONS/16;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "1:                                                          \n"
    "  sdot z0.d, z0.h, z0.h                                     \n"
    "  sdot z1.d, z1.h, z1.h                                     \n"
    "  sdot z2.d, z2.h, z2.h                                     \n"
    "  sdot z3.d, z3.h, z3.h                                     \n"
    "  sdot z4.d, z4.h, z4.h                                     \n"
    "  sdot z5.d, z5.h, z5.h                                     \n"
    "  sdot z6.d, z6.h, z6.h                                     \n"
    "  sdot z7.d, z7.h, z7.h                                     \n"
    "  sdot z8.d, z8.h, z8.h                                     \n"
    "  sdot z9.d, z9.h, z9.h                                     \n"
    "  sdot z10.d, z10.h, z10.h                                  \n"
    "  sdot z11.d, z11.h, z11.h                                  \n"
    "  sdot z12.d, z12.h, z12.h                                  \n"
    "  sdot z13.d, z13.h, z13.h                                  \n"
    "  sdot z14.d, z14.h, z14.h                                  \n"
    "  sdot z15.d, z15.h, z15.h                                  \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*16.0*(double)n_iterations;
}


static double sdot_za_i32_i16_vgx2_ilp1(const void*) {
  // SDOT (I16 to I32, 2-way, two vectors), Dot Product (integer)
  //
  // Each instruction: (64x i16, 64x i16) → 32x i32 (128 OPs)
  // Total of 128 OPs per loop iteration, ILP = 1
  size_t n_iterations = N_ITERATIONS;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  sdot za.s[w8, 0, VGx2], {z0.h-z1.h}, {z0.h-z1.h}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*1.0*(double)n_iterations;
}


static double sdot_za_i32_i16_vgx2_ilp2(const void*) {
  // SDOT (I16 to I32, 2-way, two vectors), Dot Product (integer)
  //
  // Each instruction: (64x i16, 64x i16) → 32x i32 (128 OPs)
  // Total of 256 OPs per loop iteration, ILP = 2
  size_t n_iterations = N_ITERATIONS/2;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  sdot za.s[w8, 0, VGx2], {z0.h-z1.h}, {z0.h-z1.h}          \n"
    "  sdot za.s[w8, 1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*2.0*(double)n_iterations;
}


static double sdot_za_i32_i16_vgx2_ilp3(const void*) {
  // SDOT (I16 to I32, 2-way, two vectors), Dot Product (integer)
  //
  // Each instruction: (64x i16, 64x i16) → 32x i32 (128 OPs)
  // Total of 384 OPs per loop iteration, ILP = 3
  size_t n_iterations = N_ITERATIONS/3;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  sdot za.s[w8, 0, VGx2], {z0.h-z1.h}, {z0.h-z1.h}          \n"
    "  sdot za.s[w8, 1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}          \n"
    "  sdot za.s[w8, 2, VGx2], {z2.h-z3.h}, {z2.h-z3.h}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*3.0*(double)n_iterations;
}


static double sdot_za_i32_i16_vgx2_ilp4(const void*) {
  // SDOT (I16 to I32, 2-way, two vectors), Dot Product (integer)
  //
  // Each instruction: (64x i16, 64x i16) → 32x i32 (128 OPs)
  // Total of 512 OPs per loop iteration, ILP = 4
  size_t n_iterations = N_ITERATIONS/4;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  sdot za.s[w8, 0, VGx2], {z0.h-z1.h}, {z0.h-z1.h}          \n"
    "  sdot za.s[w8, 1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}          \n"
    "  sdot za.s[w8, 2, VGx2], {z2.h-z3.h}, {z2.h-z3.h}          \n"
    "  sdot za.s[w8, 3, VGx2], {z2.h-z3.h}, {z2.h-z3.h}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*4.0*(double)n_iterations;
}


static double sdot_za_i32_i16_vgx2_ilp5(const void*) {
  // SDOT (I16 to I32, 2-way, two vectors), Dot Product (integer)
  //
  // Each instruction: (64x i16, 64x i16) → 32x i32 (128 OPs)
  // Total of 640 OPs per loop iteration, ILP = 5
  size_t n_iterations = N_ITERATIONS/5;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  sdot za.s[w8, 0, VGx2], {z0.h-z1.h}, {z0.h-z1.h}          \n"
    "  sdot za.s[w8, 1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}          \n"
    "  sdot za.s[w8, 2, VGx2], {z2.h-z3.h}, {z2.h-z3.h}          \n"
    "  sdot za.s[w8, 3, VGx2], {z2.h-z3.h}, {z2.h-z3.h}          \n"
    "  sdot za.s[w8, 4, VGx2], {z4.h-z5.h}, {z4.h-z5.h}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*5.0*(double)n_iterations;
}


static double sdot_za_i32_i16_vgx2_ilp6(const void*) {
  // SDOT (I16 to I32, 2-way, two vectors), Dot Product (integer)
  //
  // Each instruction: (64x i16, 64x i16) → 32x i32 (128 OPs)
  // Total of 768 OPs per loop iteration, ILP = 6
  size_t n_iterations = N_ITERATIONS/6;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  sdot za.s[w8, 0, VGx2], {z0.h-z1.h}, {z0.h-z1.h}          \n"
    "  sdot za.s[w8, 1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}          \n"
    "  sdot za.s[w8, 2, VGx2], {z2.h-z3.h}, {z2.h-z3.h}          \n"
    "  sdot za.s[w8, 3, VGx2], {z2.h-z3.h}, {z2.h-z3.h}          \n"
    "  sdot za.s[w8, 4, VGx2], {z4.h-z5.h}, {z4.h-z5.h}          \n"
    "  sdot za.s[w8, 5, VGx2], {z4.h-z5.h}, {z4.h-z5.h}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*6.0*(double)n_iterations;
}


static double sdot_za_i32_i16_vgx2_ilp7(const void*) {
  // SDOT (I16 to I32, 2-way, two vectors), Dot Product (integer)
  //
  // Each instruction: (64x i16, 64x i16) → 32x i32 (128 OPs)
  // Total of 896 OPs per loop iteration, ILP = 7
  size_t n_iterations = N_ITERATIONS/7;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  sdot za.s[w8, 0, VGx2], {z0.h-z1.h}, {z0.h-z1.h}          \n"
    "  sdot za.s[w8, 1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}          \n"
    "  sdot za.s[w8, 2, VGx2], {z2.h-z3.h}, {z2.h-z3.h}          \n"
    "  sdot za.s[w8, 3, VGx2], {z2.h-z3.h}, {z2.h-z3.h}          \n"
    "  sdot za.s[w8, 4, VGx2], {z4.h-z5.h}, {z4.h-z5.h}          \n"
    "  sdot za.s[w8, 5, VGx2], {z4.h-z5.h}, {z4.h-z5.h}          \n"
    "  sdot za.s[w8, 6, VGx2], {z6.h-z7.h}, {z6.h-z7.h}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*7.0*(double)n_iterations;
}


static double sdot_za_i32_i16_vgx2_ilp8(const void*) {
  // SDOT (I16 to I32, 2-way, two vectors), Dot Product (integer)
  //
  // Each instruction: (64x i16, 64x i16) → 32x i32 (128 OPs)
  // Total of 1024 OPs per loop iteration, ILP = 8
  size_t n_iterations = N_ITERATIONS/8;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  sdot za.s[w8, 0, VGx2], {z0.h-z1.h}, {z0.h-z1.h}          \n"
    "  sdot za.s[w8, 1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}          \n"
    "  sdot za.s[w8, 2, VGx2], {z2.h-z3.h}, {z2.h-z3.h}          \n"
    "  sdot za.s[w8, 3, VGx2], {z2.h-z3.h}, {z2.h-z3.h}          \n"
    "  sdot za.s[w8, 4, VGx2], {z4.h-z5.h}, {z4.h-z5.h}          \n"
    "  sdot za.s[w8, 5, VGx2], {z4.h-z5.h}, {z4.h-z5.h}          \n"
    "  sdot za.s[w8, 6, VGx2], {z6.h-z7.h}, {z6.h-z7.h}          \n"
    "  sdot za.s[w8, 7, VGx2], {z6.h-z7.h}, {z6.h-z7.h}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*8.0*(double)n_iterations;
}


static double sdot_za_i32_i16_vgx2_ilp9(const void*) {
  // SDOT (I16 to I32, 2-way, two vectors), Dot Product (integer)
  //
  // Each instruction: (64x i16, 64x i16) → 32x i32 (128 OPs)
  // Total of 1152 OPs per loop iteration, ILP = 9
  size_t n_iterations = N_ITERATIONS/9;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  sdot za.s[w8, 0, VGx2], {z0.h-z1.h}, {z0.h-z1.h}          \n"
    "  sdot za.s[w8, 1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}          \n"
    "  sdot za.s[w8, 2, VGx2], {z2.h-z3.h}, {z2.h-z3.h}          \n"
    "  sdot za.s[w8, 3, VGx2], {z2.h-z3.h}, {z2.h-z3.h}          \n"
    "  sdot za.s[w8, 4, VGx2], {z4.h-z5.h}, {z4.h-z5.h}          \n"
    "  sdot za.s[w8, 5, VGx2], {z4.h-z5.h}, {z4.h-z5.h}          \n"
    "  sdot za.s[w8, 6, VGx2], {z6.h-z7.h}, {z6.h-z7.h}          \n"
    "  sdot za.s[w8, 7, VGx2], {z6.h-z7.h}, {z6.h-z7.h}          \n"
    "  sdot za.s[w9, 0, VGx2], {z8.h-z9.h}, {z8.h-z9.h}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*9.0*(double)n_iterations;
}


static double sdot_za_i32_i16_vgx2_ilp10(const void*) {
  // SDOT (I16 to I32, 2-way, two vectors), Dot Product (integer)
  //
  // Each instruction: (64x i16, 64x i16) → 32x i32 (128 OPs)
  // Total of 1280 OPs per loop iteration, ILP = 10
  size_t n_iterations = N_ITERATIONS/10;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  sdot za.s[w8, 0, VGx2], {z0.h-z1.h}, {z0.h-z1.h}          \n"
    "  sdot za.s[w8, 1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}          \n"
    "  sdot za.s[w8, 2, VGx2], {z2.h-z3.h}, {z2.h-z3.h}          \n"
    "  sdot za.s[w8, 3, VGx2], {z2.h-z3.h}, {z2.h-z3.h}          \n"
    "  sdot za.s[w8, 4, VGx2], {z4.h-z5.h}, {z4.h-z5.h}          \n"
    "  sdot za.s[w8, 5, VGx2], {z4.h-z5.h}, {z4.h-z5.h}          \n"
    "  sdot za.s[w8, 6, VGx2], {z6.h-z7.h}, {z6.h-z7.h}          \n"
    "  sdot za.s[w8, 7, VGx2], {z6.h-z7.h}, {z6.h-z7.h}          \n"
    "  sdot za.s[w9, 0, VGx2], {z8.h-z9.h}, {z8.h-z9.h}          \n"
    "  sdot za.s[w9, 1, VGx2], {z8.h-z9.h}, {z8.h-z9.h}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*10.0*(double)n_iterations;
}


static double sdot_za_i32_i16_vgx2_ilp11(const void*) {
  // SDOT (I16 to I32, 2-way, two vectors), Dot Product (integer)
  //
  // Each instruction: (64x i16, 64x i16) → 32x i32 (128 OPs)
  // Total of 1408 OPs per loop iteration, ILP = 11
  size_t n_iterations = N_ITERATIONS/11;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  sdot za.s[w8, 0, VGx2], {z0.h-z1.h}, {z0.h-z1.h}          \n"
    "  sdot za.s[w8, 1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}          \n"
    "  sdot za.s[w8, 2, VGx2], {z2.h-z3.h}, {z2.h-z3.h}          \n"
    "  sdot za.s[w8, 3, VGx2], {z2.h-z3.h}, {z2.h-z3.h}          \n"
    "  sdot za.s[w8, 4, VGx2], {z4.h-z5.h}, {z4.h-z5.h}          \n"
    "  sdot za.s[w8, 5, VGx2], {z4.h-z5.h}, {z4.h-z5.h}          \n"
    "  sdot za.s[w8, 6, VGx2], {z6.h-z7.h}, {z6.h-z7.h}          \n"
    "  sdot za.s[w8, 7, VGx2], {z6.h-z7.h}, {z6.h-z7.h}          \n"
    "  sdot za.s[w9, 0, VGx2], {z8.h-z9.h}, {z8.h-z9.h}          \n"
    "  sdot za.s[w9, 1, VGx2], {z8.h-z9.h}, {z8.h-z9.h}          \n"
    "  sdot za.s[w9, 2, VGx2], {z10.h-z11.h}, {z10.h-z11.h}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*11.0*(double)n_iterations;
}


static double sdot_za_i32_i16_vgx2_ilp12(const void*) {
  // SDOT (I16 to I32, 2-way, two vectors), Dot Product (integer)
  //
  // Each instruction: (64x i16, 64x i16) → 32x i32 (128 OPs)
  // Total of 1536 OPs per loop iteration, ILP = 12
  size_t n_iterations = N_ITERATIONS/12;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  sdot za.s[w8, 0, VGx2], {z0.h-z1.h}, {z0.h-z1.h}          \n"
    "  sdot za.s[w8, 1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}          \n"
    "  sdot za.s[w8, 2, VGx2], {z2.h-z3.h}, {z2.h-z3.h}          \n"
    "  sdot za.s[w8, 3, VGx2], {z2.h-z3.h}, {z2.h-z3.h}          \n"
    "  sdot za.s[w8, 4, VGx2], {z4.h-z5.h}, {z4.h-z5.h}          \n"
    "  sdot za.s[w8, 5, VGx2], {z4.h-z5.h}, {z4.h-z5.h}          \n"
    "  sdot za.s[w8, 6, VGx2], {z6.h-z7.h}, {z6.h-z7.h}          \n"
    "  sdot za.s[w8, 7, VGx2], {z6.h-z7.h}, {z6.h-z7.h}          \n"
    "  sdot za.s[w9, 0, VGx2], {z8.h-z9.h}, {z8.h-z9.h}          \n"
    "  sdot za.s[w9, 1, VGx2], {z8.h-z9.h}, {z8.h-z9.h}          \n"
    "  sdot za.s[w9, 2, VGx2], {z10.h-z11.h}, {z10.h-z11.h}      \n"
    "  sdot za.s[w9, 3, VGx2], {z10.h-z11.h}, {z10.h-z11.h}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*12.0*(double)n_iterations;
}


static double sdot_za_i32_i16_vgx2_ilp13(const void*) {
  // SDOT (I16 to I32, 2-way, two vectors), Dot Product (integer)
  //
  // Each instruction: (64x i16, 64x i16) → 32x i32 (128 OPs)
  // Total of 1664 OPs per loop iteration, ILP = 13
  size_t n_iterations = N_ITERATIONS/13;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  sdot za.s[w8, 0, VGx2], {z0.h-z1.h}, {z0.h-z1.h}          \n"
    "  sdot za.s[w8, 1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}          \n"
    "  sdot za.s[w8, 2, VGx2], {z2.h-z3.h}, {z2.h-z3.h}          \n"
    "  sdot za.s[w8, 3, VGx2], {z2.h-z3.h}, {z2.h-z3.h}          \n"
    "  sdot za.s[w8, 4, VGx2], {z4.h-z5.h}, {z4.h-z5.h}          \n"
    "  sdot za.s[w8, 5, VGx2], {z4.h-z5.h}, {z4.h-z5.h}          \n"
    "  sdot za.s[w8, 6, VGx2], {z6.h-z7.h}, {z6.h-z7.h}          \n"
    "  sdot za.s[w8, 7, VGx2], {z6.h-z7.h}, {z6.h-z7.h}          \n"
    "  sdot za.s[w9, 0, VGx2], {z8.h-z9.h}, {z8.h-z9.h}          \n"
    "  sdot za.s[w9, 1, VGx2], {z8.h-z9.h}, {z8.h-z9.h}          \n"
    "  sdot za.s[w9, 2, VGx2], {z10.h-z11.h}, {z10.h-z11.h}      \n"
    "  sdot za.s[w9, 3, VGx2], {z10.h-z11.h}, {z10.h-z11.h}      \n"
    "  sdot za.s[w9, 4, VGx2], {z12.h-z13.h}, {z12.h-z13.h}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*13.0*(double)n_iterations;
}


static double sdot_za_i32_i16_vgx2_ilp14(const void*) {
  // SDOT (I16 to I32, 2-way, two vectors), Dot Product (integer)
  //
  // Each instruction: (64x i16, 64x i16) → 32x i32 (128 OPs)
  // Total of 1792 OPs per loop iteration, ILP = 14
  size_t n_iterations = N_ITERATIONS/14;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  sdot za.s[w8, 0, VGx2], {z0.h-z1.h}, {z0.h-z1.h}          \n"
    "  sdot za.s[w8, 1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}          \n"
    "  sdot za.s[w8, 2, VGx2], {z2.h-z3.h}, {z2.h-z3.h}          \n"
    "  sdot za.s[w8, 3, VGx2], {z2.h-z3.h}, {z2.h-z3.h}          \n"
    "  sdot za.s[w8, 4, VGx2], {z4.h-z5.h}, {z4.h-z5.h}          \n"
    "  sdot za.s[w8, 5, VGx2], {z4.h-z5.h}, {z4.h-z5.h}          \n"
    "  sdot za.s[w8, 6, VGx2], {z6.h-z7.h}, {z6.h-z7.h}          \n"
    "  sdot za.s[w8, 7, VGx2], {z6.h-z7.h}, {z6.h-z7.h}          \n"
    "  sdot za.s[w9, 0, VGx2], {z8.h-z9.h}, {z8.h-z9.h}          \n"
    "  sdot za.s[w9, 1, VGx2], {z8.h-z9.h}, {z8.h-z9.h}          \n"
    "  sdot za.s[w9, 2, VGx2], {z10.h-z11.h}, {z10.h-z11.h}      \n"
    "  sdot za.s[w9, 3, VGx2], {z10.h-z11.h}, {z10.h-z11.h}      \n"
    "  sdot za.s[w9, 4, VGx2], {z12.h-z13.h}, {z12.h-z13.h}      \n"
    "  sdot za.s[w9, 5, VGx2], {z12.h-z13.h}, {z12.h-z13.h}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*14.0*(double)n_iterations;
}


static double sdot_za_i32_i16_vgx2_ilp15(const void*) {
  // SDOT (I16 to I32, 2-way, two vectors), Dot Product (integer)
  //
  // Each instruction: (64x i16, 64x i16) → 32x i32 (128 OPs)
  // Total of 1920 OPs per loop iteration, ILP = 15
  size_t n_iterations = N_ITERATIONS/15;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  sdot za.s[w8, 0, VGx2], {z0.h-z1.h}, {z0.h-z1.h}          \n"
    "  sdot za.s[w8, 1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}          \n"
    "  sdot za.s[w8, 2, VGx2], {z2.h-z3.h}, {z2.h-z3.h}          \n"
    "  sdot za.s[w8, 3, VGx2], {z2.h-z3.h}, {z2.h-z3.h}          \n"
    "  sdot za.s[w8, 4, VGx2], {z4.h-z5.h}, {z4.h-z5.h}          \n"
    "  sdot za.s[w8, 5, VGx2], {z4.h-z5.h}, {z4.h-z5.h}          \n"
    "  sdot za.s[w8, 6, VGx2], {z6.h-z7.h}, {z6.h-z7.h}          \n"
    "  sdot za.s[w8, 7, VGx2], {z6.h-z7.h}, {z6.h-z7.h}          \n"
    "  sdot za.s[w9, 0, VGx2], {z8.h-z9.h}, {z8.h-z9.h}          \n"
    "  sdot za.s[w9, 1, VGx2], {z8.h-z9.h}, {z8.h-z9.h}          \n"
    "  sdot za.s[w9, 2, VGx2], {z10.h-z11.h}, {z10.h-z11.h}      \n"
    "  sdot za.s[w9, 3, VGx2], {z10.h-z11.h}, {z10.h-z11.h}      \n"
    "  sdot za.s[w9, 4, VGx2], {z12.h-z13.h}, {z12.h-z13.h}      \n"
    "  sdot za.s[w9, 5, VGx2], {z12.h-z13.h}, {z12.h-z13.h}      \n"
    "  sdot za.s[w9, 6, VGx2], {z14.h-z15.h}, {z14.h-z15.h}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*15.0*(double)n_iterations;
}


static double sdot_za_i32_i16_vgx2_ilp16(const void*) {
  // SDOT (I16 to I32, 2-way, two vectors), Dot Product (integer)
  //
  // Each instruction: (64x i16, 64x i16) → 32x i32 (128 OPs)
  // Total of 2048 OPs per loop iteration, ILP = 16
  size_t n_iterations = N_ITERATIONS/16;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  sdot za.s[w8, 0, VGx2], {z0.h-z1.h}, {z0.h-z1.h}          \n"
    "  sdot za.s[w8, 1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}          \n"
    "  sdot za.s[w8, 2, VGx2], {z2.h-z3.h}, {z2.h-z3.h}          \n"
    "  sdot za.s[w8, 3, VGx2], {z2.h-z3.h}, {z2.h-z3.h}          \n"
    "  sdot za.s[w8, 4, VGx2], {z4.h-z5.h}, {z4.h-z5.h}          \n"
    "  sdot za.s[w8, 5, VGx2], {z4.h-z5.h}, {z4.h-z5.h}          \n"
    "  sdot za.s[w8, 6, VGx2], {z6.h-z7.h}, {z6.h-z7.h}          \n"
    "  sdot za.s[w8, 7, VGx2], {z6.h-z7.h}, {z6.h-z7.h}          \n"
    "  sdot za.s[w9, 0, VGx2], {z8.h-z9.h}, {z8.h-z9.h}          \n"
    "  sdot za.s[w9, 1, VGx2], {z8.h-z9.h}, {z8.h-z9.h}          \n"
    "  sdot za.s[w9, 2, VGx2], {z10.h-z11.h}, {z10.h-z11.h}      \n"
    "  sdot za.s[w9, 3, VGx2], {z10.h-z11.h}, {z10.h-z11.h}      \n"
    "  sdot za.s[w9, 4, VGx2], {z12.h-z13.h}, {z12.h-z13.h}      \n"
    "  sdot za.s[w9, 5, VGx2], {z12.h-z13.h}, {z12.h-z13.h}      \n"
    "  sdot za.s[w9, 6, VGx2], {z14.h-z15.h}, {z14.h-z15.h}      \n"
    "  sdot za.s[w9, 7, VGx2], {z14.h-z15.h}, {z14.h-z15.h}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*16.0*(double)n_iterations;
}


static double sdot_za_i32_i16_vgx4_ilp1(const void*) {
  // SDOT (I16 to I32, 2-way, four vectors), Dot Product (integer)
  //
  // Each instruction: (128x i16, 128x i16) → 64x i32 (256 OPs)
  // Total of 256 OPs per loop iteration, ILP = 1
  size_t n_iterations = N_ITERATIONS;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  sdot za.s[w8, 0, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*1.0*(double)n_iterations;
}


static double sdot_za_i32_i16_vgx4_ilp2(const void*) {
  // SDOT (I16 to I32, 2-way, four vectors), Dot Product (integer)
  //
  // Each instruction: (128x i16, 128x i16) → 64x i32 (256 OPs)
  // Total of 512 OPs per loop iteration, ILP = 2
  size_t n_iterations = N_ITERATIONS/2;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  sdot za.s[w8, 0, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.s[w8, 1, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*2.0*(double)n_iterations;
}


static double sdot_za_i32_i16_vgx4_ilp3(const void*) {
  // SDOT (I16 to I32, 2-way, four vectors), Dot Product (integer)
  //
  // Each instruction: (128x i16, 128x i16) → 64x i32 (256 OPs)
  // Total of 768 OPs per loop iteration, ILP = 3
  size_t n_iterations = N_ITERATIONS/3;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  sdot za.s[w8, 0, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.s[w8, 1, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.s[w8, 2, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*3.0*(double)n_iterations;
}


static double sdot_za_i32_i16_vgx4_ilp4(const void*) {
  // SDOT (I16 to I32, 2-way, four vectors), Dot Product (integer)
  //
  // Each instruction: (128x i16, 128x i16) → 64x i32 (256 OPs)
  // Total of 1024 OPs per loop iteration, ILP = 4
  size_t n_iterations = N_ITERATIONS/4;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  sdot za.s[w8, 0, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.s[w8, 1, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.s[w8, 2, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.s[w8, 3, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*4.0*(double)n_iterations;
}


static double sdot_za_i32_i16_vgx4_ilp5(const void*) {
  // SDOT (I16 to I32, 2-way, four vectors), Dot Product (integer)
  //
  // Each instruction: (128x i16, 128x i16) → 64x i32 (256 OPs)
  // Total of 1280 OPs per loop iteration, ILP = 5
  size_t n_iterations = N_ITERATIONS/5;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  sdot za.s[w8, 0, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.s[w8, 1, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.s[w8, 2, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.s[w8, 3, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.s[w8, 4, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*5.0*(double)n_iterations;
}


static double sdot_za_i32_i16_vgx4_ilp6(const void*) {
  // SDOT (I16 to I32, 2-way, four vectors), Dot Product (integer)
  //
  // Each instruction: (128x i16, 128x i16) → 64x i32 (256 OPs)
  // Total of 1536 OPs per loop iteration, ILP = 6
  size_t n_iterations = N_ITERATIONS/6;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  sdot za.s[w8, 0, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.s[w8, 1, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.s[w8, 2, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.s[w8, 3, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.s[w8, 4, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  sdot za.s[w8, 5, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*6.0*(double)n_iterations;
}


static double sdot_za_i32_i16_vgx4_ilp7(const void*) {
  // SDOT (I16 to I32, 2-way, four vectors), Dot Product (integer)
  //
  // Each instruction: (128x i16, 128x i16) → 64x i32 (256 OPs)
  // Total of 1792 OPs per loop iteration, ILP = 7
  size_t n_iterations = N_ITERATIONS/7;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  sdot za.s[w8, 0, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.s[w8, 1, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.s[w8, 2, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.s[w8, 3, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.s[w8, 4, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  sdot za.s[w8, 5, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  sdot za.s[w8, 6, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*7.0*(double)n_iterations;
}


static double sdot_za_i32_i16_vgx4_ilp8(const void*) {
  // SDOT (I16 to I32, 2-way, four vectors), Dot Product (integer)
  //
  // Each instruction: (128x i16, 128x i16) → 64x i32 (256 OPs)
  // Total of 2048 OPs per loop iteration, ILP = 8
  size_t n_iterations = N_ITERATIONS/8;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  sdot za.s[w8, 0, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.s[w8, 1, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.s[w8, 2, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.s[w8, 3, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.s[w8, 4, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  sdot za.s[w8, 5, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  sdot za.s[w8, 6, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  sdot za.s[w8, 7, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*8.0*(double)n_iterations;
}


static double sdot_za_i32_i16_vgx4_ilp9(const void*) {
  // SDOT (I16 to I32, 2-way, four vectors), Dot Product (integer)
  //
  // Each instruction: (128x i16, 128x i16) → 64x i32 (256 OPs)
  // Total of 2304 OPs per loop iteration, ILP = 9
  size_t n_iterations = N_ITERATIONS/9;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  sdot za.s[w8, 0, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.s[w8, 1, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.s[w8, 2, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.s[w8, 3, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.s[w8, 4, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  sdot za.s[w8, 5, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  sdot za.s[w8, 6, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  sdot za.s[w8, 7, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  sdot za.s[w9, 0, VGx4], {z8.h-z11.h}, {z8.h-z11.h}        \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*9.0*(double)n_iterations;
}


static double sdot_za_i32_i16_vgx4_ilp10(const void*) {
  // SDOT (I16 to I32, 2-way, four vectors), Dot Product (integer)
  //
  // Each instruction: (128x i16, 128x i16) → 64x i32 (256 OPs)
  // Total of 2560 OPs per loop iteration, ILP = 10
  size_t n_iterations = N_ITERATIONS/10;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  sdot za.s[w8, 0, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.s[w8, 1, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.s[w8, 2, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.s[w8, 3, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.s[w8, 4, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  sdot za.s[w8, 5, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  sdot za.s[w8, 6, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  sdot za.s[w8, 7, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  sdot za.s[w9, 0, VGx4], {z8.h-z11.h}, {z8.h-z11.h}        \n"
    "  sdot za.s[w9, 1, VGx4], {z8.h-z11.h}, {z8.h-z11.h}        \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*10.0*(double)n_iterations;
}


static double sdot_za_i32_i16_vgx4_ilp11(const void*) {
  // SDOT (I16 to I32, 2-way, four vectors), Dot Product (integer)
  //
  // Each instruction: (128x i16, 128x i16) → 64x i32 (256 OPs)
  // Total of 2816 OPs per loop iteration, ILP = 11
  size_t n_iterations = N_ITERATIONS/11;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  sdot za.s[w8, 0, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.s[w8, 1, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.s[w8, 2, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.s[w8, 3, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.s[w8, 4, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  sdot za.s[w8, 5, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  sdot za.s[w8, 6, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  sdot za.s[w8, 7, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  sdot za.s[w9, 0, VGx4], {z8.h-z11.h}, {z8.h-z11.h}        \n"
    "  sdot za.s[w9, 1, VGx4], {z8.h-z11.h}, {z8.h-z11.h}        \n"
    "  sdot za.s[w9, 2, VGx4], {z8.h-z11.h}, {z8.h-z11.h}        \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*11.0*(double)n_iterations;
}


static double sdot_za_i32_i16_vgx4_ilp12(const void*) {
  // SDOT (I16 to I32, 2-way, four vectors), Dot Product (integer)
  //
  // Each instruction: (128x i16, 128x i16) → 64x i32 (256 OPs)
  // Total of 3072 OPs per loop iteration, ILP = 12
  size_t n_iterations = N_ITERATIONS/12;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  sdot za.s[w8, 0, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.s[w8, 1, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.s[w8, 2, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.s[w8, 3, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.s[w8, 4, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  sdot za.s[w8, 5, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  sdot za.s[w8, 6, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  sdot za.s[w8, 7, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  sdot za.s[w9, 0, VGx4], {z8.h-z11.h}, {z8.h-z11.h}        \n"
    "  sdot za.s[w9, 1, VGx4], {z8.h-z11.h}, {z8.h-z11.h}        \n"
    "  sdot za.s[w9, 2, VGx4], {z8.h-z11.h}, {z8.h-z11.h}        \n"
    "  sdot za.s[w9, 3, VGx4], {z8.h-z11.h}, {z8.h-z11.h}        \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*12.0*(double)n_iterations;
}


static double sdot_za_i32_i16_vgx4_ilp13(const void*) {
  // SDOT (I16 to I32, 2-way, four vectors), Dot Product (integer)
  //
  // Each instruction: (128x i16, 128x i16) → 64x i32 (256 OPs)
  // Total of 3328 OPs per loop iteration, ILP = 13
  size_t n_iterations = N_ITERATIONS/13;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  sdot za.s[w8, 0, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.s[w8, 1, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.s[w8, 2, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.s[w8, 3, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.s[w8, 4, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  sdot za.s[w8, 5, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  sdot za.s[w8, 6, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  sdot za.s[w8, 7, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  sdot za.s[w9, 0, VGx4], {z8.h-z11.h}, {z8.h-z11.h}        \n"
    "  sdot za.s[w9, 1, VGx4], {z8.h-z11.h}, {z8.h-z11.h}        \n"
    "  sdot za.s[w9, 2, VGx4], {z8.h-z11.h}, {z8.h-z11.h}        \n"
    "  sdot za.s[w9, 3, VGx4], {z8.h-z11.h}, {z8.h-z11.h}        \n"
    "  sdot za.s[w9, 4, VGx4], {z12.h-z15.h}, {z12.h-z15.h}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*13.0*(double)n_iterations;
}


static double sdot_za_i32_i16_vgx4_ilp14(const void*) {
  // SDOT (I16 to I32, 2-way, four vectors), Dot Product (integer)
  //
  // Each instruction: (128x i16, 128x i16) → 64x i32 (256 OPs)
  // Total of 3584 OPs per loop iteration, ILP = 14
  size_t n_iterations = N_ITERATIONS/14;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  sdot za.s[w8, 0, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.s[w8, 1, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.s[w8, 2, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.s[w8, 3, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.s[w8, 4, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  sdot za.s[w8, 5, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  sdot za.s[w8, 6, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  sdot za.s[w8, 7, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  sdot za.s[w9, 0, VGx4], {z8.h-z11.h}, {z8.h-z11.h}        \n"
    "  sdot za.s[w9, 1, VGx4], {z8.h-z11.h}, {z8.h-z11.h}        \n"
    "  sdot za.s[w9, 2, VGx4], {z8.h-z11.h}, {z8.h-z11.h}        \n"
    "  sdot za.s[w9, 3, VGx4], {z8.h-z11.h}, {z8.h-z11.h}        \n"
    "  sdot za.s[w9, 4, VGx4], {z12.h-z15.h}, {z12.h-z15.h}      \n"
    "  sdot za.s[w9, 5, VGx4], {z12.h-z15.h}, {z12.h-z15.h}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*14.0*(double)n_iterations;
}


static double sdot_za_i32_i16_vgx4_ilp15(const void*) {
  // SDOT (I16 to I32, 2-way, four vectors), Dot Product (integer)
  //
  // Each instruction: (128x i16, 128x i16) → 64x i32 (256 OPs)
  // Total of 3840 OPs per loop iteration, ILP = 15
  size_t n_iterations = N_ITERATIONS/15;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  sdot za.s[w8, 0, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.s[w8, 1, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.s[w8, 2, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.s[w8, 3, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.s[w8, 4, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  sdot za.s[w8, 5, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  sdot za.s[w8, 6, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  sdot za.s[w8, 7, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  sdot za.s[w9, 0, VGx4], {z8.h-z11.h}, {z8.h-z11.h}        \n"
    "  sdot za.s[w9, 1, VGx4], {z8.h-z11.h}, {z8.h-z11.h}        \n"
    "  sdot za.s[w9, 2, VGx4], {z8.h-z11.h}, {z8.h-z11.h}        \n"
    "  sdot za.s[w9, 3, VGx4], {z8.h-z11.h}, {z8.h-z11.h}        \n"
    "  sdot za.s[w9, 4, VGx4], {z12.h-z15.h}, {z12.h-z15.h}      \n"
    "  sdot za.s[w9, 5, VGx4], {z12.h-z15.h}, {z12.h-z15.h}      \n"
    "  sdot za.s[w9, 6, VGx4], {z12.h-z15.h}, {z12.h-z15.h}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*15.0*(double)n_iterations;
}


static double sdot_za_i32_i16_vgx4_ilp16(const void*) {
  // SDOT (I16 to I32, 2-way, four vectors), Dot Product (integer)
  //
  // Each instruction: (128x i16, 128x i16) → 64x i32 (256 OPs)
  // Total of 4096 OPs per loop iteration, ILP = 16
  size_t n_iterations = N_ITERATIONS/16;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  sdot za.s[w8, 0, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.s[w8, 1, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.s[w8, 2, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.s[w8, 3, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.s[w8, 4, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  sdot za.s[w8, 5, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  sdot za.s[w8, 6, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  sdot za.s[w8, 7, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  sdot za.s[w9, 0, VGx4], {z8.h-z11.h}, {z8.h-z11.h}        \n"
    "  sdot za.s[w9, 1, VGx4], {z8.h-z11.h}, {z8.h-z11.h}        \n"
    "  sdot za.s[w9, 2, VGx4], {z8.h-z11.h}, {z8.h-z11.h}        \n"
    "  sdot za.s[w9, 3, VGx4], {z8.h-z11.h}, {z8.h-z11.h}        \n"
    "  sdot za.s[w9, 4, VGx4], {z12.h-z15.h}, {z12.h-z15.h}      \n"
    "  sdot za.s[w9, 5, VGx4], {z12.h-z15.h}, {z12.h-z15.h}      \n"
    "  sdot za.s[w9, 6, VGx4], {z12.h-z15.h}, {z12.h-z15.h}      \n"
    "  sdot za.s[w9, 7, VGx4], {z12.h-z15.h}, {z12.h-z15.h}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*16.0*(double)n_iterations;
}


static double sdot_za_i32_i8_vgx2_ilp1(const void*) {
  // SDOT (I8 to I32, 4-way, two vectors), Dot Product (integer)
  //
  // Each instruction: (128x i8, 128x i8) → 32x i32 (256 OPs)
  // Total of 256 OPs per loop iteration, ILP = 1
  size_t n_iterations = N_ITERATIONS;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  sdot za.s[w8, 0, VGx2], {z0.b-z1.b}, {z0.b-z1.b}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*1.0*(double)n_iterations;
}


static double sdot_za_i32_i8_vgx2_ilp2(const void*) {
  // SDOT (I8 to I32, 4-way, two vectors), Dot Product (integer)
  //
  // Each instruction: (128x i8, 128x i8) → 32x i32 (256 OPs)
  // Total of 512 OPs per loop iteration, ILP = 2
  size_t n_iterations = N_ITERATIONS/2;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  sdot za.s[w8, 0, VGx2], {z0.b-z1.b}, {z0.b-z1.b}          \n"
    "  sdot za.s[w8, 1, VGx2], {z0.b-z1.b}, {z0.b-z1.b}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*2.0*(double)n_iterations;
}


static double sdot_za_i32_i8_vgx2_ilp3(const void*) {
  // SDOT (I8 to I32, 4-way, two vectors), Dot Product (integer)
  //
  // Each instruction: (128x i8, 128x i8) → 32x i32 (256 OPs)
  // Total of 768 OPs per loop iteration, ILP = 3
  size_t n_iterations = N_ITERATIONS/3;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  sdot za.s[w8, 0, VGx2], {z0.b-z1.b}, {z0.b-z1.b}          \n"
    "  sdot za.s[w8, 1, VGx2], {z0.b-z1.b}, {z0.b-z1.b}          \n"
    "  sdot za.s[w8, 2, VGx2], {z2.b-z3.b}, {z2.b-z3.b}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*3.0*(double)n_iterations;
}


static double sdot_za_i32_i8_vgx2_ilp4(const void*) {
  // SDOT (I8 to I32, 4-way, two vectors), Dot Product (integer)
  //
  // Each instruction: (128x i8, 128x i8) → 32x i32 (256 OPs)
  // Total of 1024 OPs per loop iteration, ILP = 4
  size_t n_iterations = N_ITERATIONS/4;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  sdot za.s[w8, 0, VGx2], {z0.b-z1.b}, {z0.b-z1.b}          \n"
    "  sdot za.s[w8, 1, VGx2], {z0.b-z1.b}, {z0.b-z1.b}          \n"
    "  sdot za.s[w8, 2, VGx2], {z2.b-z3.b}, {z2.b-z3.b}          \n"
    "  sdot za.s[w8, 3, VGx2], {z2.b-z3.b}, {z2.b-z3.b}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*4.0*(double)n_iterations;
}


static double sdot_za_i32_i8_vgx2_ilp5(const void*) {
  // SDOT (I8 to I32, 4-way, two vectors), Dot Product (integer)
  //
  // Each instruction: (128x i8, 128x i8) → 32x i32 (256 OPs)
  // Total of 1280 OPs per loop iteration, ILP = 5
  size_t n_iterations = N_ITERATIONS/5;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  sdot za.s[w8, 0, VGx2], {z0.b-z1.b}, {z0.b-z1.b}          \n"
    "  sdot za.s[w8, 1, VGx2], {z0.b-z1.b}, {z0.b-z1.b}          \n"
    "  sdot za.s[w8, 2, VGx2], {z2.b-z3.b}, {z2.b-z3.b}          \n"
    "  sdot za.s[w8, 3, VGx2], {z2.b-z3.b}, {z2.b-z3.b}          \n"
    "  sdot za.s[w8, 4, VGx2], {z4.b-z5.b}, {z4.b-z5.b}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*5.0*(double)n_iterations;
}


static double sdot_za_i32_i8_vgx2_ilp6(const void*) {
  // SDOT (I8 to I32, 4-way, two vectors), Dot Product (integer)
  //
  // Each instruction: (128x i8, 128x i8) → 32x i32 (256 OPs)
  // Total of 1536 OPs per loop iteration, ILP = 6
  size_t n_iterations = N_ITERATIONS/6;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  sdot za.s[w8, 0, VGx2], {z0.b-z1.b}, {z0.b-z1.b}          \n"
    "  sdot za.s[w8, 1, VGx2], {z0.b-z1.b}, {z0.b-z1.b}          \n"
    "  sdot za.s[w8, 2, VGx2], {z2.b-z3.b}, {z2.b-z3.b}          \n"
    "  sdot za.s[w8, 3, VGx2], {z2.b-z3.b}, {z2.b-z3.b}          \n"
    "  sdot za.s[w8, 4, VGx2], {z4.b-z5.b}, {z4.b-z5.b}          \n"
    "  sdot za.s[w8, 5, VGx2], {z4.b-z5.b}, {z4.b-z5.b}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*6.0*(double)n_iterations;
}


static double sdot_za_i32_i8_vgx2_ilp7(const void*) {
  // SDOT (I8 to I32, 4-way, two vectors), Dot Product (integer)
  //
  // Each instruction: (128x i8, 128x i8) → 32x i32 (256 OPs)
  // Total of 1792 OPs per loop iteration, ILP = 7
  size_t n_iterations = N_ITERATIONS/7;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  sdot za.s[w8, 0, VGx2], {z0.b-z1.b}, {z0.b-z1.b}          \n"
    "  sdot za.s[w8, 1, VGx2], {z0.b-z1.b}, {z0.b-z1.b}          \n"
    "  sdot za.s[w8, 2, VGx2], {z2.b-z3.b}, {z2.b-z3.b}          \n"
    "  sdot za.s[w8, 3, VGx2], {z2.b-z3.b}, {z2.b-z3.b}          \n"
    "  sdot za.s[w8, 4, VGx2], {z4.b-z5.b}, {z4.b-z5.b}          \n"
    "  sdot za.s[w8, 5, VGx2], {z4.b-z5.b}, {z4.b-z5.b}          \n"
    "  sdot za.s[w8, 6, VGx2], {z6.b-z7.b}, {z6.b-z7.b}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*7.0*(double)n_iterations;
}


static double sdot_za_i32_i8_vgx2_ilp8(const void*) {
  // SDOT (I8 to I32, 4-way, two vectors), Dot Product (integer)
  //
  // Each instruction: (128x i8, 128x i8) → 32x i32 (256 OPs)
  // Total of 2048 OPs per loop iteration, ILP = 8
  size_t n_iterations = N_ITERATIONS/8;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  sdot za.s[w8, 0, VGx2], {z0.b-z1.b}, {z0.b-z1.b}          \n"
    "  sdot za.s[w8, 1, VGx2], {z0.b-z1.b}, {z0.b-z1.b}          \n"
    "  sdot za.s[w8, 2, VGx2], {z2.b-z3.b}, {z2.b-z3.b}          \n"
    "  sdot za.s[w8, 3, VGx2], {z2.b-z3.b}, {z2.b-z3.b}          \n"
    "  sdot za.s[w8, 4, VGx2], {z4.b-z5.b}, {z4.b-z5.b}          \n"
    "  sdot za.s[w8, 5, VGx2], {z4.b-z5.b}, {z4.b-z5.b}          \n"
    "  sdot za.s[w8, 6, VGx2], {z6.b-z7.b}, {z6.b-z7.b}          \n"
    "  sdot za.s[w8, 7, VGx2], {z6.b-z7.b}, {z6.b-z7.b}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*8.0*(double)n_iterations;
}


static double sdot_za_i32_i8_vgx2_ilp9(const void*) {
  // SDOT (I8 to I32, 4-way, two vectors), Dot Product (integer)
  //
  // Each instruction: (128x i8, 128x i8) → 32x i32 (256 OPs)
  // Total of 2304 OPs per loop iteration, ILP = 9
  size_t n_iterations = N_ITERATIONS/9;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  sdot za.s[w8, 0, VGx2], {z0.b-z1.b}, {z0.b-z1.b}          \n"
    "  sdot za.s[w8, 1, VGx2], {z0.b-z1.b}, {z0.b-z1.b}          \n"
    "  sdot za.s[w8, 2, VGx2], {z2.b-z3.b}, {z2.b-z3.b}          \n"
    "  sdot za.s[w8, 3, VGx2], {z2.b-z3.b}, {z2.b-z3.b}          \n"
    "  sdot za.s[w8, 4, VGx2], {z4.b-z5.b}, {z4.b-z5.b}          \n"
    "  sdot za.s[w8, 5, VGx2], {z4.b-z5.b}, {z4.b-z5.b}          \n"
    "  sdot za.s[w8, 6, VGx2], {z6.b-z7.b}, {z6.b-z7.b}          \n"
    "  sdot za.s[w8, 7, VGx2], {z6.b-z7.b}, {z6.b-z7.b}          \n"
    "  sdot za.s[w9, 0, VGx2], {z8.b-z9.b}, {z8.b-z9.b}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*9.0*(double)n_iterations;
}


static double sdot_za_i32_i8_vgx2_ilp10(const void*) {
  // SDOT (I8 to I32, 4-way, two vectors), Dot Product (integer)
  //
  // Each instruction: (128x i8, 128x i8) → 32x i32 (256 OPs)
  // Total of 2560 OPs per loop iteration, ILP = 10
  size_t n_iterations = N_ITERATIONS/10;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  sdot za.s[w8, 0, VGx2], {z0.b-z1.b}, {z0.b-z1.b}          \n"
    "  sdot za.s[w8, 1, VGx2], {z0.b-z1.b}, {z0.b-z1.b}          \n"
    "  sdot za.s[w8, 2, VGx2], {z2.b-z3.b}, {z2.b-z3.b}          \n"
    "  sdot za.s[w8, 3, VGx2], {z2.b-z3.b}, {z2.b-z3.b}          \n"
    "  sdot za.s[w8, 4, VGx2], {z4.b-z5.b}, {z4.b-z5.b}          \n"
    "  sdot za.s[w8, 5, VGx2], {z4.b-z5.b}, {z4.b-z5.b}          \n"
    "  sdot za.s[w8, 6, VGx2], {z6.b-z7.b}, {z6.b-z7.b}          \n"
    "  sdot za.s[w8, 7, VGx2], {z6.b-z7.b}, {z6.b-z7.b}          \n"
    "  sdot za.s[w9, 0, VGx2], {z8.b-z9.b}, {z8.b-z9.b}          \n"
    "  sdot za.s[w9, 1, VGx2], {z8.b-z9.b}, {z8.b-z9.b}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*10.0*(double)n_iterations;
}


static double sdot_za_i32_i8_vgx2_ilp11(const void*) {
  // SDOT (I8 to I32, 4-way, two vectors), Dot Product (integer)
  //
  // Each instruction: (128x i8, 128x i8) → 32x i32 (256 OPs)
  // Total of 2816 OPs per loop iteration, ILP = 11
  size_t n_iterations = N_ITERATIONS/11;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  sdot za.s[w8, 0, VGx2], {z0.b-z1.b}, {z0.b-z1.b}          \n"
    "  sdot za.s[w8, 1, VGx2], {z0.b-z1.b}, {z0.b-z1.b}          \n"
    "  sdot za.s[w8, 2, VGx2], {z2.b-z3.b}, {z2.b-z3.b}          \n"
    "  sdot za.s[w8, 3, VGx2], {z2.b-z3.b}, {z2.b-z3.b}          \n"
    "  sdot za.s[w8, 4, VGx2], {z4.b-z5.b}, {z4.b-z5.b}          \n"
    "  sdot za.s[w8, 5, VGx2], {z4.b-z5.b}, {z4.b-z5.b}          \n"
    "  sdot za.s[w8, 6, VGx2], {z6.b-z7.b}, {z6.b-z7.b}          \n"
    "  sdot za.s[w8, 7, VGx2], {z6.b-z7.b}, {z6.b-z7.b}          \n"
    "  sdot za.s[w9, 0, VGx2], {z8.b-z9.b}, {z8.b-z9.b}          \n"
    "  sdot za.s[w9, 1, VGx2], {z8.b-z9.b}, {z8.b-z9.b}          \n"
    "  sdot za.s[w9, 2, VGx2], {z10.b-z11.b}, {z10.b-z11.b}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*11.0*(double)n_iterations;
}


static double sdot_za_i32_i8_vgx2_ilp12(const void*) {
  // SDOT (I8 to I32, 4-way, two vectors), Dot Product (integer)
  //
  // Each instruction: (128x i8, 128x i8) → 32x i32 (256 OPs)
  // Total of 3072 OPs per loop iteration, ILP = 12
  size_t n_iterations = N_ITERATIONS/12;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  sdot za.s[w8, 0, VGx2], {z0.b-z1.b}, {z0.b-z1.b}          \n"
    "  sdot za.s[w8, 1, VGx2], {z0.b-z1.b}, {z0.b-z1.b}          \n"
    "  sdot za.s[w8, 2, VGx2], {z2.b-z3.b}, {z2.b-z3.b}          \n"
    "  sdot za.s[w8, 3, VGx2], {z2.b-z3.b}, {z2.b-z3.b}          \n"
    "  sdot za.s[w8, 4, VGx2], {z4.b-z5.b}, {z4.b-z5.b}          \n"
    "  sdot za.s[w8, 5, VGx2], {z4.b-z5.b}, {z4.b-z5.b}          \n"
    "  sdot za.s[w8, 6, VGx2], {z6.b-z7.b}, {z6.b-z7.b}          \n"
    "  sdot za.s[w8, 7, VGx2], {z6.b-z7.b}, {z6.b-z7.b}          \n"
    "  sdot za.s[w9, 0, VGx2], {z8.b-z9.b}, {z8.b-z9.b}          \n"
    "  sdot za.s[w9, 1, VGx2], {z8.b-z9.b}, {z8.b-z9.b}          \n"
    "  sdot za.s[w9, 2, VGx2], {z10.b-z11.b}, {z10.b-z11.b}      \n"
    "  sdot za.s[w9, 3, VGx2], {z10.b-z11.b}, {z10.b-z11.b}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*12.0*(double)n_iterations;
}


static double sdot_za_i32_i8_vgx2_ilp13(const void*) {
  // SDOT (I8 to I32, 4-way, two vectors), Dot Product (integer)
  //
  // Each instruction: (128x i8, 128x i8) → 32x i32 (256 OPs)
  // Total of 3328 OPs per loop iteration, ILP = 13
  size_t n_iterations = N_ITERATIONS/13;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  sdot za.s[w8, 0, VGx2], {z0.b-z1.b}, {z0.b-z1.b}          \n"
    "  sdot za.s[w8, 1, VGx2], {z0.b-z1.b}, {z0.b-z1.b}          \n"
    "  sdot za.s[w8, 2, VGx2], {z2.b-z3.b}, {z2.b-z3.b}          \n"
    "  sdot za.s[w8, 3, VGx2], {z2.b-z3.b}, {z2.b-z3.b}          \n"
    "  sdot za.s[w8, 4, VGx2], {z4.b-z5.b}, {z4.b-z5.b}          \n"
    "  sdot za.s[w8, 5, VGx2], {z4.b-z5.b}, {z4.b-z5.b}          \n"
    "  sdot za.s[w8, 6, VGx2], {z6.b-z7.b}, {z6.b-z7.b}          \n"
    "  sdot za.s[w8, 7, VGx2], {z6.b-z7.b}, {z6.b-z7.b}          \n"
    "  sdot za.s[w9, 0, VGx2], {z8.b-z9.b}, {z8.b-z9.b}          \n"
    "  sdot za.s[w9, 1, VGx2], {z8.b-z9.b}, {z8.b-z9.b}          \n"
    "  sdot za.s[w9, 2, VGx2], {z10.b-z11.b}, {z10.b-z11.b}      \n"
    "  sdot za.s[w9, 3, VGx2], {z10.b-z11.b}, {z10.b-z11.b}      \n"
    "  sdot za.s[w9, 4, VGx2], {z12.b-z13.b}, {z12.b-z13.b}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*13.0*(double)n_iterations;
}


static double sdot_za_i32_i8_vgx2_ilp14(const void*) {
  // SDOT (I8 to I32, 4-way, two vectors), Dot Product (integer)
  //
  // Each instruction: (128x i8, 128x i8) → 32x i32 (256 OPs)
  // Total of 3584 OPs per loop iteration, ILP = 14
  size_t n_iterations = N_ITERATIONS/14;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  sdot za.s[w8, 0, VGx2], {z0.b-z1.b}, {z0.b-z1.b}          \n"
    "  sdot za.s[w8, 1, VGx2], {z0.b-z1.b}, {z0.b-z1.b}          \n"
    "  sdot za.s[w8, 2, VGx2], {z2.b-z3.b}, {z2.b-z3.b}          \n"
    "  sdot za.s[w8, 3, VGx2], {z2.b-z3.b}, {z2.b-z3.b}          \n"
    "  sdot za.s[w8, 4, VGx2], {z4.b-z5.b}, {z4.b-z5.b}          \n"
    "  sdot za.s[w8, 5, VGx2], {z4.b-z5.b}, {z4.b-z5.b}          \n"
    "  sdot za.s[w8, 6, VGx2], {z6.b-z7.b}, {z6.b-z7.b}          \n"
    "  sdot za.s[w8, 7, VGx2], {z6.b-z7.b}, {z6.b-z7.b}          \n"
    "  sdot za.s[w9, 0, VGx2], {z8.b-z9.b}, {z8.b-z9.b}          \n"
    "  sdot za.s[w9, 1, VGx2], {z8.b-z9.b}, {z8.b-z9.b}          \n"
    "  sdot za.s[w9, 2, VGx2], {z10.b-z11.b}, {z10.b-z11.b}      \n"
    "  sdot za.s[w9, 3, VGx2], {z10.b-z11.b}, {z10.b-z11.b}      \n"
    "  sdot za.s[w9, 4, VGx2], {z12.b-z13.b}, {z12.b-z13.b}      \n"
    "  sdot za.s[w9, 5, VGx2], {z12.b-z13.b}, {z12.b-z13.b}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*14.0*(double)n_iterations;
}


static double sdot_za_i32_i8_vgx2_ilp15(const void*) {
  // SDOT (I8 to I32, 4-way, two vectors), Dot Product (integer)
  //
  // Each instruction: (128x i8, 128x i8) → 32x i32 (256 OPs)
  // Total of 3840 OPs per loop iteration, ILP = 15
  size_t n_iterations = N_ITERATIONS/15;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  sdot za.s[w8, 0, VGx2], {z0.b-z1.b}, {z0.b-z1.b}          \n"
    "  sdot za.s[w8, 1, VGx2], {z0.b-z1.b}, {z0.b-z1.b}          \n"
    "  sdot za.s[w8, 2, VGx2], {z2.b-z3.b}, {z2.b-z3.b}          \n"
    "  sdot za.s[w8, 3, VGx2], {z2.b-z3.b}, {z2.b-z3.b}          \n"
    "  sdot za.s[w8, 4, VGx2], {z4.b-z5.b}, {z4.b-z5.b}          \n"
    "  sdot za.s[w8, 5, VGx2], {z4.b-z5.b}, {z4.b-z5.b}          \n"
    "  sdot za.s[w8, 6, VGx2], {z6.b-z7.b}, {z6.b-z7.b}          \n"
    "  sdot za.s[w8, 7, VGx2], {z6.b-z7.b}, {z6.b-z7.b}          \n"
    "  sdot za.s[w9, 0, VGx2], {z8.b-z9.b}, {z8.b-z9.b}          \n"
    "  sdot za.s[w9, 1, VGx2], {z8.b-z9.b}, {z8.b-z9.b}          \n"
    "  sdot za.s[w9, 2, VGx2], {z10.b-z11.b}, {z10.b-z11.b}      \n"
    "  sdot za.s[w9, 3, VGx2], {z10.b-z11.b}, {z10.b-z11.b}      \n"
    "  sdot za.s[w9, 4, VGx2], {z12.b-z13.b}, {z12.b-z13.b}      \n"
    "  sdot za.s[w9, 5, VGx2], {z12.b-z13.b}, {z12.b-z13.b}      \n"
    "  sdot za.s[w9, 6, VGx2], {z14.b-z15.b}, {z14.b-z15.b}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*15.0*(double)n_iterations;
}


static double sdot_za_i32_i8_vgx2_ilp16(const void*) {
  // SDOT (I8 to I32, 4-way, two vectors), Dot Product (integer)
  //
  // Each instruction: (128x i8, 128x i8) → 32x i32 (256 OPs)
  // Total of 4096 OPs per loop iteration, ILP = 16
  size_t n_iterations = N_ITERATIONS/16;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  sdot za.s[w8, 0, VGx2], {z0.b-z1.b}, {z0.b-z1.b}          \n"
    "  sdot za.s[w8, 1, VGx2], {z0.b-z1.b}, {z0.b-z1.b}          \n"
    "  sdot za.s[w8, 2, VGx2], {z2.b-z3.b}, {z2.b-z3.b}          \n"
    "  sdot za.s[w8, 3, VGx2], {z2.b-z3.b}, {z2.b-z3.b}          \n"
    "  sdot za.s[w8, 4, VGx2], {z4.b-z5.b}, {z4.b-z5.b}          \n"
    "  sdot za.s[w8, 5, VGx2], {z4.b-z5.b}, {z4.b-z5.b}          \n"
    "  sdot za.s[w8, 6, VGx2], {z6.b-z7.b}, {z6.b-z7.b}          \n"
    "  sdot za.s[w8, 7, VGx2], {z6.b-z7.b}, {z6.b-z7.b}          \n"
    "  sdot za.s[w9, 0, VGx2], {z8.b-z9.b}, {z8.b-z9.b}          \n"
    "  sdot za.s[w9, 1, VGx2], {z8.b-z9.b}, {z8.b-z9.b}          \n"
    "  sdot za.s[w9, 2, VGx2], {z10.b-z11.b}, {z10.b-z11.b}      \n"
    "  sdot za.s[w9, 3, VGx2], {z10.b-z11.b}, {z10.b-z11.b}      \n"
    "  sdot za.s[w9, 4, VGx2], {z12.b-z13.b}, {z12.b-z13.b}      \n"
    "  sdot za.s[w9, 5, VGx2], {z12.b-z13.b}, {z12.b-z13.b}      \n"
    "  sdot za.s[w9, 6, VGx2], {z14.b-z15.b}, {z14.b-z15.b}      \n"
    "  sdot za.s[w9, 7, VGx2], {z14.b-z15.b}, {z14.b-z15.b}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*16.0*(double)n_iterations;
}


static double sdot_za_i32_i8_vgx4_ilp1(const void*) {
  // SDOT (I8 to I32, 4-way, four vectors), Dot Product (integer)
  //
  // Each instruction: (256x i8, 256x i8) → 64x i32 (512 OPs)
  // Total of 512 OPs per loop iteration, ILP = 1
  size_t n_iterations = N_ITERATIONS;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  sdot za.s[w8, 0, VGx4], {z0.b-z3.b}, {z0.b-z3.b}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 512.0*1.0*(double)n_iterations;
}


static double sdot_za_i32_i8_vgx4_ilp2(const void*) {
  // SDOT (I8 to I32, 4-way, four vectors), Dot Product (integer)
  //
  // Each instruction: (256x i8, 256x i8) → 64x i32 (512 OPs)
  // Total of 1024 OPs per loop iteration, ILP = 2
  size_t n_iterations = N_ITERATIONS/2;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  sdot za.s[w8, 0, VGx4], {z0.b-z3.b}, {z0.b-z3.b}          \n"
    "  sdot za.s[w8, 1, VGx4], {z0.b-z3.b}, {z0.b-z3.b}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 512.0*2.0*(double)n_iterations;
}


static double sdot_za_i32_i8_vgx4_ilp3(const void*) {
  // SDOT (I8 to I32, 4-way, four vectors), Dot Product (integer)
  //
  // Each instruction: (256x i8, 256x i8) → 64x i32 (512 OPs)
  // Total of 1536 OPs per loop iteration, ILP = 3
  size_t n_iterations = N_ITERATIONS/3;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  sdot za.s[w8, 0, VGx4], {z0.b-z3.b}, {z0.b-z3.b}          \n"
    "  sdot za.s[w8, 1, VGx4], {z0.b-z3.b}, {z0.b-z3.b}          \n"
    "  sdot za.s[w8, 2, VGx4], {z0.b-z3.b}, {z0.b-z3.b}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 512.0*3.0*(double)n_iterations;
}


static double sdot_za_i32_i8_vgx4_ilp4(const void*) {
  // SDOT (I8 to I32, 4-way, four vectors), Dot Product (integer)
  //
  // Each instruction: (256x i8, 256x i8) → 64x i32 (512 OPs)
  // Total of 2048 OPs per loop iteration, ILP = 4
  size_t n_iterations = N_ITERATIONS/4;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  sdot za.s[w8, 0, VGx4], {z0.b-z3.b}, {z0.b-z3.b}          \n"
    "  sdot za.s[w8, 1, VGx4], {z0.b-z3.b}, {z0.b-z3.b}          \n"
    "  sdot za.s[w8, 2, VGx4], {z0.b-z3.b}, {z0.b-z3.b}          \n"
    "  sdot za.s[w8, 3, VGx4], {z0.b-z3.b}, {z0.b-z3.b}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 512.0*4.0*(double)n_iterations;
}


static double sdot_za_i32_i8_vgx4_ilp5(const void*) {
  // SDOT (I8 to I32, 4-way, four vectors), Dot Product (integer)
  //
  // Each instruction: (256x i8, 256x i8) → 64x i32 (512 OPs)
  // Total of 2560 OPs per loop iteration, ILP = 5
  size_t n_iterations = N_ITERATIONS/5;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  sdot za.s[w8, 0, VGx4], {z0.b-z3.b}, {z0.b-z3.b}          \n"
    "  sdot za.s[w8, 1, VGx4], {z0.b-z3.b}, {z0.b-z3.b}          \n"
    "  sdot za.s[w8, 2, VGx4], {z0.b-z3.b}, {z0.b-z3.b}          \n"
    "  sdot za.s[w8, 3, VGx4], {z0.b-z3.b}, {z0.b-z3.b}          \n"
    "  sdot za.s[w8, 4, VGx4], {z4.b-z7.b}, {z4.b-z7.b}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 512.0*5.0*(double)n_iterations;
}


static double sdot_za_i32_i8_vgx4_ilp6(const void*) {
  // SDOT (I8 to I32, 4-way, four vectors), Dot Product (integer)
  //
  // Each instruction: (256x i8, 256x i8) → 64x i32 (512 OPs)
  // Total of 3072 OPs per loop iteration, ILP = 6
  size_t n_iterations = N_ITERATIONS/6;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  sdot za.s[w8, 0, VGx4], {z0.b-z3.b}, {z0.b-z3.b}          \n"
    "  sdot za.s[w8, 1, VGx4], {z0.b-z3.b}, {z0.b-z3.b}          \n"
    "  sdot za.s[w8, 2, VGx4], {z0.b-z3.b}, {z0.b-z3.b}          \n"
    "  sdot za.s[w8, 3, VGx4], {z0.b-z3.b}, {z0.b-z3.b}          \n"
    "  sdot za.s[w8, 4, VGx4], {z4.b-z7.b}, {z4.b-z7.b}          \n"
    "  sdot za.s[w8, 5, VGx4], {z4.b-z7.b}, {z4.b-z7.b}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 512.0*6.0*(double)n_iterations;
}


static double sdot_za_i32_i8_vgx4_ilp7(const void*) {
  // SDOT (I8 to I32, 4-way, four vectors), Dot Product (integer)
  //
  // Each instruction: (256x i8, 256x i8) → 64x i32 (512 OPs)
  // Total of 3584 OPs per loop iteration, ILP = 7
  size_t n_iterations = N_ITERATIONS/7;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  sdot za.s[w8, 0, VGx4], {z0.b-z3.b}, {z0.b-z3.b}          \n"
    "  sdot za.s[w8, 1, VGx4], {z0.b-z3.b}, {z0.b-z3.b}          \n"
    "  sdot za.s[w8, 2, VGx4], {z0.b-z3.b}, {z0.b-z3.b}          \n"
    "  sdot za.s[w8, 3, VGx4], {z0.b-z3.b}, {z0.b-z3.b}          \n"
    "  sdot za.s[w8, 4, VGx4], {z4.b-z7.b}, {z4.b-z7.b}          \n"
    "  sdot za.s[w8, 5, VGx4], {z4.b-z7.b}, {z4.b-z7.b}          \n"
    "  sdot za.s[w8, 6, VGx4], {z4.b-z7.b}, {z4.b-z7.b}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 512.0*7.0*(double)n_iterations;
}


static double sdot_za_i32_i8_vgx4_ilp8(const void*) {
  // SDOT (I8 to I32, 4-way, four vectors), Dot Product (integer)
  //
  // Each instruction: (256x i8, 256x i8) → 64x i32 (512 OPs)
  // Total of 4096 OPs per loop iteration, ILP = 8
  size_t n_iterations = N_ITERATIONS/8;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  sdot za.s[w8, 0, VGx4], {z0.b-z3.b}, {z0.b-z3.b}          \n"
    "  sdot za.s[w8, 1, VGx4], {z0.b-z3.b}, {z0.b-z3.b}          \n"
    "  sdot za.s[w8, 2, VGx4], {z0.b-z3.b}, {z0.b-z3.b}          \n"
    "  sdot za.s[w8, 3, VGx4], {z0.b-z3.b}, {z0.b-z3.b}          \n"
    "  sdot za.s[w8, 4, VGx4], {z4.b-z7.b}, {z4.b-z7.b}          \n"
    "  sdot za.s[w8, 5, VGx4], {z4.b-z7.b}, {z4.b-z7.b}          \n"
    "  sdot za.s[w8, 6, VGx4], {z4.b-z7.b}, {z4.b-z7.b}          \n"
    "  sdot za.s[w8, 7, VGx4], {z4.b-z7.b}, {z4.b-z7.b}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 512.0*8.0*(double)n_iterations;
}


static double sdot_za_i32_i8_vgx4_ilp9(const void*) {
  // SDOT (I8 to I32, 4-way, four vectors), Dot Product (integer)
  //
  // Each instruction: (256x i8, 256x i8) → 64x i32 (512 OPs)
  // Total of 4608 OPs per loop iteration, ILP = 9
  size_t n_iterations = N_ITERATIONS/9;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  sdot za.s[w8, 0, VGx4], {z0.b-z3.b}, {z0.b-z3.b}          \n"
    "  sdot za.s[w8, 1, VGx4], {z0.b-z3.b}, {z0.b-z3.b}          \n"
    "  sdot za.s[w8, 2, VGx4], {z0.b-z3.b}, {z0.b-z3.b}          \n"
    "  sdot za.s[w8, 3, VGx4], {z0.b-z3.b}, {z0.b-z3.b}          \n"
    "  sdot za.s[w8, 4, VGx4], {z4.b-z7.b}, {z4.b-z7.b}          \n"
    "  sdot za.s[w8, 5, VGx4], {z4.b-z7.b}, {z4.b-z7.b}          \n"
    "  sdot za.s[w8, 6, VGx4], {z4.b-z7.b}, {z4.b-z7.b}          \n"
    "  sdot za.s[w8, 7, VGx4], {z4.b-z7.b}, {z4.b-z7.b}          \n"
    "  sdot za.s[w9, 0, VGx4], {z8.b-z11.b}, {z8.b-z11.b}        \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 512.0*9.0*(double)n_iterations;
}


static double sdot_za_i32_i8_vgx4_ilp10(const void*) {
  // SDOT (I8 to I32, 4-way, four vectors), Dot Product (integer)
  //
  // Each instruction: (256x i8, 256x i8) → 64x i32 (512 OPs)
  // Total of 5120 OPs per loop iteration, ILP = 10
  size_t n_iterations = N_ITERATIONS/10;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  sdot za.s[w8, 0, VGx4], {z0.b-z3.b}, {z0.b-z3.b}          \n"
    "  sdot za.s[w8, 1, VGx4], {z0.b-z3.b}, {z0.b-z3.b}          \n"
    "  sdot za.s[w8, 2, VGx4], {z0.b-z3.b}, {z0.b-z3.b}          \n"
    "  sdot za.s[w8, 3, VGx4], {z0.b-z3.b}, {z0.b-z3.b}          \n"
    "  sdot za.s[w8, 4, VGx4], {z4.b-z7.b}, {z4.b-z7.b}          \n"
    "  sdot za.s[w8, 5, VGx4], {z4.b-z7.b}, {z4.b-z7.b}          \n"
    "  sdot za.s[w8, 6, VGx4], {z4.b-z7.b}, {z4.b-z7.b}          \n"
    "  sdot za.s[w8, 7, VGx4], {z4.b-z7.b}, {z4.b-z7.b}          \n"
    "  sdot za.s[w9, 0, VGx4], {z8.b-z11.b}, {z8.b-z11.b}        \n"
    "  sdot za.s[w9, 1, VGx4], {z8.b-z11.b}, {z8.b-z11.b}        \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 512.0*10.0*(double)n_iterations;
}


static double sdot_za_i32_i8_vgx4_ilp11(const void*) {
  // SDOT (I8 to I32, 4-way, four vectors), Dot Product (integer)
  //
  // Each instruction: (256x i8, 256x i8) → 64x i32 (512 OPs)
  // Total of 5632 OPs per loop iteration, ILP = 11
  size_t n_iterations = N_ITERATIONS/11;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  sdot za.s[w8, 0, VGx4], {z0.b-z3.b}, {z0.b-z3.b}          \n"
    "  sdot za.s[w8, 1, VGx4], {z0.b-z3.b}, {z0.b-z3.b}          \n"
    "  sdot za.s[w8, 2, VGx4], {z0.b-z3.b}, {z0.b-z3.b}          \n"
    "  sdot za.s[w8, 3, VGx4], {z0.b-z3.b}, {z0.b-z3.b}          \n"
    "  sdot za.s[w8, 4, VGx4], {z4.b-z7.b}, {z4.b-z7.b}          \n"
    "  sdot za.s[w8, 5, VGx4], {z4.b-z7.b}, {z4.b-z7.b}          \n"
    "  sdot za.s[w8, 6, VGx4], {z4.b-z7.b}, {z4.b-z7.b}          \n"
    "  sdot za.s[w8, 7, VGx4], {z4.b-z7.b}, {z4.b-z7.b}          \n"
    "  sdot za.s[w9, 0, VGx4], {z8.b-z11.b}, {z8.b-z11.b}        \n"
    "  sdot za.s[w9, 1, VGx4], {z8.b-z11.b}, {z8.b-z11.b}        \n"
    "  sdot za.s[w9, 2, VGx4], {z8.b-z11.b}, {z8.b-z11.b}        \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 512.0*11.0*(double)n_iterations;
}


static double sdot_za_i32_i8_vgx4_ilp12(const void*) {
  // SDOT (I8 to I32, 4-way, four vectors), Dot Product (integer)
  //
  // Each instruction: (256x i8, 256x i8) → 64x i32 (512 OPs)
  // Total of 6144 OPs per loop iteration, ILP = 12
  size_t n_iterations = N_ITERATIONS/12;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  sdot za.s[w8, 0, VGx4], {z0.b-z3.b}, {z0.b-z3.b}          \n"
    "  sdot za.s[w8, 1, VGx4], {z0.b-z3.b}, {z0.b-z3.b}          \n"
    "  sdot za.s[w8, 2, VGx4], {z0.b-z3.b}, {z0.b-z3.b}          \n"
    "  sdot za.s[w8, 3, VGx4], {z0.b-z3.b}, {z0.b-z3.b}          \n"
    "  sdot za.s[w8, 4, VGx4], {z4.b-z7.b}, {z4.b-z7.b}          \n"
    "  sdot za.s[w8, 5, VGx4], {z4.b-z7.b}, {z4.b-z7.b}          \n"
    "  sdot za.s[w8, 6, VGx4], {z4.b-z7.b}, {z4.b-z7.b}          \n"
    "  sdot za.s[w8, 7, VGx4], {z4.b-z7.b}, {z4.b-z7.b}          \n"
    "  sdot za.s[w9, 0, VGx4], {z8.b-z11.b}, {z8.b-z11.b}        \n"
    "  sdot za.s[w9, 1, VGx4], {z8.b-z11.b}, {z8.b-z11.b}        \n"
    "  sdot za.s[w9, 2, VGx4], {z8.b-z11.b}, {z8.b-z11.b}        \n"
    "  sdot za.s[w9, 3, VGx4], {z8.b-z11.b}, {z8.b-z11.b}        \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 512.0*12.0*(double)n_iterations;
}


static double sdot_za_i32_i8_vgx4_ilp13(const void*) {
  // SDOT (I8 to I32, 4-way, four vectors), Dot Product (integer)
  //
  // Each instruction: (256x i8, 256x i8) → 64x i32 (512 OPs)
  // Total of 6656 OPs per loop iteration, ILP = 13
  size_t n_iterations = N_ITERATIONS/13;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  sdot za.s[w8, 0, VGx4], {z0.b-z3.b}, {z0.b-z3.b}          \n"
    "  sdot za.s[w8, 1, VGx4], {z0.b-z3.b}, {z0.b-z3.b}          \n"
    "  sdot za.s[w8, 2, VGx4], {z0.b-z3.b}, {z0.b-z3.b}          \n"
    "  sdot za.s[w8, 3, VGx4], {z0.b-z3.b}, {z0.b-z3.b}          \n"
    "  sdot za.s[w8, 4, VGx4], {z4.b-z7.b}, {z4.b-z7.b}          \n"
    "  sdot za.s[w8, 5, VGx4], {z4.b-z7.b}, {z4.b-z7.b}          \n"
    "  sdot za.s[w8, 6, VGx4], {z4.b-z7.b}, {z4.b-z7.b}          \n"
    "  sdot za.s[w8, 7, VGx4], {z4.b-z7.b}, {z4.b-z7.b}          \n"
    "  sdot za.s[w9, 0, VGx4], {z8.b-z11.b}, {z8.b-z11.b}        \n"
    "  sdot za.s[w9, 1, VGx4], {z8.b-z11.b}, {z8.b-z11.b}        \n"
    "  sdot za.s[w9, 2, VGx4], {z8.b-z11.b}, {z8.b-z11.b}        \n"
    "  sdot za.s[w9, 3, VGx4], {z8.b-z11.b}, {z8.b-z11.b}        \n"
    "  sdot za.s[w9, 4, VGx4], {z12.b-z15.b}, {z12.b-z15.b}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 512.0*13.0*(double)n_iterations;
}


static double sdot_za_i32_i8_vgx4_ilp14(const void*) {
  // SDOT (I8 to I32, 4-way, four vectors), Dot Product (integer)
  //
  // Each instruction: (256x i8, 256x i8) → 64x i32 (512 OPs)
  // Total of 7168 OPs per loop iteration, ILP = 14
  size_t n_iterations = N_ITERATIONS/14;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  sdot za.s[w8, 0, VGx4], {z0.b-z3.b}, {z0.b-z3.b}          \n"
    "  sdot za.s[w8, 1, VGx4], {z0.b-z3.b}, {z0.b-z3.b}          \n"
    "  sdot za.s[w8, 2, VGx4], {z0.b-z3.b}, {z0.b-z3.b}          \n"
    "  sdot za.s[w8, 3, VGx4], {z0.b-z3.b}, {z0.b-z3.b}          \n"
    "  sdot za.s[w8, 4, VGx4], {z4.b-z7.b}, {z4.b-z7.b}          \n"
    "  sdot za.s[w8, 5, VGx4], {z4.b-z7.b}, {z4.b-z7.b}          \n"
    "  sdot za.s[w8, 6, VGx4], {z4.b-z7.b}, {z4.b-z7.b}          \n"
    "  sdot za.s[w8, 7, VGx4], {z4.b-z7.b}, {z4.b-z7.b}          \n"
    "  sdot za.s[w9, 0, VGx4], {z8.b-z11.b}, {z8.b-z11.b}        \n"
    "  sdot za.s[w9, 1, VGx4], {z8.b-z11.b}, {z8.b-z11.b}        \n"
    "  sdot za.s[w9, 2, VGx4], {z8.b-z11.b}, {z8.b-z11.b}        \n"
    "  sdot za.s[w9, 3, VGx4], {z8.b-z11.b}, {z8.b-z11.b}        \n"
    "  sdot za.s[w9, 4, VGx4], {z12.b-z15.b}, {z12.b-z15.b}      \n"
    "  sdot za.s[w9, 5, VGx4], {z12.b-z15.b}, {z12.b-z15.b}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 512.0*14.0*(double)n_iterations;
}


static double sdot_za_i32_i8_vgx4_ilp15(const void*) {
  // SDOT (I8 to I32, 4-way, four vectors), Dot Product (integer)
  //
  // Each instruction: (256x i8, 256x i8) → 64x i32 (512 OPs)
  // Total of 7680 OPs per loop iteration, ILP = 15
  size_t n_iterations = N_ITERATIONS/15;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  sdot za.s[w8, 0, VGx4], {z0.b-z3.b}, {z0.b-z3.b}          \n"
    "  sdot za.s[w8, 1, VGx4], {z0.b-z3.b}, {z0.b-z3.b}          \n"
    "  sdot za.s[w8, 2, VGx4], {z0.b-z3.b}, {z0.b-z3.b}          \n"
    "  sdot za.s[w8, 3, VGx4], {z0.b-z3.b}, {z0.b-z3.b}          \n"
    "  sdot za.s[w8, 4, VGx4], {z4.b-z7.b}, {z4.b-z7.b}          \n"
    "  sdot za.s[w8, 5, VGx4], {z4.b-z7.b}, {z4.b-z7.b}          \n"
    "  sdot za.s[w8, 6, VGx4], {z4.b-z7.b}, {z4.b-z7.b}          \n"
    "  sdot za.s[w8, 7, VGx4], {z4.b-z7.b}, {z4.b-z7.b}          \n"
    "  sdot za.s[w9, 0, VGx4], {z8.b-z11.b}, {z8.b-z11.b}        \n"
    "  sdot za.s[w9, 1, VGx4], {z8.b-z11.b}, {z8.b-z11.b}        \n"
    "  sdot za.s[w9, 2, VGx4], {z8.b-z11.b}, {z8.b-z11.b}        \n"
    "  sdot za.s[w9, 3, VGx4], {z8.b-z11.b}, {z8.b-z11.b}        \n"
    "  sdot za.s[w9, 4, VGx4], {z12.b-z15.b}, {z12.b-z15.b}      \n"
    "  sdot za.s[w9, 5, VGx4], {z12.b-z15.b}, {z12.b-z15.b}      \n"
    "  sdot za.s[w9, 6, VGx4], {z12.b-z15.b}, {z12.b-z15.b}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 512.0*15.0*(double)n_iterations;
}


static double sdot_za_i32_i8_vgx4_ilp16(const void*) {
  // SDOT (I8 to I32, 4-way, four vectors), Dot Product (integer)
  //
  // Each instruction: (256x i8, 256x i8) → 64x i32 (512 OPs)
  // Total of 8192 OPs per loop iteration, ILP = 16
  size_t n_iterations = N_ITERATIONS/16;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  sdot za.s[w8, 0, VGx4], {z0.b-z3.b}, {z0.b-z3.b}          \n"
    "  sdot za.s[w8, 1, VGx4], {z0.b-z3.b}, {z0.b-z3.b}          \n"
    "  sdot za.s[w8, 2, VGx4], {z0.b-z3.b}, {z0.b-z3.b}          \n"
    "  sdot za.s[w8, 3, VGx4], {z0.b-z3.b}, {z0.b-z3.b}          \n"
    "  sdot za.s[w8, 4, VGx4], {z4.b-z7.b}, {z4.b-z7.b}          \n"
    "  sdot za.s[w8, 5, VGx4], {z4.b-z7.b}, {z4.b-z7.b}          \n"
    "  sdot za.s[w8, 6, VGx4], {z4.b-z7.b}, {z4.b-z7.b}          \n"
    "  sdot za.s[w8, 7, VGx4], {z4.b-z7.b}, {z4.b-z7.b}          \n"
    "  sdot za.s[w9, 0, VGx4], {z8.b-z11.b}, {z8.b-z11.b}        \n"
    "  sdot za.s[w9, 1, VGx4], {z8.b-z11.b}, {z8.b-z11.b}        \n"
    "  sdot za.s[w9, 2, VGx4], {z8.b-z11.b}, {z8.b-z11.b}        \n"
    "  sdot za.s[w9, 3, VGx4], {z8.b-z11.b}, {z8.b-z11.b}        \n"
    "  sdot za.s[w9, 4, VGx4], {z12.b-z15.b}, {z12.b-z15.b}      \n"
    "  sdot za.s[w9, 5, VGx4], {z12.b-z15.b}, {z12.b-z15.b}      \n"
    "  sdot za.s[w9, 6, VGx4], {z12.b-z15.b}, {z12.b-z15.b}      \n"
    "  sdot za.s[w9, 7, VGx4], {z12.b-z15.b}, {z12.b-z15.b}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 512.0*16.0*(double)n_iterations;
}


static double sdot_za_i64_i16_vgx2_ilp1(const void*) {
  // SDOT (I16 to I64, 4-way, two vectors), Dot Product (integer)
  //
  // Each instruction: (64x i16, 64x i16) → 16x i64 (128 OPs)
  // Total of 128 OPs per loop iteration, ILP = 1
  size_t n_iterations = N_ITERATIONS;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  sdot za.d[w8, 0, VGx2], {z0.h-z1.h}, {z0.h-z1.h}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*1.0*(double)n_iterations;
}


static double sdot_za_i64_i16_vgx2_ilp2(const void*) {
  // SDOT (I16 to I64, 4-way, two vectors), Dot Product (integer)
  //
  // Each instruction: (64x i16, 64x i16) → 16x i64 (128 OPs)
  // Total of 256 OPs per loop iteration, ILP = 2
  size_t n_iterations = N_ITERATIONS/2;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  sdot za.d[w8, 0, VGx2], {z0.h-z1.h}, {z0.h-z1.h}          \n"
    "  sdot za.d[w8, 1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*2.0*(double)n_iterations;
}


static double sdot_za_i64_i16_vgx2_ilp3(const void*) {
  // SDOT (I16 to I64, 4-way, two vectors), Dot Product (integer)
  //
  // Each instruction: (64x i16, 64x i16) → 16x i64 (128 OPs)
  // Total of 384 OPs per loop iteration, ILP = 3
  size_t n_iterations = N_ITERATIONS/3;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  sdot za.d[w8, 0, VGx2], {z0.h-z1.h}, {z0.h-z1.h}          \n"
    "  sdot za.d[w8, 1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}          \n"
    "  sdot za.d[w8, 2, VGx2], {z2.h-z3.h}, {z2.h-z3.h}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*3.0*(double)n_iterations;
}


static double sdot_za_i64_i16_vgx2_ilp4(const void*) {
  // SDOT (I16 to I64, 4-way, two vectors), Dot Product (integer)
  //
  // Each instruction: (64x i16, 64x i16) → 16x i64 (128 OPs)
  // Total of 512 OPs per loop iteration, ILP = 4
  size_t n_iterations = N_ITERATIONS/4;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  sdot za.d[w8, 0, VGx2], {z0.h-z1.h}, {z0.h-z1.h}          \n"
    "  sdot za.d[w8, 1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}          \n"
    "  sdot za.d[w8, 2, VGx2], {z2.h-z3.h}, {z2.h-z3.h}          \n"
    "  sdot za.d[w8, 3, VGx2], {z2.h-z3.h}, {z2.h-z3.h}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*4.0*(double)n_iterations;
}


static double sdot_za_i64_i16_vgx2_ilp5(const void*) {
  // SDOT (I16 to I64, 4-way, two vectors), Dot Product (integer)
  //
  // Each instruction: (64x i16, 64x i16) → 16x i64 (128 OPs)
  // Total of 640 OPs per loop iteration, ILP = 5
  size_t n_iterations = N_ITERATIONS/5;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  sdot za.d[w8, 0, VGx2], {z0.h-z1.h}, {z0.h-z1.h}          \n"
    "  sdot za.d[w8, 1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}          \n"
    "  sdot za.d[w8, 2, VGx2], {z2.h-z3.h}, {z2.h-z3.h}          \n"
    "  sdot za.d[w8, 3, VGx2], {z2.h-z3.h}, {z2.h-z3.h}          \n"
    "  sdot za.d[w8, 4, VGx2], {z4.h-z5.h}, {z4.h-z5.h}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*5.0*(double)n_iterations;
}


static double sdot_za_i64_i16_vgx2_ilp6(const void*) {
  // SDOT (I16 to I64, 4-way, two vectors), Dot Product (integer)
  //
  // Each instruction: (64x i16, 64x i16) → 16x i64 (128 OPs)
  // Total of 768 OPs per loop iteration, ILP = 6
  size_t n_iterations = N_ITERATIONS/6;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  sdot za.d[w8, 0, VGx2], {z0.h-z1.h}, {z0.h-z1.h}          \n"
    "  sdot za.d[w8, 1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}          \n"
    "  sdot za.d[w8, 2, VGx2], {z2.h-z3.h}, {z2.h-z3.h}          \n"
    "  sdot za.d[w8, 3, VGx2], {z2.h-z3.h}, {z2.h-z3.h}          \n"
    "  sdot za.d[w8, 4, VGx2], {z4.h-z5.h}, {z4.h-z5.h}          \n"
    "  sdot za.d[w8, 5, VGx2], {z4.h-z5.h}, {z4.h-z5.h}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*6.0*(double)n_iterations;
}


static double sdot_za_i64_i16_vgx2_ilp7(const void*) {
  // SDOT (I16 to I64, 4-way, two vectors), Dot Product (integer)
  //
  // Each instruction: (64x i16, 64x i16) → 16x i64 (128 OPs)
  // Total of 896 OPs per loop iteration, ILP = 7
  size_t n_iterations = N_ITERATIONS/7;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  sdot za.d[w8, 0, VGx2], {z0.h-z1.h}, {z0.h-z1.h}          \n"
    "  sdot za.d[w8, 1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}          \n"
    "  sdot za.d[w8, 2, VGx2], {z2.h-z3.h}, {z2.h-z3.h}          \n"
    "  sdot za.d[w8, 3, VGx2], {z2.h-z3.h}, {z2.h-z3.h}          \n"
    "  sdot za.d[w8, 4, VGx2], {z4.h-z5.h}, {z4.h-z5.h}          \n"
    "  sdot za.d[w8, 5, VGx2], {z4.h-z5.h}, {z4.h-z5.h}          \n"
    "  sdot za.d[w8, 6, VGx2], {z6.h-z7.h}, {z6.h-z7.h}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*7.0*(double)n_iterations;
}


static double sdot_za_i64_i16_vgx2_ilp8(const void*) {
  // SDOT (I16 to I64, 4-way, two vectors), Dot Product (integer)
  //
  // Each instruction: (64x i16, 64x i16) → 16x i64 (128 OPs)
  // Total of 1024 OPs per loop iteration, ILP = 8
  size_t n_iterations = N_ITERATIONS/8;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  sdot za.d[w8, 0, VGx2], {z0.h-z1.h}, {z0.h-z1.h}          \n"
    "  sdot za.d[w8, 1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}          \n"
    "  sdot za.d[w8, 2, VGx2], {z2.h-z3.h}, {z2.h-z3.h}          \n"
    "  sdot za.d[w8, 3, VGx2], {z2.h-z3.h}, {z2.h-z3.h}          \n"
    "  sdot za.d[w8, 4, VGx2], {z4.h-z5.h}, {z4.h-z5.h}          \n"
    "  sdot za.d[w8, 5, VGx2], {z4.h-z5.h}, {z4.h-z5.h}          \n"
    "  sdot za.d[w8, 6, VGx2], {z6.h-z7.h}, {z6.h-z7.h}          \n"
    "  sdot za.d[w8, 7, VGx2], {z6.h-z7.h}, {z6.h-z7.h}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*8.0*(double)n_iterations;
}


static double sdot_za_i64_i16_vgx2_ilp9(const void*) {
  // SDOT (I16 to I64, 4-way, two vectors), Dot Product (integer)
  //
  // Each instruction: (64x i16, 64x i16) → 16x i64 (128 OPs)
  // Total of 1152 OPs per loop iteration, ILP = 9
  size_t n_iterations = N_ITERATIONS/9;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  sdot za.d[w8, 0, VGx2], {z0.h-z1.h}, {z0.h-z1.h}          \n"
    "  sdot za.d[w8, 1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}          \n"
    "  sdot za.d[w8, 2, VGx2], {z2.h-z3.h}, {z2.h-z3.h}          \n"
    "  sdot za.d[w8, 3, VGx2], {z2.h-z3.h}, {z2.h-z3.h}          \n"
    "  sdot za.d[w8, 4, VGx2], {z4.h-z5.h}, {z4.h-z5.h}          \n"
    "  sdot za.d[w8, 5, VGx2], {z4.h-z5.h}, {z4.h-z5.h}          \n"
    "  sdot za.d[w8, 6, VGx2], {z6.h-z7.h}, {z6.h-z7.h}          \n"
    "  sdot za.d[w8, 7, VGx2], {z6.h-z7.h}, {z6.h-z7.h}          \n"
    "  sdot za.d[w9, 0, VGx2], {z8.h-z9.h}, {z8.h-z9.h}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*9.0*(double)n_iterations;
}


static double sdot_za_i64_i16_vgx2_ilp10(const void*) {
  // SDOT (I16 to I64, 4-way, two vectors), Dot Product (integer)
  //
  // Each instruction: (64x i16, 64x i16) → 16x i64 (128 OPs)
  // Total of 1280 OPs per loop iteration, ILP = 10
  size_t n_iterations = N_ITERATIONS/10;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  sdot za.d[w8, 0, VGx2], {z0.h-z1.h}, {z0.h-z1.h}          \n"
    "  sdot za.d[w8, 1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}          \n"
    "  sdot za.d[w8, 2, VGx2], {z2.h-z3.h}, {z2.h-z3.h}          \n"
    "  sdot za.d[w8, 3, VGx2], {z2.h-z3.h}, {z2.h-z3.h}          \n"
    "  sdot za.d[w8, 4, VGx2], {z4.h-z5.h}, {z4.h-z5.h}          \n"
    "  sdot za.d[w8, 5, VGx2], {z4.h-z5.h}, {z4.h-z5.h}          \n"
    "  sdot za.d[w8, 6, VGx2], {z6.h-z7.h}, {z6.h-z7.h}          \n"
    "  sdot za.d[w8, 7, VGx2], {z6.h-z7.h}, {z6.h-z7.h}          \n"
    "  sdot za.d[w9, 0, VGx2], {z8.h-z9.h}, {z8.h-z9.h}          \n"
    "  sdot za.d[w9, 1, VGx2], {z8.h-z9.h}, {z8.h-z9.h}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*10.0*(double)n_iterations;
}


static double sdot_za_i64_i16_vgx2_ilp11(const void*) {
  // SDOT (I16 to I64, 4-way, two vectors), Dot Product (integer)
  //
  // Each instruction: (64x i16, 64x i16) → 16x i64 (128 OPs)
  // Total of 1408 OPs per loop iteration, ILP = 11
  size_t n_iterations = N_ITERATIONS/11;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  sdot za.d[w8, 0, VGx2], {z0.h-z1.h}, {z0.h-z1.h}          \n"
    "  sdot za.d[w8, 1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}          \n"
    "  sdot za.d[w8, 2, VGx2], {z2.h-z3.h}, {z2.h-z3.h}          \n"
    "  sdot za.d[w8, 3, VGx2], {z2.h-z3.h}, {z2.h-z3.h}          \n"
    "  sdot za.d[w8, 4, VGx2], {z4.h-z5.h}, {z4.h-z5.h}          \n"
    "  sdot za.d[w8, 5, VGx2], {z4.h-z5.h}, {z4.h-z5.h}          \n"
    "  sdot za.d[w8, 6, VGx2], {z6.h-z7.h}, {z6.h-z7.h}          \n"
    "  sdot za.d[w8, 7, VGx2], {z6.h-z7.h}, {z6.h-z7.h}          \n"
    "  sdot za.d[w9, 0, VGx2], {z8.h-z9.h}, {z8.h-z9.h}          \n"
    "  sdot za.d[w9, 1, VGx2], {z8.h-z9.h}, {z8.h-z9.h}          \n"
    "  sdot za.d[w9, 2, VGx2], {z10.h-z11.h}, {z10.h-z11.h}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*11.0*(double)n_iterations;
}


static double sdot_za_i64_i16_vgx2_ilp12(const void*) {
  // SDOT (I16 to I64, 4-way, two vectors), Dot Product (integer)
  //
  // Each instruction: (64x i16, 64x i16) → 16x i64 (128 OPs)
  // Total of 1536 OPs per loop iteration, ILP = 12
  size_t n_iterations = N_ITERATIONS/12;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  sdot za.d[w8, 0, VGx2], {z0.h-z1.h}, {z0.h-z1.h}          \n"
    "  sdot za.d[w8, 1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}          \n"
    "  sdot za.d[w8, 2, VGx2], {z2.h-z3.h}, {z2.h-z3.h}          \n"
    "  sdot za.d[w8, 3, VGx2], {z2.h-z3.h}, {z2.h-z3.h}          \n"
    "  sdot za.d[w8, 4, VGx2], {z4.h-z5.h}, {z4.h-z5.h}          \n"
    "  sdot za.d[w8, 5, VGx2], {z4.h-z5.h}, {z4.h-z5.h}          \n"
    "  sdot za.d[w8, 6, VGx2], {z6.h-z7.h}, {z6.h-z7.h}          \n"
    "  sdot za.d[w8, 7, VGx2], {z6.h-z7.h}, {z6.h-z7.h}          \n"
    "  sdot za.d[w9, 0, VGx2], {z8.h-z9.h}, {z8.h-z9.h}          \n"
    "  sdot za.d[w9, 1, VGx2], {z8.h-z9.h}, {z8.h-z9.h}          \n"
    "  sdot za.d[w9, 2, VGx2], {z10.h-z11.h}, {z10.h-z11.h}      \n"
    "  sdot za.d[w9, 3, VGx2], {z10.h-z11.h}, {z10.h-z11.h}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*12.0*(double)n_iterations;
}


static double sdot_za_i64_i16_vgx2_ilp13(const void*) {
  // SDOT (I16 to I64, 4-way, two vectors), Dot Product (integer)
  //
  // Each instruction: (64x i16, 64x i16) → 16x i64 (128 OPs)
  // Total of 1664 OPs per loop iteration, ILP = 13
  size_t n_iterations = N_ITERATIONS/13;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  sdot za.d[w8, 0, VGx2], {z0.h-z1.h}, {z0.h-z1.h}          \n"
    "  sdot za.d[w8, 1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}          \n"
    "  sdot za.d[w8, 2, VGx2], {z2.h-z3.h}, {z2.h-z3.h}          \n"
    "  sdot za.d[w8, 3, VGx2], {z2.h-z3.h}, {z2.h-z3.h}          \n"
    "  sdot za.d[w8, 4, VGx2], {z4.h-z5.h}, {z4.h-z5.h}          \n"
    "  sdot za.d[w8, 5, VGx2], {z4.h-z5.h}, {z4.h-z5.h}          \n"
    "  sdot za.d[w8, 6, VGx2], {z6.h-z7.h}, {z6.h-z7.h}          \n"
    "  sdot za.d[w8, 7, VGx2], {z6.h-z7.h}, {z6.h-z7.h}          \n"
    "  sdot za.d[w9, 0, VGx2], {z8.h-z9.h}, {z8.h-z9.h}          \n"
    "  sdot za.d[w9, 1, VGx2], {z8.h-z9.h}, {z8.h-z9.h}          \n"
    "  sdot za.d[w9, 2, VGx2], {z10.h-z11.h}, {z10.h-z11.h}      \n"
    "  sdot za.d[w9, 3, VGx2], {z10.h-z11.h}, {z10.h-z11.h}      \n"
    "  sdot za.d[w9, 4, VGx2], {z12.h-z13.h}, {z12.h-z13.h}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*13.0*(double)n_iterations;
}


static double sdot_za_i64_i16_vgx2_ilp14(const void*) {
  // SDOT (I16 to I64, 4-way, two vectors), Dot Product (integer)
  //
  // Each instruction: (64x i16, 64x i16) → 16x i64 (128 OPs)
  // Total of 1792 OPs per loop iteration, ILP = 14
  size_t n_iterations = N_ITERATIONS/14;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  sdot za.d[w8, 0, VGx2], {z0.h-z1.h}, {z0.h-z1.h}          \n"
    "  sdot za.d[w8, 1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}          \n"
    "  sdot za.d[w8, 2, VGx2], {z2.h-z3.h}, {z2.h-z3.h}          \n"
    "  sdot za.d[w8, 3, VGx2], {z2.h-z3.h}, {z2.h-z3.h}          \n"
    "  sdot za.d[w8, 4, VGx2], {z4.h-z5.h}, {z4.h-z5.h}          \n"
    "  sdot za.d[w8, 5, VGx2], {z4.h-z5.h}, {z4.h-z5.h}          \n"
    "  sdot za.d[w8, 6, VGx2], {z6.h-z7.h}, {z6.h-z7.h}          \n"
    "  sdot za.d[w8, 7, VGx2], {z6.h-z7.h}, {z6.h-z7.h}          \n"
    "  sdot za.d[w9, 0, VGx2], {z8.h-z9.h}, {z8.h-z9.h}          \n"
    "  sdot za.d[w9, 1, VGx2], {z8.h-z9.h}, {z8.h-z9.h}          \n"
    "  sdot za.d[w9, 2, VGx2], {z10.h-z11.h}, {z10.h-z11.h}      \n"
    "  sdot za.d[w9, 3, VGx2], {z10.h-z11.h}, {z10.h-z11.h}      \n"
    "  sdot za.d[w9, 4, VGx2], {z12.h-z13.h}, {z12.h-z13.h}      \n"
    "  sdot za.d[w9, 5, VGx2], {z12.h-z13.h}, {z12.h-z13.h}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*14.0*(double)n_iterations;
}


static double sdot_za_i64_i16_vgx2_ilp15(const void*) {
  // SDOT (I16 to I64, 4-way, two vectors), Dot Product (integer)
  //
  // Each instruction: (64x i16, 64x i16) → 16x i64 (128 OPs)
  // Total of 1920 OPs per loop iteration, ILP = 15
  size_t n_iterations = N_ITERATIONS/15;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  sdot za.d[w8, 0, VGx2], {z0.h-z1.h}, {z0.h-z1.h}          \n"
    "  sdot za.d[w8, 1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}          \n"
    "  sdot za.d[w8, 2, VGx2], {z2.h-z3.h}, {z2.h-z3.h}          \n"
    "  sdot za.d[w8, 3, VGx2], {z2.h-z3.h}, {z2.h-z3.h}          \n"
    "  sdot za.d[w8, 4, VGx2], {z4.h-z5.h}, {z4.h-z5.h}          \n"
    "  sdot za.d[w8, 5, VGx2], {z4.h-z5.h}, {z4.h-z5.h}          \n"
    "  sdot za.d[w8, 6, VGx2], {z6.h-z7.h}, {z6.h-z7.h}          \n"
    "  sdot za.d[w8, 7, VGx2], {z6.h-z7.h}, {z6.h-z7.h}          \n"
    "  sdot za.d[w9, 0, VGx2], {z8.h-z9.h}, {z8.h-z9.h}          \n"
    "  sdot za.d[w9, 1, VGx2], {z8.h-z9.h}, {z8.h-z9.h}          \n"
    "  sdot za.d[w9, 2, VGx2], {z10.h-z11.h}, {z10.h-z11.h}      \n"
    "  sdot za.d[w9, 3, VGx2], {z10.h-z11.h}, {z10.h-z11.h}      \n"
    "  sdot za.d[w9, 4, VGx2], {z12.h-z13.h}, {z12.h-z13.h}      \n"
    "  sdot za.d[w9, 5, VGx2], {z12.h-z13.h}, {z12.h-z13.h}      \n"
    "  sdot za.d[w9, 6, VGx2], {z14.h-z15.h}, {z14.h-z15.h}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*15.0*(double)n_iterations;
}


static double sdot_za_i64_i16_vgx2_ilp16(const void*) {
  // SDOT (I16 to I64, 4-way, two vectors), Dot Product (integer)
  //
  // Each instruction: (64x i16, 64x i16) → 16x i64 (128 OPs)
  // Total of 2048 OPs per loop iteration, ILP = 16
  size_t n_iterations = N_ITERATIONS/16;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  sdot za.d[w8, 0, VGx2], {z0.h-z1.h}, {z0.h-z1.h}          \n"
    "  sdot za.d[w8, 1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}          \n"
    "  sdot za.d[w8, 2, VGx2], {z2.h-z3.h}, {z2.h-z3.h}          \n"
    "  sdot za.d[w8, 3, VGx2], {z2.h-z3.h}, {z2.h-z3.h}          \n"
    "  sdot za.d[w8, 4, VGx2], {z4.h-z5.h}, {z4.h-z5.h}          \n"
    "  sdot za.d[w8, 5, VGx2], {z4.h-z5.h}, {z4.h-z5.h}          \n"
    "  sdot za.d[w8, 6, VGx2], {z6.h-z7.h}, {z6.h-z7.h}          \n"
    "  sdot za.d[w8, 7, VGx2], {z6.h-z7.h}, {z6.h-z7.h}          \n"
    "  sdot za.d[w9, 0, VGx2], {z8.h-z9.h}, {z8.h-z9.h}          \n"
    "  sdot za.d[w9, 1, VGx2], {z8.h-z9.h}, {z8.h-z9.h}          \n"
    "  sdot za.d[w9, 2, VGx2], {z10.h-z11.h}, {z10.h-z11.h}      \n"
    "  sdot za.d[w9, 3, VGx2], {z10.h-z11.h}, {z10.h-z11.h}      \n"
    "  sdot za.d[w9, 4, VGx2], {z12.h-z13.h}, {z12.h-z13.h}      \n"
    "  sdot za.d[w9, 5, VGx2], {z12.h-z13.h}, {z12.h-z13.h}      \n"
    "  sdot za.d[w9, 6, VGx2], {z14.h-z15.h}, {z14.h-z15.h}      \n"
    "  sdot za.d[w9, 7, VGx2], {z14.h-z15.h}, {z14.h-z15.h}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*16.0*(double)n_iterations;
}


static double sdot_za_i64_i16_vgx4_ilp1(const void*) {
  // SDOT (I16 to I64, 4-way, four vectors), Dot Product (integer)
  //
  // Each instruction: (128x i16, 128x i16) → 32x i64 (256 OPs)
  // Total of 256 OPs per loop iteration, ILP = 1
  size_t n_iterations = N_ITERATIONS;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  sdot za.d[w8, 0, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*1.0*(double)n_iterations;
}


static double sdot_za_i64_i16_vgx4_ilp2(const void*) {
  // SDOT (I16 to I64, 4-way, four vectors), Dot Product (integer)
  //
  // Each instruction: (128x i16, 128x i16) → 32x i64 (256 OPs)
  // Total of 512 OPs per loop iteration, ILP = 2
  size_t n_iterations = N_ITERATIONS/2;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  sdot za.d[w8, 0, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.d[w8, 1, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*2.0*(double)n_iterations;
}


static double sdot_za_i64_i16_vgx4_ilp3(const void*) {
  // SDOT (I16 to I64, 4-way, four vectors), Dot Product (integer)
  //
  // Each instruction: (128x i16, 128x i16) → 32x i64 (256 OPs)
  // Total of 768 OPs per loop iteration, ILP = 3
  size_t n_iterations = N_ITERATIONS/3;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  sdot za.d[w8, 0, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.d[w8, 1, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.d[w8, 2, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*3.0*(double)n_iterations;
}


static double sdot_za_i64_i16_vgx4_ilp4(const void*) {
  // SDOT (I16 to I64, 4-way, four vectors), Dot Product (integer)
  //
  // Each instruction: (128x i16, 128x i16) → 32x i64 (256 OPs)
  // Total of 1024 OPs per loop iteration, ILP = 4
  size_t n_iterations = N_ITERATIONS/4;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  sdot za.d[w8, 0, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.d[w8, 1, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.d[w8, 2, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.d[w8, 3, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*4.0*(double)n_iterations;
}


static double sdot_za_i64_i16_vgx4_ilp5(const void*) {
  // SDOT (I16 to I64, 4-way, four vectors), Dot Product (integer)
  //
  // Each instruction: (128x i16, 128x i16) → 32x i64 (256 OPs)
  // Total of 1280 OPs per loop iteration, ILP = 5
  size_t n_iterations = N_ITERATIONS/5;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  sdot za.d[w8, 0, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.d[w8, 1, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.d[w8, 2, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.d[w8, 3, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.d[w8, 4, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*5.0*(double)n_iterations;
}


static double sdot_za_i64_i16_vgx4_ilp6(const void*) {
  // SDOT (I16 to I64, 4-way, four vectors), Dot Product (integer)
  //
  // Each instruction: (128x i16, 128x i16) → 32x i64 (256 OPs)
  // Total of 1536 OPs per loop iteration, ILP = 6
  size_t n_iterations = N_ITERATIONS/6;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  sdot za.d[w8, 0, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.d[w8, 1, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.d[w8, 2, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.d[w8, 3, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.d[w8, 4, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  sdot za.d[w8, 5, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*6.0*(double)n_iterations;
}


static double sdot_za_i64_i16_vgx4_ilp7(const void*) {
  // SDOT (I16 to I64, 4-way, four vectors), Dot Product (integer)
  //
  // Each instruction: (128x i16, 128x i16) → 32x i64 (256 OPs)
  // Total of 1792 OPs per loop iteration, ILP = 7
  size_t n_iterations = N_ITERATIONS/7;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  sdot za.d[w8, 0, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.d[w8, 1, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.d[w8, 2, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.d[w8, 3, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.d[w8, 4, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  sdot za.d[w8, 5, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  sdot za.d[w8, 6, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*7.0*(double)n_iterations;
}


static double sdot_za_i64_i16_vgx4_ilp8(const void*) {
  // SDOT (I16 to I64, 4-way, four vectors), Dot Product (integer)
  //
  // Each instruction: (128x i16, 128x i16) → 32x i64 (256 OPs)
  // Total of 2048 OPs per loop iteration, ILP = 8
  size_t n_iterations = N_ITERATIONS/8;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  sdot za.d[w8, 0, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.d[w8, 1, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.d[w8, 2, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.d[w8, 3, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.d[w8, 4, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  sdot za.d[w8, 5, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  sdot za.d[w8, 6, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  sdot za.d[w8, 7, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*8.0*(double)n_iterations;
}


static double sdot_za_i64_i16_vgx4_ilp9(const void*) {
  // SDOT (I16 to I64, 4-way, four vectors), Dot Product (integer)
  //
  // Each instruction: (128x i16, 128x i16) → 32x i64 (256 OPs)
  // Total of 2304 OPs per loop iteration, ILP = 9
  size_t n_iterations = N_ITERATIONS/9;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  sdot za.d[w8, 0, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.d[w8, 1, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.d[w8, 2, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.d[w8, 3, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.d[w8, 4, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  sdot za.d[w8, 5, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  sdot za.d[w8, 6, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  sdot za.d[w8, 7, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  sdot za.d[w9, 0, VGx4], {z8.h-z11.h}, {z8.h-z11.h}        \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*9.0*(double)n_iterations;
}


static double sdot_za_i64_i16_vgx4_ilp10(const void*) {
  // SDOT (I16 to I64, 4-way, four vectors), Dot Product (integer)
  //
  // Each instruction: (128x i16, 128x i16) → 32x i64 (256 OPs)
  // Total of 2560 OPs per loop iteration, ILP = 10
  size_t n_iterations = N_ITERATIONS/10;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  sdot za.d[w8, 0, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.d[w8, 1, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.d[w8, 2, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.d[w8, 3, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.d[w8, 4, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  sdot za.d[w8, 5, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  sdot za.d[w8, 6, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  sdot za.d[w8, 7, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  sdot za.d[w9, 0, VGx4], {z8.h-z11.h}, {z8.h-z11.h}        \n"
    "  sdot za.d[w9, 1, VGx4], {z8.h-z11.h}, {z8.h-z11.h}        \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*10.0*(double)n_iterations;
}


static double sdot_za_i64_i16_vgx4_ilp11(const void*) {
  // SDOT (I16 to I64, 4-way, four vectors), Dot Product (integer)
  //
  // Each instruction: (128x i16, 128x i16) → 32x i64 (256 OPs)
  // Total of 2816 OPs per loop iteration, ILP = 11
  size_t n_iterations = N_ITERATIONS/11;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  sdot za.d[w8, 0, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.d[w8, 1, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.d[w8, 2, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.d[w8, 3, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.d[w8, 4, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  sdot za.d[w8, 5, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  sdot za.d[w8, 6, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  sdot za.d[w8, 7, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  sdot za.d[w9, 0, VGx4], {z8.h-z11.h}, {z8.h-z11.h}        \n"
    "  sdot za.d[w9, 1, VGx4], {z8.h-z11.h}, {z8.h-z11.h}        \n"
    "  sdot za.d[w9, 2, VGx4], {z8.h-z11.h}, {z8.h-z11.h}        \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*11.0*(double)n_iterations;
}


static double sdot_za_i64_i16_vgx4_ilp12(const void*) {
  // SDOT (I16 to I64, 4-way, four vectors), Dot Product (integer)
  //
  // Each instruction: (128x i16, 128x i16) → 32x i64 (256 OPs)
  // Total of 3072 OPs per loop iteration, ILP = 12
  size_t n_iterations = N_ITERATIONS/12;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  sdot za.d[w8, 0, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.d[w8, 1, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.d[w8, 2, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.d[w8, 3, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.d[w8, 4, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  sdot za.d[w8, 5, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  sdot za.d[w8, 6, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  sdot za.d[w8, 7, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  sdot za.d[w9, 0, VGx4], {z8.h-z11.h}, {z8.h-z11.h}        \n"
    "  sdot za.d[w9, 1, VGx4], {z8.h-z11.h}, {z8.h-z11.h}        \n"
    "  sdot za.d[w9, 2, VGx4], {z8.h-z11.h}, {z8.h-z11.h}        \n"
    "  sdot za.d[w9, 3, VGx4], {z8.h-z11.h}, {z8.h-z11.h}        \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*12.0*(double)n_iterations;
}


static double sdot_za_i64_i16_vgx4_ilp13(const void*) {
  // SDOT (I16 to I64, 4-way, four vectors), Dot Product (integer)
  //
  // Each instruction: (128x i16, 128x i16) → 32x i64 (256 OPs)
  // Total of 3328 OPs per loop iteration, ILP = 13
  size_t n_iterations = N_ITERATIONS/13;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  sdot za.d[w8, 0, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.d[w8, 1, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.d[w8, 2, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.d[w8, 3, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.d[w8, 4, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  sdot za.d[w8, 5, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  sdot za.d[w8, 6, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  sdot za.d[w8, 7, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  sdot za.d[w9, 0, VGx4], {z8.h-z11.h}, {z8.h-z11.h}        \n"
    "  sdot za.d[w9, 1, VGx4], {z8.h-z11.h}, {z8.h-z11.h}        \n"
    "  sdot za.d[w9, 2, VGx4], {z8.h-z11.h}, {z8.h-z11.h}        \n"
    "  sdot za.d[w9, 3, VGx4], {z8.h-z11.h}, {z8.h-z11.h}        \n"
    "  sdot za.d[w9, 4, VGx4], {z12.h-z15.h}, {z12.h-z15.h}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*13.0*(double)n_iterations;
}


static double sdot_za_i64_i16_vgx4_ilp14(const void*) {
  // SDOT (I16 to I64, 4-way, four vectors), Dot Product (integer)
  //
  // Each instruction: (128x i16, 128x i16) → 32x i64 (256 OPs)
  // Total of 3584 OPs per loop iteration, ILP = 14
  size_t n_iterations = N_ITERATIONS/14;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  sdot za.d[w8, 0, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.d[w8, 1, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.d[w8, 2, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.d[w8, 3, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.d[w8, 4, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  sdot za.d[w8, 5, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  sdot za.d[w8, 6, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  sdot za.d[w8, 7, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  sdot za.d[w9, 0, VGx4], {z8.h-z11.h}, {z8.h-z11.h}        \n"
    "  sdot za.d[w9, 1, VGx4], {z8.h-z11.h}, {z8.h-z11.h}        \n"
    "  sdot za.d[w9, 2, VGx4], {z8.h-z11.h}, {z8.h-z11.h}        \n"
    "  sdot za.d[w9, 3, VGx4], {z8.h-z11.h}, {z8.h-z11.h}        \n"
    "  sdot za.d[w9, 4, VGx4], {z12.h-z15.h}, {z12.h-z15.h}      \n"
    "  sdot za.d[w9, 5, VGx4], {z12.h-z15.h}, {z12.h-z15.h}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*14.0*(double)n_iterations;
}


static double sdot_za_i64_i16_vgx4_ilp15(const void*) {
  // SDOT (I16 to I64, 4-way, four vectors), Dot Product (integer)
  //
  // Each instruction: (128x i16, 128x i16) → 32x i64 (256 OPs)
  // Total of 3840 OPs per loop iteration, ILP = 15
  size_t n_iterations = N_ITERATIONS/15;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  sdot za.d[w8, 0, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.d[w8, 1, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.d[w8, 2, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.d[w8, 3, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.d[w8, 4, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  sdot za.d[w8, 5, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  sdot za.d[w8, 6, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  sdot za.d[w8, 7, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  sdot za.d[w9, 0, VGx4], {z8.h-z11.h}, {z8.h-z11.h}        \n"
    "  sdot za.d[w9, 1, VGx4], {z8.h-z11.h}, {z8.h-z11.h}        \n"
    "  sdot za.d[w9, 2, VGx4], {z8.h-z11.h}, {z8.h-z11.h}        \n"
    "  sdot za.d[w9, 3, VGx4], {z8.h-z11.h}, {z8.h-z11.h}        \n"
    "  sdot za.d[w9, 4, VGx4], {z12.h-z15.h}, {z12.h-z15.h}      \n"
    "  sdot za.d[w9, 5, VGx4], {z12.h-z15.h}, {z12.h-z15.h}      \n"
    "  sdot za.d[w9, 6, VGx4], {z12.h-z15.h}, {z12.h-z15.h}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*15.0*(double)n_iterations;
}


static double sdot_za_i64_i16_vgx4_ilp16(const void*) {
  // SDOT (I16 to I64, 4-way, four vectors), Dot Product (integer)
  //
  // Each instruction: (128x i16, 128x i16) → 32x i64 (256 OPs)
  // Total of 4096 OPs per loop iteration, ILP = 16
  size_t n_iterations = N_ITERATIONS/16;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  sdot za.d[w8, 0, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.d[w8, 1, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.d[w8, 2, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.d[w8, 3, VGx4], {z0.h-z3.h}, {z0.h-z3.h}          \n"
    "  sdot za.d[w8, 4, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  sdot za.d[w8, 5, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  sdot za.d[w8, 6, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  sdot za.d[w8, 7, VGx4], {z4.h-z7.h}, {z4.h-z7.h}          \n"
    "  sdot za.d[w9, 0, VGx4], {z8.h-z11.h}, {z8.h-z11.h}        \n"
    "  sdot za.d[w9, 1, VGx4], {z8.h-z11.h}, {z8.h-z11.h}        \n"
    "  sdot za.d[w9, 2, VGx4], {z8.h-z11.h}, {z8.h-z11.h}        \n"
    "  sdot za.d[w9, 3, VGx4], {z8.h-z11.h}, {z8.h-z11.h}        \n"
    "  sdot za.d[w9, 4, VGx4], {z12.h-z15.h}, {z12.h-z15.h}      \n"
    "  sdot za.d[w9, 5, VGx4], {z12.h-z15.h}, {z12.h-z15.h}      \n"
    "  sdot za.d[w9, 6, VGx4], {z12.h-z15.h}, {z12.h-z15.h}      \n"
    "  sdot za.d[w9, 7, VGx4], {z12.h-z15.h}, {z12.h-z15.h}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*16.0*(double)n_iterations;
}


static double fmla_f16_f16_ilp1(const void*) {
  // FMLA (FP16, one vector), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (32x f16, 32x f16) → 32x f16 (64 OPs)
  // Total of 64 OPs per loop iteration, ILP = 1
  size_t n_iterations = N_ITERATIONS;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.h                                                  \n"
    "1:                                                          \n"
    "  fmla z0.h, p0/m, z0.h, z0.h                               \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*1.0*(double)n_iterations;
}


static double fmla_f16_f16_ilp2(const void*) {
  // FMLA (FP16, one vector), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (32x f16, 32x f16) → 32x f16 (64 OPs)
  // Total of 128 OPs per loop iteration, ILP = 2
  size_t n_iterations = N_ITERATIONS/2;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.h                                                  \n"
    "1:                                                          \n"
    "  fmla z0.h, p0/m, z0.h, z0.h                               \n"
    "  fmla z1.h, p0/m, z1.h, z1.h                               \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*2.0*(double)n_iterations;
}


static double fmla_f16_f16_ilp3(const void*) {
  // FMLA (FP16, one vector), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (32x f16, 32x f16) → 32x f16 (64 OPs)
  // Total of 192 OPs per loop iteration, ILP = 3
  size_t n_iterations = N_ITERATIONS/3;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.h                                                  \n"
    "1:                                                          \n"
    "  fmla z0.h, p0/m, z0.h, z0.h                               \n"
    "  fmla z1.h, p0/m, z1.h, z1.h                               \n"
    "  fmla z2.h, p0/m, z2.h, z2.h                               \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*3.0*(double)n_iterations;
}


static double fmla_f16_f16_ilp4(const void*) {
  // FMLA (FP16, one vector), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (32x f16, 32x f16) → 32x f16 (64 OPs)
  // Total of 256 OPs per loop iteration, ILP = 4
  size_t n_iterations = N_ITERATIONS/4;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.h                                                  \n"
    "1:                                                          \n"
    "  fmla z0.h, p0/m, z0.h, z0.h                               \n"
    "  fmla z1.h, p0/m, z1.h, z1.h                               \n"
    "  fmla z2.h, p0/m, z2.h, z2.h                               \n"
    "  fmla z3.h, p0/m, z3.h, z3.h                               \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*4.0*(double)n_iterations;
}


static double fmla_f16_f16_ilp5(const void*) {
  // FMLA (FP16, one vector), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (32x f16, 32x f16) → 32x f16 (64 OPs)
  // Total of 320 OPs per loop iteration, ILP = 5
  size_t n_iterations = N_ITERATIONS/5;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.h                                                  \n"
    "1:                                                          \n"
    "  fmla z0.h, p0/m, z0.h, z0.h                               \n"
    "  fmla z1.h, p0/m, z1.h, z1.h                               \n"
    "  fmla z2.h, p0/m, z2.h, z2.h                               \n"
    "  fmla z3.h, p0/m, z3.h, z3.h                               \n"
    "  fmla z4.h, p0/m, z4.h, z4.h                               \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*5.0*(double)n_iterations;
}


static double fmla_f16_f16_ilp6(const void*) {
  // FMLA (FP16, one vector), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (32x f16, 32x f16) → 32x f16 (64 OPs)
  // Total of 384 OPs per loop iteration, ILP = 6
  size_t n_iterations = N_ITERATIONS/6;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.h                                                  \n"
    "1:                                                          \n"
    "  fmla z0.h, p0/m, z0.h, z0.h                               \n"
    "  fmla z1.h, p0/m, z1.h, z1.h                               \n"
    "  fmla z2.h, p0/m, z2.h, z2.h                               \n"
    "  fmla z3.h, p0/m, z3.h, z3.h                               \n"
    "  fmla z4.h, p0/m, z4.h, z4.h                               \n"
    "  fmla z5.h, p0/m, z5.h, z5.h                               \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*6.0*(double)n_iterations;
}


static double fmla_f16_f16_ilp7(const void*) {
  // FMLA (FP16, one vector), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (32x f16, 32x f16) → 32x f16 (64 OPs)
  // Total of 448 OPs per loop iteration, ILP = 7
  size_t n_iterations = N_ITERATIONS/7;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.h                                                  \n"
    "1:                                                          \n"
    "  fmla z0.h, p0/m, z0.h, z0.h                               \n"
    "  fmla z1.h, p0/m, z1.h, z1.h                               \n"
    "  fmla z2.h, p0/m, z2.h, z2.h                               \n"
    "  fmla z3.h, p0/m, z3.h, z3.h                               \n"
    "  fmla z4.h, p0/m, z4.h, z4.h                               \n"
    "  fmla z5.h, p0/m, z5.h, z5.h                               \n"
    "  fmla z6.h, p0/m, z6.h, z6.h                               \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*7.0*(double)n_iterations;
}


static double fmla_f16_f16_ilp8(const void*) {
  // FMLA (FP16, one vector), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (32x f16, 32x f16) → 32x f16 (64 OPs)
  // Total of 512 OPs per loop iteration, ILP = 8
  size_t n_iterations = N_ITERATIONS/8;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.h                                                  \n"
    "1:                                                          \n"
    "  fmla z0.h, p0/m, z0.h, z0.h                               \n"
    "  fmla z1.h, p0/m, z1.h, z1.h                               \n"
    "  fmla z2.h, p0/m, z2.h, z2.h                               \n"
    "  fmla z3.h, p0/m, z3.h, z3.h                               \n"
    "  fmla z4.h, p0/m, z4.h, z4.h                               \n"
    "  fmla z5.h, p0/m, z5.h, z5.h                               \n"
    "  fmla z6.h, p0/m, z6.h, z6.h                               \n"
    "  fmla z7.h, p0/m, z7.h, z7.h                               \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*8.0*(double)n_iterations;
}


static double fmla_f16_f16_ilp9(const void*) {
  // FMLA (FP16, one vector), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (32x f16, 32x f16) → 32x f16 (64 OPs)
  // Total of 576 OPs per loop iteration, ILP = 9
  size_t n_iterations = N_ITERATIONS/9;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.h                                                  \n"
    "1:                                                          \n"
    "  fmla z0.h, p0/m, z0.h, z0.h                               \n"
    "  fmla z1.h, p0/m, z1.h, z1.h                               \n"
    "  fmla z2.h, p0/m, z2.h, z2.h                               \n"
    "  fmla z3.h, p0/m, z3.h, z3.h                               \n"
    "  fmla z4.h, p0/m, z4.h, z4.h                               \n"
    "  fmla z5.h, p0/m, z5.h, z5.h                               \n"
    "  fmla z6.h, p0/m, z6.h, z6.h                               \n"
    "  fmla z7.h, p0/m, z7.h, z7.h                               \n"
    "  fmla z8.h, p0/m, z8.h, z8.h                               \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*9.0*(double)n_iterations;
}


static double fmla_f16_f16_ilp10(const void*) {
  // FMLA (FP16, one vector), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (32x f16, 32x f16) → 32x f16 (64 OPs)
  // Total of 640 OPs per loop iteration, ILP = 10
  size_t n_iterations = N_ITERATIONS/10;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.h                                                  \n"
    "1:                                                          \n"
    "  fmla z0.h, p0/m, z0.h, z0.h                               \n"
    "  fmla z1.h, p0/m, z1.h, z1.h                               \n"
    "  fmla z2.h, p0/m, z2.h, z2.h                               \n"
    "  fmla z3.h, p0/m, z3.h, z3.h                               \n"
    "  fmla z4.h, p0/m, z4.h, z4.h                               \n"
    "  fmla z5.h, p0/m, z5.h, z5.h                               \n"
    "  fmla z6.h, p0/m, z6.h, z6.h                               \n"
    "  fmla z7.h, p0/m, z7.h, z7.h                               \n"
    "  fmla z8.h, p0/m, z8.h, z8.h                               \n"
    "  fmla z9.h, p0/m, z9.h, z9.h                               \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*10.0*(double)n_iterations;
}


static double fmla_f16_f16_ilp11(const void*) {
  // FMLA (FP16, one vector), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (32x f16, 32x f16) → 32x f16 (64 OPs)
  // Total of 704 OPs per loop iteration, ILP = 11
  size_t n_iterations = N_ITERATIONS/11;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.h                                                  \n"
    "1:                                                          \n"
    "  fmla z0.h, p0/m, z0.h, z0.h                               \n"
    "  fmla z1.h, p0/m, z1.h, z1.h                               \n"
    "  fmla z2.h, p0/m, z2.h, z2.h                               \n"
    "  fmla z3.h, p0/m, z3.h, z3.h                               \n"
    "  fmla z4.h, p0/m, z4.h, z4.h                               \n"
    "  fmla z5.h, p0/m, z5.h, z5.h                               \n"
    "  fmla z6.h, p0/m, z6.h, z6.h                               \n"
    "  fmla z7.h, p0/m, z7.h, z7.h                               \n"
    "  fmla z8.h, p0/m, z8.h, z8.h                               \n"
    "  fmla z9.h, p0/m, z9.h, z9.h                               \n"
    "  fmla z10.h, p0/m, z10.h, z10.h                            \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*11.0*(double)n_iterations;
}


static double fmla_f16_f16_ilp12(const void*) {
  // FMLA (FP16, one vector), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (32x f16, 32x f16) → 32x f16 (64 OPs)
  // Total of 768 OPs per loop iteration, ILP = 12
  size_t n_iterations = N_ITERATIONS/12;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.h                                                  \n"
    "1:                                                          \n"
    "  fmla z0.h, p0/m, z0.h, z0.h                               \n"
    "  fmla z1.h, p0/m, z1.h, z1.h                               \n"
    "  fmla z2.h, p0/m, z2.h, z2.h                               \n"
    "  fmla z3.h, p0/m, z3.h, z3.h                               \n"
    "  fmla z4.h, p0/m, z4.h, z4.h                               \n"
    "  fmla z5.h, p0/m, z5.h, z5.h                               \n"
    "  fmla z6.h, p0/m, z6.h, z6.h                               \n"
    "  fmla z7.h, p0/m, z7.h, z7.h                               \n"
    "  fmla z8.h, p0/m, z8.h, z8.h                               \n"
    "  fmla z9.h, p0/m, z9.h, z9.h                               \n"
    "  fmla z10.h, p0/m, z10.h, z10.h                            \n"
    "  fmla z11.h, p0/m, z11.h, z11.h                            \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*12.0*(double)n_iterations;
}


static double fmla_f16_f16_ilp13(const void*) {
  // FMLA (FP16, one vector), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (32x f16, 32x f16) → 32x f16 (64 OPs)
  // Total of 832 OPs per loop iteration, ILP = 13
  size_t n_iterations = N_ITERATIONS/13;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.h                                                  \n"
    "1:                                                          \n"
    "  fmla z0.h, p0/m, z0.h, z0.h                               \n"
    "  fmla z1.h, p0/m, z1.h, z1.h                               \n"
    "  fmla z2.h, p0/m, z2.h, z2.h                               \n"
    "  fmla z3.h, p0/m, z3.h, z3.h                               \n"
    "  fmla z4.h, p0/m, z4.h, z4.h                               \n"
    "  fmla z5.h, p0/m, z5.h, z5.h                               \n"
    "  fmla z6.h, p0/m, z6.h, z6.h                               \n"
    "  fmla z7.h, p0/m, z7.h, z7.h                               \n"
    "  fmla z8.h, p0/m, z8.h, z8.h                               \n"
    "  fmla z9.h, p0/m, z9.h, z9.h                               \n"
    "  fmla z10.h, p0/m, z10.h, z10.h                            \n"
    "  fmla z11.h, p0/m, z11.h, z11.h                            \n"
    "  fmla z12.h, p0/m, z12.h, z12.h                            \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*13.0*(double)n_iterations;
}


static double fmla_f16_f16_ilp14(const void*) {
  // FMLA (FP16, one vector), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (32x f16, 32x f16) → 32x f16 (64 OPs)
  // Total of 896 OPs per loop iteration, ILP = 14
  size_t n_iterations = N_ITERATIONS/14;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.h                                                  \n"
    "1:                                                          \n"
    "  fmla z0.h, p0/m, z0.h, z0.h                               \n"
    "  fmla z1.h, p0/m, z1.h, z1.h                               \n"
    "  fmla z2.h, p0/m, z2.h, z2.h                               \n"
    "  fmla z3.h, p0/m, z3.h, z3.h                               \n"
    "  fmla z4.h, p0/m, z4.h, z4.h                               \n"
    "  fmla z5.h, p0/m, z5.h, z5.h                               \n"
    "  fmla z6.h, p0/m, z6.h, z6.h                               \n"
    "  fmla z7.h, p0/m, z7.h, z7.h                               \n"
    "  fmla z8.h, p0/m, z8.h, z8.h                               \n"
    "  fmla z9.h, p0/m, z9.h, z9.h                               \n"
    "  fmla z10.h, p0/m, z10.h, z10.h                            \n"
    "  fmla z11.h, p0/m, z11.h, z11.h                            \n"
    "  fmla z12.h, p0/m, z12.h, z12.h                            \n"
    "  fmla z13.h, p0/m, z13.h, z13.h                            \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*14.0*(double)n_iterations;
}


static double fmla_f16_f16_ilp15(const void*) {
  // FMLA (FP16, one vector), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (32x f16, 32x f16) → 32x f16 (64 OPs)
  // Total of 960 OPs per loop iteration, ILP = 15
  size_t n_iterations = N_ITERATIONS/15;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.h                                                  \n"
    "1:                                                          \n"
    "  fmla z0.h, p0/m, z0.h, z0.h                               \n"
    "  fmla z1.h, p0/m, z1.h, z1.h                               \n"
    "  fmla z2.h, p0/m, z2.h, z2.h                               \n"
    "  fmla z3.h, p0/m, z3.h, z3.h                               \n"
    "  fmla z4.h, p0/m, z4.h, z4.h                               \n"
    "  fmla z5.h, p0/m, z5.h, z5.h                               \n"
    "  fmla z6.h, p0/m, z6.h, z6.h                               \n"
    "  fmla z7.h, p0/m, z7.h, z7.h                               \n"
    "  fmla z8.h, p0/m, z8.h, z8.h                               \n"
    "  fmla z9.h, p0/m, z9.h, z9.h                               \n"
    "  fmla z10.h, p0/m, z10.h, z10.h                            \n"
    "  fmla z11.h, p0/m, z11.h, z11.h                            \n"
    "  fmla z12.h, p0/m, z12.h, z12.h                            \n"
    "  fmla z13.h, p0/m, z13.h, z13.h                            \n"
    "  fmla z14.h, p0/m, z14.h, z14.h                            \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*15.0*(double)n_iterations;
}


static double fmla_f16_f16_ilp16(const void*) {
  // FMLA (FP16, one vector), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (32x f16, 32x f16) → 32x f16 (64 OPs)
  // Total of 1024 OPs per loop iteration, ILP = 16
  size_t n_iterations = N_ITERATIONS/16;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.h                                                  \n"
    "1:                                                          \n"
    "  fmla z0.h, p0/m, z0.h, z0.h                               \n"
    "  fmla z1.h, p0/m, z1.h, z1.h                               \n"
    "  fmla z2.h, p0/m, z2.h, z2.h                               \n"
    "  fmla z3.h, p0/m, z3.h, z3.h                               \n"
    "  fmla z4.h, p0/m, z4.h, z4.h                               \n"
    "  fmla z5.h, p0/m, z5.h, z5.h                               \n"
    "  fmla z6.h, p0/m, z6.h, z6.h                               \n"
    "  fmla z7.h, p0/m, z7.h, z7.h                               \n"
    "  fmla z8.h, p0/m, z8.h, z8.h                               \n"
    "  fmla z9.h, p0/m, z9.h, z9.h                               \n"
    "  fmla z10.h, p0/m, z10.h, z10.h                            \n"
    "  fmla z11.h, p0/m, z11.h, z11.h                            \n"
    "  fmla z12.h, p0/m, z12.h, z12.h                            \n"
    "  fmla z13.h, p0/m, z13.h, z13.h                            \n"
    "  fmla z14.h, p0/m, z14.h, z14.h                            \n"
    "  fmla z15.h, p0/m, z15.h, z15.h                            \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*16.0*(double)n_iterations;
}


static double fmla_f32_f32_ilp1(const void*) {
  // FMLA (FP32, one vector), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (16x f32, 16x f32) → 16x f32 (32 OPs)
  // Total of 32 OPs per loop iteration, ILP = 1
  size_t n_iterations = N_ITERATIONS;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.s                                                  \n"
    "1:                                                          \n"
    "  fmla z0.s, p0/m, z0.s, z0.s                               \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 32.0*1.0*(double)n_iterations;
}


static double fmla_f32_f32_ilp2(const void*) {
  // FMLA (FP32, one vector), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (16x f32, 16x f32) → 16x f32 (32 OPs)
  // Total of 64 OPs per loop iteration, ILP = 2
  size_t n_iterations = N_ITERATIONS/2;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.s                                                  \n"
    "1:                                                          \n"
    "  fmla z0.s, p0/m, z0.s, z0.s                               \n"
    "  fmla z1.s, p0/m, z1.s, z1.s                               \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 32.0*2.0*(double)n_iterations;
}


static double fmla_f32_f32_ilp3(const void*) {
  // FMLA (FP32, one vector), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (16x f32, 16x f32) → 16x f32 (32 OPs)
  // Total of 96 OPs per loop iteration, ILP = 3
  size_t n_iterations = N_ITERATIONS/3;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.s                                                  \n"
    "1:                                                          \n"
    "  fmla z0.s, p0/m, z0.s, z0.s                               \n"
    "  fmla z1.s, p0/m, z1.s, z1.s                               \n"
    "  fmla z2.s, p0/m, z2.s, z2.s                               \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 32.0*3.0*(double)n_iterations;
}


static double fmla_f32_f32_ilp4(const void*) {
  // FMLA (FP32, one vector), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (16x f32, 16x f32) → 16x f32 (32 OPs)
  // Total of 128 OPs per loop iteration, ILP = 4
  size_t n_iterations = N_ITERATIONS/4;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.s                                                  \n"
    "1:                                                          \n"
    "  fmla z0.s, p0/m, z0.s, z0.s                               \n"
    "  fmla z1.s, p0/m, z1.s, z1.s                               \n"
    "  fmla z2.s, p0/m, z2.s, z2.s                               \n"
    "  fmla z3.s, p0/m, z3.s, z3.s                               \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 32.0*4.0*(double)n_iterations;
}


static double fmla_f32_f32_ilp5(const void*) {
  // FMLA (FP32, one vector), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (16x f32, 16x f32) → 16x f32 (32 OPs)
  // Total of 160 OPs per loop iteration, ILP = 5
  size_t n_iterations = N_ITERATIONS/5;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.s                                                  \n"
    "1:                                                          \n"
    "  fmla z0.s, p0/m, z0.s, z0.s                               \n"
    "  fmla z1.s, p0/m, z1.s, z1.s                               \n"
    "  fmla z2.s, p0/m, z2.s, z2.s                               \n"
    "  fmla z3.s, p0/m, z3.s, z3.s                               \n"
    "  fmla z4.s, p0/m, z4.s, z4.s                               \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 32.0*5.0*(double)n_iterations;
}


static double fmla_f32_f32_ilp6(const void*) {
  // FMLA (FP32, one vector), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (16x f32, 16x f32) → 16x f32 (32 OPs)
  // Total of 192 OPs per loop iteration, ILP = 6
  size_t n_iterations = N_ITERATIONS/6;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.s                                                  \n"
    "1:                                                          \n"
    "  fmla z0.s, p0/m, z0.s, z0.s                               \n"
    "  fmla z1.s, p0/m, z1.s, z1.s                               \n"
    "  fmla z2.s, p0/m, z2.s, z2.s                               \n"
    "  fmla z3.s, p0/m, z3.s, z3.s                               \n"
    "  fmla z4.s, p0/m, z4.s, z4.s                               \n"
    "  fmla z5.s, p0/m, z5.s, z5.s                               \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 32.0*6.0*(double)n_iterations;
}


static double fmla_f32_f32_ilp7(const void*) {
  // FMLA (FP32, one vector), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (16x f32, 16x f32) → 16x f32 (32 OPs)
  // Total of 224 OPs per loop iteration, ILP = 7
  size_t n_iterations = N_ITERATIONS/7;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.s                                                  \n"
    "1:                                                          \n"
    "  fmla z0.s, p0/m, z0.s, z0.s                               \n"
    "  fmla z1.s, p0/m, z1.s, z1.s                               \n"
    "  fmla z2.s, p0/m, z2.s, z2.s                               \n"
    "  fmla z3.s, p0/m, z3.s, z3.s                               \n"
    "  fmla z4.s, p0/m, z4.s, z4.s                               \n"
    "  fmla z5.s, p0/m, z5.s, z5.s                               \n"
    "  fmla z6.s, p0/m, z6.s, z6.s                               \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 32.0*7.0*(double)n_iterations;
}


static double fmla_f32_f32_ilp8(const void*) {
  // FMLA (FP32, one vector), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (16x f32, 16x f32) → 16x f32 (32 OPs)
  // Total of 256 OPs per loop iteration, ILP = 8
  size_t n_iterations = N_ITERATIONS/8;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.s                                                  \n"
    "1:                                                          \n"
    "  fmla z0.s, p0/m, z0.s, z0.s                               \n"
    "  fmla z1.s, p0/m, z1.s, z1.s                               \n"
    "  fmla z2.s, p0/m, z2.s, z2.s                               \n"
    "  fmla z3.s, p0/m, z3.s, z3.s                               \n"
    "  fmla z4.s, p0/m, z4.s, z4.s                               \n"
    "  fmla z5.s, p0/m, z5.s, z5.s                               \n"
    "  fmla z6.s, p0/m, z6.s, z6.s                               \n"
    "  fmla z7.s, p0/m, z7.s, z7.s                               \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 32.0*8.0*(double)n_iterations;
}


static double fmla_f32_f32_ilp9(const void*) {
  // FMLA (FP32, one vector), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (16x f32, 16x f32) → 16x f32 (32 OPs)
  // Total of 288 OPs per loop iteration, ILP = 9
  size_t n_iterations = N_ITERATIONS/9;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.s                                                  \n"
    "1:                                                          \n"
    "  fmla z0.s, p0/m, z0.s, z0.s                               \n"
    "  fmla z1.s, p0/m, z1.s, z1.s                               \n"
    "  fmla z2.s, p0/m, z2.s, z2.s                               \n"
    "  fmla z3.s, p0/m, z3.s, z3.s                               \n"
    "  fmla z4.s, p0/m, z4.s, z4.s                               \n"
    "  fmla z5.s, p0/m, z5.s, z5.s                               \n"
    "  fmla z6.s, p0/m, z6.s, z6.s                               \n"
    "  fmla z7.s, p0/m, z7.s, z7.s                               \n"
    "  fmla z8.s, p0/m, z8.s, z8.s                               \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 32.0*9.0*(double)n_iterations;
}


static double fmla_f32_f32_ilp10(const void*) {
  // FMLA (FP32, one vector), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (16x f32, 16x f32) → 16x f32 (32 OPs)
  // Total of 320 OPs per loop iteration, ILP = 10
  size_t n_iterations = N_ITERATIONS/10;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.s                                                  \n"
    "1:                                                          \n"
    "  fmla z0.s, p0/m, z0.s, z0.s                               \n"
    "  fmla z1.s, p0/m, z1.s, z1.s                               \n"
    "  fmla z2.s, p0/m, z2.s, z2.s                               \n"
    "  fmla z3.s, p0/m, z3.s, z3.s                               \n"
    "  fmla z4.s, p0/m, z4.s, z4.s                               \n"
    "  fmla z5.s, p0/m, z5.s, z5.s                               \n"
    "  fmla z6.s, p0/m, z6.s, z6.s                               \n"
    "  fmla z7.s, p0/m, z7.s, z7.s                               \n"
    "  fmla z8.s, p0/m, z8.s, z8.s                               \n"
    "  fmla z9.s, p0/m, z9.s, z9.s                               \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 32.0*10.0*(double)n_iterations;
}


static double fmla_f32_f32_ilp11(const void*) {
  // FMLA (FP32, one vector), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (16x f32, 16x f32) → 16x f32 (32 OPs)
  // Total of 352 OPs per loop iteration, ILP = 11
  size_t n_iterations = N_ITERATIONS/11;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.s                                                  \n"
    "1:                                                          \n"
    "  fmla z0.s, p0/m, z0.s, z0.s                               \n"
    "  fmla z1.s, p0/m, z1.s, z1.s                               \n"
    "  fmla z2.s, p0/m, z2.s, z2.s                               \n"
    "  fmla z3.s, p0/m, z3.s, z3.s                               \n"
    "  fmla z4.s, p0/m, z4.s, z4.s                               \n"
    "  fmla z5.s, p0/m, z5.s, z5.s                               \n"
    "  fmla z6.s, p0/m, z6.s, z6.s                               \n"
    "  fmla z7.s, p0/m, z7.s, z7.s                               \n"
    "  fmla z8.s, p0/m, z8.s, z8.s                               \n"
    "  fmla z9.s, p0/m, z9.s, z9.s                               \n"
    "  fmla z10.s, p0/m, z10.s, z10.s                            \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 32.0*11.0*(double)n_iterations;
}


static double fmla_f32_f32_ilp12(const void*) {
  // FMLA (FP32, one vector), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (16x f32, 16x f32) → 16x f32 (32 OPs)
  // Total of 384 OPs per loop iteration, ILP = 12
  size_t n_iterations = N_ITERATIONS/12;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.s                                                  \n"
    "1:                                                          \n"
    "  fmla z0.s, p0/m, z0.s, z0.s                               \n"
    "  fmla z1.s, p0/m, z1.s, z1.s                               \n"
    "  fmla z2.s, p0/m, z2.s, z2.s                               \n"
    "  fmla z3.s, p0/m, z3.s, z3.s                               \n"
    "  fmla z4.s, p0/m, z4.s, z4.s                               \n"
    "  fmla z5.s, p0/m, z5.s, z5.s                               \n"
    "  fmla z6.s, p0/m, z6.s, z6.s                               \n"
    "  fmla z7.s, p0/m, z7.s, z7.s                               \n"
    "  fmla z8.s, p0/m, z8.s, z8.s                               \n"
    "  fmla z9.s, p0/m, z9.s, z9.s                               \n"
    "  fmla z10.s, p0/m, z10.s, z10.s                            \n"
    "  fmla z11.s, p0/m, z11.s, z11.s                            \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 32.0*12.0*(double)n_iterations;
}


static double fmla_f32_f32_ilp13(const void*) {
  // FMLA (FP32, one vector), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (16x f32, 16x f32) → 16x f32 (32 OPs)
  // Total of 416 OPs per loop iteration, ILP = 13
  size_t n_iterations = N_ITERATIONS/13;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.s                                                  \n"
    "1:                                                          \n"
    "  fmla z0.s, p0/m, z0.s, z0.s                               \n"
    "  fmla z1.s, p0/m, z1.s, z1.s                               \n"
    "  fmla z2.s, p0/m, z2.s, z2.s                               \n"
    "  fmla z3.s, p0/m, z3.s, z3.s                               \n"
    "  fmla z4.s, p0/m, z4.s, z4.s                               \n"
    "  fmla z5.s, p0/m, z5.s, z5.s                               \n"
    "  fmla z6.s, p0/m, z6.s, z6.s                               \n"
    "  fmla z7.s, p0/m, z7.s, z7.s                               \n"
    "  fmla z8.s, p0/m, z8.s, z8.s                               \n"
    "  fmla z9.s, p0/m, z9.s, z9.s                               \n"
    "  fmla z10.s, p0/m, z10.s, z10.s                            \n"
    "  fmla z11.s, p0/m, z11.s, z11.s                            \n"
    "  fmla z12.s, p0/m, z12.s, z12.s                            \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 32.0*13.0*(double)n_iterations;
}


static double fmla_f32_f32_ilp14(const void*) {
  // FMLA (FP32, one vector), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (16x f32, 16x f32) → 16x f32 (32 OPs)
  // Total of 448 OPs per loop iteration, ILP = 14
  size_t n_iterations = N_ITERATIONS/14;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.s                                                  \n"
    "1:                                                          \n"
    "  fmla z0.s, p0/m, z0.s, z0.s                               \n"
    "  fmla z1.s, p0/m, z1.s, z1.s                               \n"
    "  fmla z2.s, p0/m, z2.s, z2.s                               \n"
    "  fmla z3.s, p0/m, z3.s, z3.s                               \n"
    "  fmla z4.s, p0/m, z4.s, z4.s                               \n"
    "  fmla z5.s, p0/m, z5.s, z5.s                               \n"
    "  fmla z6.s, p0/m, z6.s, z6.s                               \n"
    "  fmla z7.s, p0/m, z7.s, z7.s                               \n"
    "  fmla z8.s, p0/m, z8.s, z8.s                               \n"
    "  fmla z9.s, p0/m, z9.s, z9.s                               \n"
    "  fmla z10.s, p0/m, z10.s, z10.s                            \n"
    "  fmla z11.s, p0/m, z11.s, z11.s                            \n"
    "  fmla z12.s, p0/m, z12.s, z12.s                            \n"
    "  fmla z13.s, p0/m, z13.s, z13.s                            \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 32.0*14.0*(double)n_iterations;
}


static double fmla_f32_f32_ilp15(const void*) {
  // FMLA (FP32, one vector), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (16x f32, 16x f32) → 16x f32 (32 OPs)
  // Total of 480 OPs per loop iteration, ILP = 15
  size_t n_iterations = N_ITERATIONS/15;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.s                                                  \n"
    "1:                                                          \n"
    "  fmla z0.s, p0/m, z0.s, z0.s                               \n"
    "  fmla z1.s, p0/m, z1.s, z1.s                               \n"
    "  fmla z2.s, p0/m, z2.s, z2.s                               \n"
    "  fmla z3.s, p0/m, z3.s, z3.s                               \n"
    "  fmla z4.s, p0/m, z4.s, z4.s                               \n"
    "  fmla z5.s, p0/m, z5.s, z5.s                               \n"
    "  fmla z6.s, p0/m, z6.s, z6.s                               \n"
    "  fmla z7.s, p0/m, z7.s, z7.s                               \n"
    "  fmla z8.s, p0/m, z8.s, z8.s                               \n"
    "  fmla z9.s, p0/m, z9.s, z9.s                               \n"
    "  fmla z10.s, p0/m, z10.s, z10.s                            \n"
    "  fmla z11.s, p0/m, z11.s, z11.s                            \n"
    "  fmla z12.s, p0/m, z12.s, z12.s                            \n"
    "  fmla z13.s, p0/m, z13.s, z13.s                            \n"
    "  fmla z14.s, p0/m, z14.s, z14.s                            \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 32.0*15.0*(double)n_iterations;
}


static double fmla_f32_f32_ilp16(const void*) {
  // FMLA (FP32, one vector), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (16x f32, 16x f32) → 16x f32 (32 OPs)
  // Total of 512 OPs per loop iteration, ILP = 16
  size_t n_iterations = N_ITERATIONS/16;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.s                                                  \n"
    "1:                                                          \n"
    "  fmla z0.s, p0/m, z0.s, z0.s                               \n"
    "  fmla z1.s, p0/m, z1.s, z1.s                               \n"
    "  fmla z2.s, p0/m, z2.s, z2.s                               \n"
    "  fmla z3.s, p0/m, z3.s, z3.s                               \n"
    "  fmla z4.s, p0/m, z4.s, z4.s                               \n"
    "  fmla z5.s, p0/m, z5.s, z5.s                               \n"
    "  fmla z6.s, p0/m, z6.s, z6.s                               \n"
    "  fmla z7.s, p0/m, z7.s, z7.s                               \n"
    "  fmla z8.s, p0/m, z8.s, z8.s                               \n"
    "  fmla z9.s, p0/m, z9.s, z9.s                               \n"
    "  fmla z10.s, p0/m, z10.s, z10.s                            \n"
    "  fmla z11.s, p0/m, z11.s, z11.s                            \n"
    "  fmla z12.s, p0/m, z12.s, z12.s                            \n"
    "  fmla z13.s, p0/m, z13.s, z13.s                            \n"
    "  fmla z14.s, p0/m, z14.s, z14.s                            \n"
    "  fmla z15.s, p0/m, z15.s, z15.s                            \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 32.0*16.0*(double)n_iterations;
}


static double fmla_f64_f64_ilp1(const void*) {
  // FMLA (FP64, one vector), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (8x f64, 8x f64) → 8x f64 (16 OPs)
  // Total of 16 OPs per loop iteration, ILP = 1
  size_t n_iterations = N_ITERATIONS;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.d                                                  \n"
    "1:                                                          \n"
    "  fmla z0.d, p0/m, z0.d, z0.d                               \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 16.0*1.0*(double)n_iterations;
}


static double fmla_f64_f64_ilp2(const void*) {
  // FMLA (FP64, one vector), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (8x f64, 8x f64) → 8x f64 (16 OPs)
  // Total of 32 OPs per loop iteration, ILP = 2
  size_t n_iterations = N_ITERATIONS/2;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.d                                                  \n"
    "1:                                                          \n"
    "  fmla z0.d, p0/m, z0.d, z0.d                               \n"
    "  fmla z1.d, p0/m, z1.d, z1.d                               \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 16.0*2.0*(double)n_iterations;
}


static double fmla_f64_f64_ilp3(const void*) {
  // FMLA (FP64, one vector), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (8x f64, 8x f64) → 8x f64 (16 OPs)
  // Total of 48 OPs per loop iteration, ILP = 3
  size_t n_iterations = N_ITERATIONS/3;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.d                                                  \n"
    "1:                                                          \n"
    "  fmla z0.d, p0/m, z0.d, z0.d                               \n"
    "  fmla z1.d, p0/m, z1.d, z1.d                               \n"
    "  fmla z2.d, p0/m, z2.d, z2.d                               \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 16.0*3.0*(double)n_iterations;
}


static double fmla_f64_f64_ilp4(const void*) {
  // FMLA (FP64, one vector), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (8x f64, 8x f64) → 8x f64 (16 OPs)
  // Total of 64 OPs per loop iteration, ILP = 4
  size_t n_iterations = N_ITERATIONS/4;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.d                                                  \n"
    "1:                                                          \n"
    "  fmla z0.d, p0/m, z0.d, z0.d                               \n"
    "  fmla z1.d, p0/m, z1.d, z1.d                               \n"
    "  fmla z2.d, p0/m, z2.d, z2.d                               \n"
    "  fmla z3.d, p0/m, z3.d, z3.d                               \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 16.0*4.0*(double)n_iterations;
}


static double fmla_f64_f64_ilp5(const void*) {
  // FMLA (FP64, one vector), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (8x f64, 8x f64) → 8x f64 (16 OPs)
  // Total of 80 OPs per loop iteration, ILP = 5
  size_t n_iterations = N_ITERATIONS/5;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.d                                                  \n"
    "1:                                                          \n"
    "  fmla z0.d, p0/m, z0.d, z0.d                               \n"
    "  fmla z1.d, p0/m, z1.d, z1.d                               \n"
    "  fmla z2.d, p0/m, z2.d, z2.d                               \n"
    "  fmla z3.d, p0/m, z3.d, z3.d                               \n"
    "  fmla z4.d, p0/m, z4.d, z4.d                               \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 16.0*5.0*(double)n_iterations;
}


static double fmla_f64_f64_ilp6(const void*) {
  // FMLA (FP64, one vector), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (8x f64, 8x f64) → 8x f64 (16 OPs)
  // Total of 96 OPs per loop iteration, ILP = 6
  size_t n_iterations = N_ITERATIONS/6;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.d                                                  \n"
    "1:                                                          \n"
    "  fmla z0.d, p0/m, z0.d, z0.d                               \n"
    "  fmla z1.d, p0/m, z1.d, z1.d                               \n"
    "  fmla z2.d, p0/m, z2.d, z2.d                               \n"
    "  fmla z3.d, p0/m, z3.d, z3.d                               \n"
    "  fmla z4.d, p0/m, z4.d, z4.d                               \n"
    "  fmla z5.d, p0/m, z5.d, z5.d                               \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 16.0*6.0*(double)n_iterations;
}


static double fmla_f64_f64_ilp7(const void*) {
  // FMLA (FP64, one vector), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (8x f64, 8x f64) → 8x f64 (16 OPs)
  // Total of 112 OPs per loop iteration, ILP = 7
  size_t n_iterations = N_ITERATIONS/7;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.d                                                  \n"
    "1:                                                          \n"
    "  fmla z0.d, p0/m, z0.d, z0.d                               \n"
    "  fmla z1.d, p0/m, z1.d, z1.d                               \n"
    "  fmla z2.d, p0/m, z2.d, z2.d                               \n"
    "  fmla z3.d, p0/m, z3.d, z3.d                               \n"
    "  fmla z4.d, p0/m, z4.d, z4.d                               \n"
    "  fmla z5.d, p0/m, z5.d, z5.d                               \n"
    "  fmla z6.d, p0/m, z6.d, z6.d                               \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 16.0*7.0*(double)n_iterations;
}


static double fmla_f64_f64_ilp8(const void*) {
  // FMLA (FP64, one vector), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (8x f64, 8x f64) → 8x f64 (16 OPs)
  // Total of 128 OPs per loop iteration, ILP = 8
  size_t n_iterations = N_ITERATIONS/8;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.d                                                  \n"
    "1:                                                          \n"
    "  fmla z0.d, p0/m, z0.d, z0.d                               \n"
    "  fmla z1.d, p0/m, z1.d, z1.d                               \n"
    "  fmla z2.d, p0/m, z2.d, z2.d                               \n"
    "  fmla z3.d, p0/m, z3.d, z3.d                               \n"
    "  fmla z4.d, p0/m, z4.d, z4.d                               \n"
    "  fmla z5.d, p0/m, z5.d, z5.d                               \n"
    "  fmla z6.d, p0/m, z6.d, z6.d                               \n"
    "  fmla z7.d, p0/m, z7.d, z7.d                               \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 16.0*8.0*(double)n_iterations;
}


static double fmla_f64_f64_ilp9(const void*) {
  // FMLA (FP64, one vector), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (8x f64, 8x f64) → 8x f64 (16 OPs)
  // Total of 144 OPs per loop iteration, ILP = 9
  size_t n_iterations = N_ITERATIONS/9;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.d                                                  \n"
    "1:                                                          \n"
    "  fmla z0.d, p0/m, z0.d, z0.d                               \n"
    "  fmla z1.d, p0/m, z1.d, z1.d                               \n"
    "  fmla z2.d, p0/m, z2.d, z2.d                               \n"
    "  fmla z3.d, p0/m, z3.d, z3.d                               \n"
    "  fmla z4.d, p0/m, z4.d, z4.d                               \n"
    "  fmla z5.d, p0/m, z5.d, z5.d                               \n"
    "  fmla z6.d, p0/m, z6.d, z6.d                               \n"
    "  fmla z7.d, p0/m, z7.d, z7.d                               \n"
    "  fmla z8.d, p0/m, z8.d, z8.d                               \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 16.0*9.0*(double)n_iterations;
}


static double fmla_f64_f64_ilp10(const void*) {
  // FMLA (FP64, one vector), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (8x f64, 8x f64) → 8x f64 (16 OPs)
  // Total of 160 OPs per loop iteration, ILP = 10
  size_t n_iterations = N_ITERATIONS/10;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.d                                                  \n"
    "1:                                                          \n"
    "  fmla z0.d, p0/m, z0.d, z0.d                               \n"
    "  fmla z1.d, p0/m, z1.d, z1.d                               \n"
    "  fmla z2.d, p0/m, z2.d, z2.d                               \n"
    "  fmla z3.d, p0/m, z3.d, z3.d                               \n"
    "  fmla z4.d, p0/m, z4.d, z4.d                               \n"
    "  fmla z5.d, p0/m, z5.d, z5.d                               \n"
    "  fmla z6.d, p0/m, z6.d, z6.d                               \n"
    "  fmla z7.d, p0/m, z7.d, z7.d                               \n"
    "  fmla z8.d, p0/m, z8.d, z8.d                               \n"
    "  fmla z9.d, p0/m, z9.d, z9.d                               \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 16.0*10.0*(double)n_iterations;
}


static double fmla_f64_f64_ilp11(const void*) {
  // FMLA (FP64, one vector), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (8x f64, 8x f64) → 8x f64 (16 OPs)
  // Total of 176 OPs per loop iteration, ILP = 11
  size_t n_iterations = N_ITERATIONS/11;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.d                                                  \n"
    "1:                                                          \n"
    "  fmla z0.d, p0/m, z0.d, z0.d                               \n"
    "  fmla z1.d, p0/m, z1.d, z1.d                               \n"
    "  fmla z2.d, p0/m, z2.d, z2.d                               \n"
    "  fmla z3.d, p0/m, z3.d, z3.d                               \n"
    "  fmla z4.d, p0/m, z4.d, z4.d                               \n"
    "  fmla z5.d, p0/m, z5.d, z5.d                               \n"
    "  fmla z6.d, p0/m, z6.d, z6.d                               \n"
    "  fmla z7.d, p0/m, z7.d, z7.d                               \n"
    "  fmla z8.d, p0/m, z8.d, z8.d                               \n"
    "  fmla z9.d, p0/m, z9.d, z9.d                               \n"
    "  fmla z10.d, p0/m, z10.d, z10.d                            \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 16.0*11.0*(double)n_iterations;
}


static double fmla_f64_f64_ilp12(const void*) {
  // FMLA (FP64, one vector), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (8x f64, 8x f64) → 8x f64 (16 OPs)
  // Total of 192 OPs per loop iteration, ILP = 12
  size_t n_iterations = N_ITERATIONS/12;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.d                                                  \n"
    "1:                                                          \n"
    "  fmla z0.d, p0/m, z0.d, z0.d                               \n"
    "  fmla z1.d, p0/m, z1.d, z1.d                               \n"
    "  fmla z2.d, p0/m, z2.d, z2.d                               \n"
    "  fmla z3.d, p0/m, z3.d, z3.d                               \n"
    "  fmla z4.d, p0/m, z4.d, z4.d                               \n"
    "  fmla z5.d, p0/m, z5.d, z5.d                               \n"
    "  fmla z6.d, p0/m, z6.d, z6.d                               \n"
    "  fmla z7.d, p0/m, z7.d, z7.d                               \n"
    "  fmla z8.d, p0/m, z8.d, z8.d                               \n"
    "  fmla z9.d, p0/m, z9.d, z9.d                               \n"
    "  fmla z10.d, p0/m, z10.d, z10.d                            \n"
    "  fmla z11.d, p0/m, z11.d, z11.d                            \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 16.0*12.0*(double)n_iterations;
}


static double fmla_f64_f64_ilp13(const void*) {
  // FMLA (FP64, one vector), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (8x f64, 8x f64) → 8x f64 (16 OPs)
  // Total of 208 OPs per loop iteration, ILP = 13
  size_t n_iterations = N_ITERATIONS/13;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.d                                                  \n"
    "1:                                                          \n"
    "  fmla z0.d, p0/m, z0.d, z0.d                               \n"
    "  fmla z1.d, p0/m, z1.d, z1.d                               \n"
    "  fmla z2.d, p0/m, z2.d, z2.d                               \n"
    "  fmla z3.d, p0/m, z3.d, z3.d                               \n"
    "  fmla z4.d, p0/m, z4.d, z4.d                               \n"
    "  fmla z5.d, p0/m, z5.d, z5.d                               \n"
    "  fmla z6.d, p0/m, z6.d, z6.d                               \n"
    "  fmla z7.d, p0/m, z7.d, z7.d                               \n"
    "  fmla z8.d, p0/m, z8.d, z8.d                               \n"
    "  fmla z9.d, p0/m, z9.d, z9.d                               \n"
    "  fmla z10.d, p0/m, z10.d, z10.d                            \n"
    "  fmla z11.d, p0/m, z11.d, z11.d                            \n"
    "  fmla z12.d, p0/m, z12.d, z12.d                            \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 16.0*13.0*(double)n_iterations;
}


static double fmla_f64_f64_ilp14(const void*) {
  // FMLA (FP64, one vector), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (8x f64, 8x f64) → 8x f64 (16 OPs)
  // Total of 224 OPs per loop iteration, ILP = 14
  size_t n_iterations = N_ITERATIONS/14;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.d                                                  \n"
    "1:                                                          \n"
    "  fmla z0.d, p0/m, z0.d, z0.d                               \n"
    "  fmla z1.d, p0/m, z1.d, z1.d                               \n"
    "  fmla z2.d, p0/m, z2.d, z2.d                               \n"
    "  fmla z3.d, p0/m, z3.d, z3.d                               \n"
    "  fmla z4.d, p0/m, z4.d, z4.d                               \n"
    "  fmla z5.d, p0/m, z5.d, z5.d                               \n"
    "  fmla z6.d, p0/m, z6.d, z6.d                               \n"
    "  fmla z7.d, p0/m, z7.d, z7.d                               \n"
    "  fmla z8.d, p0/m, z8.d, z8.d                               \n"
    "  fmla z9.d, p0/m, z9.d, z9.d                               \n"
    "  fmla z10.d, p0/m, z10.d, z10.d                            \n"
    "  fmla z11.d, p0/m, z11.d, z11.d                            \n"
    "  fmla z12.d, p0/m, z12.d, z12.d                            \n"
    "  fmla z13.d, p0/m, z13.d, z13.d                            \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 16.0*14.0*(double)n_iterations;
}


static double fmla_f64_f64_ilp15(const void*) {
  // FMLA (FP64, one vector), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (8x f64, 8x f64) → 8x f64 (16 OPs)
  // Total of 240 OPs per loop iteration, ILP = 15
  size_t n_iterations = N_ITERATIONS/15;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.d                                                  \n"
    "1:                                                          \n"
    "  fmla z0.d, p0/m, z0.d, z0.d                               \n"
    "  fmla z1.d, p0/m, z1.d, z1.d                               \n"
    "  fmla z2.d, p0/m, z2.d, z2.d                               \n"
    "  fmla z3.d, p0/m, z3.d, z3.d                               \n"
    "  fmla z4.d, p0/m, z4.d, z4.d                               \n"
    "  fmla z5.d, p0/m, z5.d, z5.d                               \n"
    "  fmla z6.d, p0/m, z6.d, z6.d                               \n"
    "  fmla z7.d, p0/m, z7.d, z7.d                               \n"
    "  fmla z8.d, p0/m, z8.d, z8.d                               \n"
    "  fmla z9.d, p0/m, z9.d, z9.d                               \n"
    "  fmla z10.d, p0/m, z10.d, z10.d                            \n"
    "  fmla z11.d, p0/m, z11.d, z11.d                            \n"
    "  fmla z12.d, p0/m, z12.d, z12.d                            \n"
    "  fmla z13.d, p0/m, z13.d, z13.d                            \n"
    "  fmla z14.d, p0/m, z14.d, z14.d                            \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 16.0*15.0*(double)n_iterations;
}


static double fmla_f64_f64_ilp16(const void*) {
  // FMLA (FP64, one vector), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (8x f64, 8x f64) → 8x f64 (16 OPs)
  // Total of 256 OPs per loop iteration, ILP = 16
  size_t n_iterations = N_ITERATIONS/16;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.d                                                  \n"
    "1:                                                          \n"
    "  fmla z0.d, p0/m, z0.d, z0.d                               \n"
    "  fmla z1.d, p0/m, z1.d, z1.d                               \n"
    "  fmla z2.d, p0/m, z2.d, z2.d                               \n"
    "  fmla z3.d, p0/m, z3.d, z3.d                               \n"
    "  fmla z4.d, p0/m, z4.d, z4.d                               \n"
    "  fmla z5.d, p0/m, z5.d, z5.d                               \n"
    "  fmla z6.d, p0/m, z6.d, z6.d                               \n"
    "  fmla z7.d, p0/m, z7.d, z7.d                               \n"
    "  fmla z8.d, p0/m, z8.d, z8.d                               \n"
    "  fmla z9.d, p0/m, z9.d, z9.d                               \n"
    "  fmla z10.d, p0/m, z10.d, z10.d                            \n"
    "  fmla z11.d, p0/m, z11.d, z11.d                            \n"
    "  fmla z12.d, p0/m, z12.d, z12.d                            \n"
    "  fmla z13.d, p0/m, z13.d, z13.d                            \n"
    "  fmla z14.d, p0/m, z14.d, z14.d                            \n"
    "  fmla z15.d, p0/m, z15.d, z15.d                            \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 16.0*16.0*(double)n_iterations;
}


static double fmla_za_f32_f32_vgx2_ilp1(const void*) {
  // FMLA (FP32, two vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (32x f32, 32x f32) → 32x f32 (64 OPs)
  // Total of 64 OPs per loop iteration, ILP = 1
  size_t n_iterations = N_ITERATIONS;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fmla za.s[w8, 0, VGx2], {z0.s-z1.s}, {z0.s-z1.s}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*1.0*(double)n_iterations;
}


static double fmla_za_f32_f32_vgx2_ilp2(const void*) {
  // FMLA (FP32, two vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (32x f32, 32x f32) → 32x f32 (64 OPs)
  // Total of 128 OPs per loop iteration, ILP = 2
  size_t n_iterations = N_ITERATIONS/2;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fmla za.s[w8, 0, VGx2], {z0.s-z1.s}, {z0.s-z1.s}          \n"
    "  fmla za.s[w8, 1, VGx2], {z0.s-z1.s}, {z0.s-z1.s}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*2.0*(double)n_iterations;
}


static double fmla_za_f32_f32_vgx2_ilp3(const void*) {
  // FMLA (FP32, two vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (32x f32, 32x f32) → 32x f32 (64 OPs)
  // Total of 192 OPs per loop iteration, ILP = 3
  size_t n_iterations = N_ITERATIONS/3;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fmla za.s[w8, 0, VGx2], {z0.s-z1.s}, {z0.s-z1.s}          \n"
    "  fmla za.s[w8, 1, VGx2], {z0.s-z1.s}, {z0.s-z1.s}          \n"
    "  fmla za.s[w8, 2, VGx2], {z2.s-z3.s}, {z2.s-z3.s}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*3.0*(double)n_iterations;
}


static double fmla_za_f32_f32_vgx2_ilp4(const void*) {
  // FMLA (FP32, two vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (32x f32, 32x f32) → 32x f32 (64 OPs)
  // Total of 256 OPs per loop iteration, ILP = 4
  size_t n_iterations = N_ITERATIONS/4;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fmla za.s[w8, 0, VGx2], {z0.s-z1.s}, {z0.s-z1.s}          \n"
    "  fmla za.s[w8, 1, VGx2], {z0.s-z1.s}, {z0.s-z1.s}          \n"
    "  fmla za.s[w8, 2, VGx2], {z2.s-z3.s}, {z2.s-z3.s}          \n"
    "  fmla za.s[w8, 3, VGx2], {z2.s-z3.s}, {z2.s-z3.s}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*4.0*(double)n_iterations;
}


static double fmla_za_f32_f32_vgx2_ilp5(const void*) {
  // FMLA (FP32, two vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (32x f32, 32x f32) → 32x f32 (64 OPs)
  // Total of 320 OPs per loop iteration, ILP = 5
  size_t n_iterations = N_ITERATIONS/5;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fmla za.s[w8, 0, VGx2], {z0.s-z1.s}, {z0.s-z1.s}          \n"
    "  fmla za.s[w8, 1, VGx2], {z0.s-z1.s}, {z0.s-z1.s}          \n"
    "  fmla za.s[w8, 2, VGx2], {z2.s-z3.s}, {z2.s-z3.s}          \n"
    "  fmla za.s[w8, 3, VGx2], {z2.s-z3.s}, {z2.s-z3.s}          \n"
    "  fmla za.s[w8, 4, VGx2], {z4.s-z5.s}, {z4.s-z5.s}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*5.0*(double)n_iterations;
}


static double fmla_za_f32_f32_vgx2_ilp6(const void*) {
  // FMLA (FP32, two vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (32x f32, 32x f32) → 32x f32 (64 OPs)
  // Total of 384 OPs per loop iteration, ILP = 6
  size_t n_iterations = N_ITERATIONS/6;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fmla za.s[w8, 0, VGx2], {z0.s-z1.s}, {z0.s-z1.s}          \n"
    "  fmla za.s[w8, 1, VGx2], {z0.s-z1.s}, {z0.s-z1.s}          \n"
    "  fmla za.s[w8, 2, VGx2], {z2.s-z3.s}, {z2.s-z3.s}          \n"
    "  fmla za.s[w8, 3, VGx2], {z2.s-z3.s}, {z2.s-z3.s}          \n"
    "  fmla za.s[w8, 4, VGx2], {z4.s-z5.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 5, VGx2], {z4.s-z5.s}, {z4.s-z5.s}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*6.0*(double)n_iterations;
}


static double fmla_za_f32_f32_vgx2_ilp7(const void*) {
  // FMLA (FP32, two vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (32x f32, 32x f32) → 32x f32 (64 OPs)
  // Total of 448 OPs per loop iteration, ILP = 7
  size_t n_iterations = N_ITERATIONS/7;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fmla za.s[w8, 0, VGx2], {z0.s-z1.s}, {z0.s-z1.s}          \n"
    "  fmla za.s[w8, 1, VGx2], {z0.s-z1.s}, {z0.s-z1.s}          \n"
    "  fmla za.s[w8, 2, VGx2], {z2.s-z3.s}, {z2.s-z3.s}          \n"
    "  fmla za.s[w8, 3, VGx2], {z2.s-z3.s}, {z2.s-z3.s}          \n"
    "  fmla za.s[w8, 4, VGx2], {z4.s-z5.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 5, VGx2], {z4.s-z5.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 6, VGx2], {z6.s-z7.s}, {z6.s-z7.s}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*7.0*(double)n_iterations;
}


static double fmla_za_f32_f32_vgx2_ilp8(const void*) {
  // FMLA (FP32, two vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (32x f32, 32x f32) → 32x f32 (64 OPs)
  // Total of 512 OPs per loop iteration, ILP = 8
  size_t n_iterations = N_ITERATIONS/8;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fmla za.s[w8, 0, VGx2], {z0.s-z1.s}, {z0.s-z1.s}          \n"
    "  fmla za.s[w8, 1, VGx2], {z0.s-z1.s}, {z0.s-z1.s}          \n"
    "  fmla za.s[w8, 2, VGx2], {z2.s-z3.s}, {z2.s-z3.s}          \n"
    "  fmla za.s[w8, 3, VGx2], {z2.s-z3.s}, {z2.s-z3.s}          \n"
    "  fmla za.s[w8, 4, VGx2], {z4.s-z5.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 5, VGx2], {z4.s-z5.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 6, VGx2], {z6.s-z7.s}, {z6.s-z7.s}          \n"
    "  fmla za.s[w8, 7, VGx2], {z6.s-z7.s}, {z6.s-z7.s}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*8.0*(double)n_iterations;
}


static double fmla_za_f32_f32_vgx2_ilp9(const void*) {
  // FMLA (FP32, two vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (32x f32, 32x f32) → 32x f32 (64 OPs)
  // Total of 576 OPs per loop iteration, ILP = 9
  size_t n_iterations = N_ITERATIONS/9;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fmla za.s[w8, 0, VGx2], {z0.s-z1.s}, {z0.s-z1.s}          \n"
    "  fmla za.s[w8, 1, VGx2], {z0.s-z1.s}, {z0.s-z1.s}          \n"
    "  fmla za.s[w8, 2, VGx2], {z2.s-z3.s}, {z2.s-z3.s}          \n"
    "  fmla za.s[w8, 3, VGx2], {z2.s-z3.s}, {z2.s-z3.s}          \n"
    "  fmla za.s[w8, 4, VGx2], {z4.s-z5.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 5, VGx2], {z4.s-z5.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 6, VGx2], {z6.s-z7.s}, {z6.s-z7.s}          \n"
    "  fmla za.s[w8, 7, VGx2], {z6.s-z7.s}, {z6.s-z7.s}          \n"
    "  fmla za.s[w9, 0, VGx2], {z8.s-z9.s}, {z8.s-z9.s}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*9.0*(double)n_iterations;
}


static double fmla_za_f32_f32_vgx2_ilp10(const void*) {
  // FMLA (FP32, two vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (32x f32, 32x f32) → 32x f32 (64 OPs)
  // Total of 640 OPs per loop iteration, ILP = 10
  size_t n_iterations = N_ITERATIONS/10;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fmla za.s[w8, 0, VGx2], {z0.s-z1.s}, {z0.s-z1.s}          \n"
    "  fmla za.s[w8, 1, VGx2], {z0.s-z1.s}, {z0.s-z1.s}          \n"
    "  fmla za.s[w8, 2, VGx2], {z2.s-z3.s}, {z2.s-z3.s}          \n"
    "  fmla za.s[w8, 3, VGx2], {z2.s-z3.s}, {z2.s-z3.s}          \n"
    "  fmla za.s[w8, 4, VGx2], {z4.s-z5.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 5, VGx2], {z4.s-z5.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 6, VGx2], {z6.s-z7.s}, {z6.s-z7.s}          \n"
    "  fmla za.s[w8, 7, VGx2], {z6.s-z7.s}, {z6.s-z7.s}          \n"
    "  fmla za.s[w9, 0, VGx2], {z8.s-z9.s}, {z8.s-z9.s}          \n"
    "  fmla za.s[w9, 1, VGx2], {z8.s-z9.s}, {z8.s-z9.s}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*10.0*(double)n_iterations;
}


static double fmla_za_f32_f32_vgx2_ilp11(const void*) {
  // FMLA (FP32, two vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (32x f32, 32x f32) → 32x f32 (64 OPs)
  // Total of 704 OPs per loop iteration, ILP = 11
  size_t n_iterations = N_ITERATIONS/11;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fmla za.s[w8, 0, VGx2], {z0.s-z1.s}, {z0.s-z1.s}          \n"
    "  fmla za.s[w8, 1, VGx2], {z0.s-z1.s}, {z0.s-z1.s}          \n"
    "  fmla za.s[w8, 2, VGx2], {z2.s-z3.s}, {z2.s-z3.s}          \n"
    "  fmla za.s[w8, 3, VGx2], {z2.s-z3.s}, {z2.s-z3.s}          \n"
    "  fmla za.s[w8, 4, VGx2], {z4.s-z5.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 5, VGx2], {z4.s-z5.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 6, VGx2], {z6.s-z7.s}, {z6.s-z7.s}          \n"
    "  fmla za.s[w8, 7, VGx2], {z6.s-z7.s}, {z6.s-z7.s}          \n"
    "  fmla za.s[w9, 0, VGx2], {z8.s-z9.s}, {z8.s-z9.s}          \n"
    "  fmla za.s[w9, 1, VGx2], {z8.s-z9.s}, {z8.s-z9.s}          \n"
    "  fmla za.s[w9, 2, VGx2], {z10.s-z11.s}, {z10.s-z11.s}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*11.0*(double)n_iterations;
}


static double fmla_za_f32_f32_vgx2_ilp12(const void*) {
  // FMLA (FP32, two vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (32x f32, 32x f32) → 32x f32 (64 OPs)
  // Total of 768 OPs per loop iteration, ILP = 12
  size_t n_iterations = N_ITERATIONS/12;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fmla za.s[w8, 0, VGx2], {z0.s-z1.s}, {z0.s-z1.s}          \n"
    "  fmla za.s[w8, 1, VGx2], {z0.s-z1.s}, {z0.s-z1.s}          \n"
    "  fmla za.s[w8, 2, VGx2], {z2.s-z3.s}, {z2.s-z3.s}          \n"
    "  fmla za.s[w8, 3, VGx2], {z2.s-z3.s}, {z2.s-z3.s}          \n"
    "  fmla za.s[w8, 4, VGx2], {z4.s-z5.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 5, VGx2], {z4.s-z5.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 6, VGx2], {z6.s-z7.s}, {z6.s-z7.s}          \n"
    "  fmla za.s[w8, 7, VGx2], {z6.s-z7.s}, {z6.s-z7.s}          \n"
    "  fmla za.s[w9, 0, VGx2], {z8.s-z9.s}, {z8.s-z9.s}          \n"
    "  fmla za.s[w9, 1, VGx2], {z8.s-z9.s}, {z8.s-z9.s}          \n"
    "  fmla za.s[w9, 2, VGx2], {z10.s-z11.s}, {z10.s-z11.s}      \n"
    "  fmla za.s[w9, 3, VGx2], {z10.s-z11.s}, {z10.s-z11.s}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*12.0*(double)n_iterations;
}


static double fmla_za_f32_f32_vgx2_ilp13(const void*) {
  // FMLA (FP32, two vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (32x f32, 32x f32) → 32x f32 (64 OPs)
  // Total of 832 OPs per loop iteration, ILP = 13
  size_t n_iterations = N_ITERATIONS/13;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fmla za.s[w8, 0, VGx2], {z0.s-z1.s}, {z0.s-z1.s}          \n"
    "  fmla za.s[w8, 1, VGx2], {z0.s-z1.s}, {z0.s-z1.s}          \n"
    "  fmla za.s[w8, 2, VGx2], {z2.s-z3.s}, {z2.s-z3.s}          \n"
    "  fmla za.s[w8, 3, VGx2], {z2.s-z3.s}, {z2.s-z3.s}          \n"
    "  fmla za.s[w8, 4, VGx2], {z4.s-z5.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 5, VGx2], {z4.s-z5.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 6, VGx2], {z6.s-z7.s}, {z6.s-z7.s}          \n"
    "  fmla za.s[w8, 7, VGx2], {z6.s-z7.s}, {z6.s-z7.s}          \n"
    "  fmla za.s[w9, 0, VGx2], {z8.s-z9.s}, {z8.s-z9.s}          \n"
    "  fmla za.s[w9, 1, VGx2], {z8.s-z9.s}, {z8.s-z9.s}          \n"
    "  fmla za.s[w9, 2, VGx2], {z10.s-z11.s}, {z10.s-z11.s}      \n"
    "  fmla za.s[w9, 3, VGx2], {z10.s-z11.s}, {z10.s-z11.s}      \n"
    "  fmla za.s[w9, 4, VGx2], {z12.s-z13.s}, {z12.s-z13.s}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*13.0*(double)n_iterations;
}


static double fmla_za_f32_f32_vgx2_ilp14(const void*) {
  // FMLA (FP32, two vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (32x f32, 32x f32) → 32x f32 (64 OPs)
  // Total of 896 OPs per loop iteration, ILP = 14
  size_t n_iterations = N_ITERATIONS/14;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fmla za.s[w8, 0, VGx2], {z0.s-z1.s}, {z0.s-z1.s}          \n"
    "  fmla za.s[w8, 1, VGx2], {z0.s-z1.s}, {z0.s-z1.s}          \n"
    "  fmla za.s[w8, 2, VGx2], {z2.s-z3.s}, {z2.s-z3.s}          \n"
    "  fmla za.s[w8, 3, VGx2], {z2.s-z3.s}, {z2.s-z3.s}          \n"
    "  fmla za.s[w8, 4, VGx2], {z4.s-z5.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 5, VGx2], {z4.s-z5.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 6, VGx2], {z6.s-z7.s}, {z6.s-z7.s}          \n"
    "  fmla za.s[w8, 7, VGx2], {z6.s-z7.s}, {z6.s-z7.s}          \n"
    "  fmla za.s[w9, 0, VGx2], {z8.s-z9.s}, {z8.s-z9.s}          \n"
    "  fmla za.s[w9, 1, VGx2], {z8.s-z9.s}, {z8.s-z9.s}          \n"
    "  fmla za.s[w9, 2, VGx2], {z10.s-z11.s}, {z10.s-z11.s}      \n"
    "  fmla za.s[w9, 3, VGx2], {z10.s-z11.s}, {z10.s-z11.s}      \n"
    "  fmla za.s[w9, 4, VGx2], {z12.s-z13.s}, {z12.s-z13.s}      \n"
    "  fmla za.s[w9, 5, VGx2], {z12.s-z13.s}, {z12.s-z13.s}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*14.0*(double)n_iterations;
}


static double fmla_za_f32_f32_vgx2_ilp15(const void*) {
  // FMLA (FP32, two vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (32x f32, 32x f32) → 32x f32 (64 OPs)
  // Total of 960 OPs per loop iteration, ILP = 15
  size_t n_iterations = N_ITERATIONS/15;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fmla za.s[w8, 0, VGx2], {z0.s-z1.s}, {z0.s-z1.s}          \n"
    "  fmla za.s[w8, 1, VGx2], {z0.s-z1.s}, {z0.s-z1.s}          \n"
    "  fmla za.s[w8, 2, VGx2], {z2.s-z3.s}, {z2.s-z3.s}          \n"
    "  fmla za.s[w8, 3, VGx2], {z2.s-z3.s}, {z2.s-z3.s}          \n"
    "  fmla za.s[w8, 4, VGx2], {z4.s-z5.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 5, VGx2], {z4.s-z5.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 6, VGx2], {z6.s-z7.s}, {z6.s-z7.s}          \n"
    "  fmla za.s[w8, 7, VGx2], {z6.s-z7.s}, {z6.s-z7.s}          \n"
    "  fmla za.s[w9, 0, VGx2], {z8.s-z9.s}, {z8.s-z9.s}          \n"
    "  fmla za.s[w9, 1, VGx2], {z8.s-z9.s}, {z8.s-z9.s}          \n"
    "  fmla za.s[w9, 2, VGx2], {z10.s-z11.s}, {z10.s-z11.s}      \n"
    "  fmla za.s[w9, 3, VGx2], {z10.s-z11.s}, {z10.s-z11.s}      \n"
    "  fmla za.s[w9, 4, VGx2], {z12.s-z13.s}, {z12.s-z13.s}      \n"
    "  fmla za.s[w9, 5, VGx2], {z12.s-z13.s}, {z12.s-z13.s}      \n"
    "  fmla za.s[w9, 6, VGx2], {z14.s-z15.s}, {z14.s-z15.s}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*15.0*(double)n_iterations;
}


static double fmla_za_f32_f32_vgx2_ilp16(const void*) {
  // FMLA (FP32, two vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (32x f32, 32x f32) → 32x f32 (64 OPs)
  // Total of 1024 OPs per loop iteration, ILP = 16
  size_t n_iterations = N_ITERATIONS/16;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fmla za.s[w8, 0, VGx2], {z0.s-z1.s}, {z0.s-z1.s}          \n"
    "  fmla za.s[w8, 1, VGx2], {z0.s-z1.s}, {z0.s-z1.s}          \n"
    "  fmla za.s[w8, 2, VGx2], {z2.s-z3.s}, {z2.s-z3.s}          \n"
    "  fmla za.s[w8, 3, VGx2], {z2.s-z3.s}, {z2.s-z3.s}          \n"
    "  fmla za.s[w8, 4, VGx2], {z4.s-z5.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 5, VGx2], {z4.s-z5.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 6, VGx2], {z6.s-z7.s}, {z6.s-z7.s}          \n"
    "  fmla za.s[w8, 7, VGx2], {z6.s-z7.s}, {z6.s-z7.s}          \n"
    "  fmla za.s[w9, 0, VGx2], {z8.s-z9.s}, {z8.s-z9.s}          \n"
    "  fmla za.s[w9, 1, VGx2], {z8.s-z9.s}, {z8.s-z9.s}          \n"
    "  fmla za.s[w9, 2, VGx2], {z10.s-z11.s}, {z10.s-z11.s}      \n"
    "  fmla za.s[w9, 3, VGx2], {z10.s-z11.s}, {z10.s-z11.s}      \n"
    "  fmla za.s[w9, 4, VGx2], {z12.s-z13.s}, {z12.s-z13.s}      \n"
    "  fmla za.s[w9, 5, VGx2], {z12.s-z13.s}, {z12.s-z13.s}      \n"
    "  fmla za.s[w9, 6, VGx2], {z14.s-z15.s}, {z14.s-z15.s}      \n"
    "  fmla za.s[w9, 7, VGx2], {z14.s-z15.s}, {z14.s-z15.s}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*16.0*(double)n_iterations;
}


static double fmla_za_f32_f32_vgx4_ilp1(const void*) {
  // FMLA (FP32, four vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (64x f32, 64x f32) → 64x f32 (128 OPs)
  // Total of 128 OPs per loop iteration, ILP = 1
  size_t n_iterations = N_ITERATIONS;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fmla za.s[w8, 0, VGx4], {z0.s-z3.s}, {z0.s-z3.s}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*1.0*(double)n_iterations;
}


static double fmla_za_f32_f32_vgx4_ilp2(const void*) {
  // FMLA (FP32, four vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (64x f32, 64x f32) → 64x f32 (128 OPs)
  // Total of 256 OPs per loop iteration, ILP = 2
  size_t n_iterations = N_ITERATIONS/2;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fmla za.s[w8, 0, VGx4], {z0.s-z3.s}, {z0.s-z3.s}          \n"
    "  fmla za.s[w8, 1, VGx4], {z0.s-z3.s}, {z0.s-z3.s}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*2.0*(double)n_iterations;
}


static double fmla_za_f32_f32_vgx4_ilp3(const void*) {
  // FMLA (FP32, four vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (64x f32, 64x f32) → 64x f32 (128 OPs)
  // Total of 384 OPs per loop iteration, ILP = 3
  size_t n_iterations = N_ITERATIONS/3;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fmla za.s[w8, 0, VGx4], {z0.s-z3.s}, {z0.s-z3.s}          \n"
    "  fmla za.s[w8, 1, VGx4], {z0.s-z3.s}, {z0.s-z3.s}          \n"
    "  fmla za.s[w8, 2, VGx4], {z0.s-z3.s}, {z0.s-z3.s}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*3.0*(double)n_iterations;
}


static double fmla_za_f32_f32_vgx4_ilp4(const void*) {
  // FMLA (FP32, four vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (64x f32, 64x f32) → 64x f32 (128 OPs)
  // Total of 512 OPs per loop iteration, ILP = 4
  size_t n_iterations = N_ITERATIONS/4;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fmla za.s[w8, 0, VGx4], {z0.s-z3.s}, {z0.s-z3.s}          \n"
    "  fmla za.s[w8, 1, VGx4], {z0.s-z3.s}, {z0.s-z3.s}          \n"
    "  fmla za.s[w8, 2, VGx4], {z0.s-z3.s}, {z0.s-z3.s}          \n"
    "  fmla za.s[w8, 3, VGx4], {z0.s-z3.s}, {z0.s-z3.s}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*4.0*(double)n_iterations;
}


static double fmla_za_f32_f32_vgx4_ilp5(const void*) {
  // FMLA (FP32, four vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (64x f32, 64x f32) → 64x f32 (128 OPs)
  // Total of 640 OPs per loop iteration, ILP = 5
  size_t n_iterations = N_ITERATIONS/5;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fmla za.s[w8, 0, VGx4], {z0.s-z3.s}, {z0.s-z3.s}          \n"
    "  fmla za.s[w8, 1, VGx4], {z0.s-z3.s}, {z0.s-z3.s}          \n"
    "  fmla za.s[w8, 2, VGx4], {z0.s-z3.s}, {z0.s-z3.s}          \n"
    "  fmla za.s[w8, 3, VGx4], {z0.s-z3.s}, {z0.s-z3.s}          \n"
    "  fmla za.s[w8, 4, VGx4], {z4.s-z7.s}, {z4.s-z7.s}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*5.0*(double)n_iterations;
}


static double fmla_za_f32_f32_vgx4_ilp6(const void*) {
  // FMLA (FP32, four vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (64x f32, 64x f32) → 64x f32 (128 OPs)
  // Total of 768 OPs per loop iteration, ILP = 6
  size_t n_iterations = N_ITERATIONS/6;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fmla za.s[w8, 0, VGx4], {z0.s-z3.s}, {z0.s-z3.s}          \n"
    "  fmla za.s[w8, 1, VGx4], {z0.s-z3.s}, {z0.s-z3.s}          \n"
    "  fmla za.s[w8, 2, VGx4], {z0.s-z3.s}, {z0.s-z3.s}          \n"
    "  fmla za.s[w8, 3, VGx4], {z0.s-z3.s}, {z0.s-z3.s}          \n"
    "  fmla za.s[w8, 4, VGx4], {z4.s-z7.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 5, VGx4], {z4.s-z7.s}, {z4.s-z7.s}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*6.0*(double)n_iterations;
}


static double fmla_za_f32_f32_vgx4_ilp7(const void*) {
  // FMLA (FP32, four vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (64x f32, 64x f32) → 64x f32 (128 OPs)
  // Total of 896 OPs per loop iteration, ILP = 7
  size_t n_iterations = N_ITERATIONS/7;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fmla za.s[w8, 0, VGx4], {z0.s-z3.s}, {z0.s-z3.s}          \n"
    "  fmla za.s[w8, 1, VGx4], {z0.s-z3.s}, {z0.s-z3.s}          \n"
    "  fmla za.s[w8, 2, VGx4], {z0.s-z3.s}, {z0.s-z3.s}          \n"
    "  fmla za.s[w8, 3, VGx4], {z0.s-z3.s}, {z0.s-z3.s}          \n"
    "  fmla za.s[w8, 4, VGx4], {z4.s-z7.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 5, VGx4], {z4.s-z7.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 6, VGx4], {z4.s-z7.s}, {z4.s-z7.s}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*7.0*(double)n_iterations;
}


static double fmla_za_f32_f32_vgx4_ilp8(const void*) {
  // FMLA (FP32, four vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (64x f32, 64x f32) → 64x f32 (128 OPs)
  // Total of 1024 OPs per loop iteration, ILP = 8
  size_t n_iterations = N_ITERATIONS/8;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fmla za.s[w8, 0, VGx4], {z0.s-z3.s}, {z0.s-z3.s}          \n"
    "  fmla za.s[w8, 1, VGx4], {z0.s-z3.s}, {z0.s-z3.s}          \n"
    "  fmla za.s[w8, 2, VGx4], {z0.s-z3.s}, {z0.s-z3.s}          \n"
    "  fmla za.s[w8, 3, VGx4], {z0.s-z3.s}, {z0.s-z3.s}          \n"
    "  fmla za.s[w8, 4, VGx4], {z4.s-z7.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 5, VGx4], {z4.s-z7.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 6, VGx4], {z4.s-z7.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 7, VGx4], {z4.s-z7.s}, {z4.s-z7.s}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*8.0*(double)n_iterations;
}


static double fmla_za_f32_f32_vgx4_ilp9(const void*) {
  // FMLA (FP32, four vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (64x f32, 64x f32) → 64x f32 (128 OPs)
  // Total of 1152 OPs per loop iteration, ILP = 9
  size_t n_iterations = N_ITERATIONS/9;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fmla za.s[w8, 0, VGx4], {z0.s-z3.s}, {z0.s-z3.s}          \n"
    "  fmla za.s[w8, 1, VGx4], {z0.s-z3.s}, {z0.s-z3.s}          \n"
    "  fmla za.s[w8, 2, VGx4], {z0.s-z3.s}, {z0.s-z3.s}          \n"
    "  fmla za.s[w8, 3, VGx4], {z0.s-z3.s}, {z0.s-z3.s}          \n"
    "  fmla za.s[w8, 4, VGx4], {z4.s-z7.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 5, VGx4], {z4.s-z7.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 6, VGx4], {z4.s-z7.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 7, VGx4], {z4.s-z7.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w9, 0, VGx4], {z8.s-z11.s}, {z8.s-z11.s}        \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*9.0*(double)n_iterations;
}


static double fmla_za_f32_f32_vgx4_ilp10(const void*) {
  // FMLA (FP32, four vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (64x f32, 64x f32) → 64x f32 (128 OPs)
  // Total of 1280 OPs per loop iteration, ILP = 10
  size_t n_iterations = N_ITERATIONS/10;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fmla za.s[w8, 0, VGx4], {z0.s-z3.s}, {z0.s-z3.s}          \n"
    "  fmla za.s[w8, 1, VGx4], {z0.s-z3.s}, {z0.s-z3.s}          \n"
    "  fmla za.s[w8, 2, VGx4], {z0.s-z3.s}, {z0.s-z3.s}          \n"
    "  fmla za.s[w8, 3, VGx4], {z0.s-z3.s}, {z0.s-z3.s}          \n"
    "  fmla za.s[w8, 4, VGx4], {z4.s-z7.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 5, VGx4], {z4.s-z7.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 6, VGx4], {z4.s-z7.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 7, VGx4], {z4.s-z7.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w9, 0, VGx4], {z8.s-z11.s}, {z8.s-z11.s}        \n"
    "  fmla za.s[w9, 1, VGx4], {z8.s-z11.s}, {z8.s-z11.s}        \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*10.0*(double)n_iterations;
}


static double fmla_za_f32_f32_vgx4_ilp11(const void*) {
  // FMLA (FP32, four vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (64x f32, 64x f32) → 64x f32 (128 OPs)
  // Total of 1408 OPs per loop iteration, ILP = 11
  size_t n_iterations = N_ITERATIONS/11;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fmla za.s[w8, 0, VGx4], {z0.s-z3.s}, {z0.s-z3.s}          \n"
    "  fmla za.s[w8, 1, VGx4], {z0.s-z3.s}, {z0.s-z3.s}          \n"
    "  fmla za.s[w8, 2, VGx4], {z0.s-z3.s}, {z0.s-z3.s}          \n"
    "  fmla za.s[w8, 3, VGx4], {z0.s-z3.s}, {z0.s-z3.s}          \n"
    "  fmla za.s[w8, 4, VGx4], {z4.s-z7.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 5, VGx4], {z4.s-z7.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 6, VGx4], {z4.s-z7.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 7, VGx4], {z4.s-z7.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w9, 0, VGx4], {z8.s-z11.s}, {z8.s-z11.s}        \n"
    "  fmla za.s[w9, 1, VGx4], {z8.s-z11.s}, {z8.s-z11.s}        \n"
    "  fmla za.s[w9, 2, VGx4], {z8.s-z11.s}, {z8.s-z11.s}        \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*11.0*(double)n_iterations;
}


static double fmla_za_f32_f32_vgx4_ilp12(const void*) {
  // FMLA (FP32, four vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (64x f32, 64x f32) → 64x f32 (128 OPs)
  // Total of 1536 OPs per loop iteration, ILP = 12
  size_t n_iterations = N_ITERATIONS/12;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fmla za.s[w8, 0, VGx4], {z0.s-z3.s}, {z0.s-z3.s}          \n"
    "  fmla za.s[w8, 1, VGx4], {z0.s-z3.s}, {z0.s-z3.s}          \n"
    "  fmla za.s[w8, 2, VGx4], {z0.s-z3.s}, {z0.s-z3.s}          \n"
    "  fmla za.s[w8, 3, VGx4], {z0.s-z3.s}, {z0.s-z3.s}          \n"
    "  fmla za.s[w8, 4, VGx4], {z4.s-z7.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 5, VGx4], {z4.s-z7.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 6, VGx4], {z4.s-z7.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 7, VGx4], {z4.s-z7.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w9, 0, VGx4], {z8.s-z11.s}, {z8.s-z11.s}        \n"
    "  fmla za.s[w9, 1, VGx4], {z8.s-z11.s}, {z8.s-z11.s}        \n"
    "  fmla za.s[w9, 2, VGx4], {z8.s-z11.s}, {z8.s-z11.s}        \n"
    "  fmla za.s[w9, 3, VGx4], {z8.s-z11.s}, {z8.s-z11.s}        \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*12.0*(double)n_iterations;
}


static double fmla_za_f32_f32_vgx4_ilp13(const void*) {
  // FMLA (FP32, four vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (64x f32, 64x f32) → 64x f32 (128 OPs)
  // Total of 1664 OPs per loop iteration, ILP = 13
  size_t n_iterations = N_ITERATIONS/13;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fmla za.s[w8, 0, VGx4], {z0.s-z3.s}, {z0.s-z3.s}          \n"
    "  fmla za.s[w8, 1, VGx4], {z0.s-z3.s}, {z0.s-z3.s}          \n"
    "  fmla za.s[w8, 2, VGx4], {z0.s-z3.s}, {z0.s-z3.s}          \n"
    "  fmla za.s[w8, 3, VGx4], {z0.s-z3.s}, {z0.s-z3.s}          \n"
    "  fmla za.s[w8, 4, VGx4], {z4.s-z7.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 5, VGx4], {z4.s-z7.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 6, VGx4], {z4.s-z7.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 7, VGx4], {z4.s-z7.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w9, 0, VGx4], {z8.s-z11.s}, {z8.s-z11.s}        \n"
    "  fmla za.s[w9, 1, VGx4], {z8.s-z11.s}, {z8.s-z11.s}        \n"
    "  fmla za.s[w9, 2, VGx4], {z8.s-z11.s}, {z8.s-z11.s}        \n"
    "  fmla za.s[w9, 3, VGx4], {z8.s-z11.s}, {z8.s-z11.s}        \n"
    "  fmla za.s[w9, 4, VGx4], {z12.s-z15.s}, {z12.s-z15.s}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*13.0*(double)n_iterations;
}


static double fmla_za_f32_f32_vgx4_ilp14(const void*) {
  // FMLA (FP32, four vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (64x f32, 64x f32) → 64x f32 (128 OPs)
  // Total of 1792 OPs per loop iteration, ILP = 14
  size_t n_iterations = N_ITERATIONS/14;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fmla za.s[w8, 0, VGx4], {z0.s-z3.s}, {z0.s-z3.s}          \n"
    "  fmla za.s[w8, 1, VGx4], {z0.s-z3.s}, {z0.s-z3.s}          \n"
    "  fmla za.s[w8, 2, VGx4], {z0.s-z3.s}, {z0.s-z3.s}          \n"
    "  fmla za.s[w8, 3, VGx4], {z0.s-z3.s}, {z0.s-z3.s}          \n"
    "  fmla za.s[w8, 4, VGx4], {z4.s-z7.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 5, VGx4], {z4.s-z7.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 6, VGx4], {z4.s-z7.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 7, VGx4], {z4.s-z7.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w9, 0, VGx4], {z8.s-z11.s}, {z8.s-z11.s}        \n"
    "  fmla za.s[w9, 1, VGx4], {z8.s-z11.s}, {z8.s-z11.s}        \n"
    "  fmla za.s[w9, 2, VGx4], {z8.s-z11.s}, {z8.s-z11.s}        \n"
    "  fmla za.s[w9, 3, VGx4], {z8.s-z11.s}, {z8.s-z11.s}        \n"
    "  fmla za.s[w9, 4, VGx4], {z12.s-z15.s}, {z12.s-z15.s}      \n"
    "  fmla za.s[w9, 5, VGx4], {z12.s-z15.s}, {z12.s-z15.s}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*14.0*(double)n_iterations;
}


static double fmla_za_f32_f32_vgx4_ilp15(const void*) {
  // FMLA (FP32, four vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (64x f32, 64x f32) → 64x f32 (128 OPs)
  // Total of 1920 OPs per loop iteration, ILP = 15
  size_t n_iterations = N_ITERATIONS/15;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fmla za.s[w8, 0, VGx4], {z0.s-z3.s}, {z0.s-z3.s}          \n"
    "  fmla za.s[w8, 1, VGx4], {z0.s-z3.s}, {z0.s-z3.s}          \n"
    "  fmla za.s[w8, 2, VGx4], {z0.s-z3.s}, {z0.s-z3.s}          \n"
    "  fmla za.s[w8, 3, VGx4], {z0.s-z3.s}, {z0.s-z3.s}          \n"
    "  fmla za.s[w8, 4, VGx4], {z4.s-z7.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 5, VGx4], {z4.s-z7.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 6, VGx4], {z4.s-z7.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 7, VGx4], {z4.s-z7.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w9, 0, VGx4], {z8.s-z11.s}, {z8.s-z11.s}        \n"
    "  fmla za.s[w9, 1, VGx4], {z8.s-z11.s}, {z8.s-z11.s}        \n"
    "  fmla za.s[w9, 2, VGx4], {z8.s-z11.s}, {z8.s-z11.s}        \n"
    "  fmla za.s[w9, 3, VGx4], {z8.s-z11.s}, {z8.s-z11.s}        \n"
    "  fmla za.s[w9, 4, VGx4], {z12.s-z15.s}, {z12.s-z15.s}      \n"
    "  fmla za.s[w9, 5, VGx4], {z12.s-z15.s}, {z12.s-z15.s}      \n"
    "  fmla za.s[w9, 6, VGx4], {z12.s-z15.s}, {z12.s-z15.s}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*15.0*(double)n_iterations;
}


static double fmla_za_f32_f32_vgx4_ilp16(const void*) {
  // FMLA (FP32, four vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (64x f32, 64x f32) → 64x f32 (128 OPs)
  // Total of 2048 OPs per loop iteration, ILP = 16
  size_t n_iterations = N_ITERATIONS/16;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fmla za.s[w8, 0, VGx4], {z0.s-z3.s}, {z0.s-z3.s}          \n"
    "  fmla za.s[w8, 1, VGx4], {z0.s-z3.s}, {z0.s-z3.s}          \n"
    "  fmla za.s[w8, 2, VGx4], {z0.s-z3.s}, {z0.s-z3.s}          \n"
    "  fmla za.s[w8, 3, VGx4], {z0.s-z3.s}, {z0.s-z3.s}          \n"
    "  fmla za.s[w8, 4, VGx4], {z4.s-z7.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 5, VGx4], {z4.s-z7.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 6, VGx4], {z4.s-z7.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 7, VGx4], {z4.s-z7.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w9, 0, VGx4], {z8.s-z11.s}, {z8.s-z11.s}        \n"
    "  fmla za.s[w9, 1, VGx4], {z8.s-z11.s}, {z8.s-z11.s}        \n"
    "  fmla za.s[w9, 2, VGx4], {z8.s-z11.s}, {z8.s-z11.s}        \n"
    "  fmla za.s[w9, 3, VGx4], {z8.s-z11.s}, {z8.s-z11.s}        \n"
    "  fmla za.s[w9, 4, VGx4], {z12.s-z15.s}, {z12.s-z15.s}      \n"
    "  fmla za.s[w9, 5, VGx4], {z12.s-z15.s}, {z12.s-z15.s}      \n"
    "  fmla za.s[w9, 6, VGx4], {z12.s-z15.s}, {z12.s-z15.s}      \n"
    "  fmla za.s[w9, 7, VGx4], {z12.s-z15.s}, {z12.s-z15.s}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*16.0*(double)n_iterations;
}


static double fmla_za_f64_f64_vgx2_ilp1(const void*) {
  // FMLA (FP64, two vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (16x f64, 16x f64) → 16x f64 (32 OPs)
  // Total of 32 OPs per loop iteration, ILP = 1
  size_t n_iterations = N_ITERATIONS;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fmla za.d[w8, 0, VGx2], {z0.d-z1.d}, {z0.d-z1.d}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 32.0*1.0*(double)n_iterations;
}


static double fmla_za_f64_f64_vgx2_ilp2(const void*) {
  // FMLA (FP64, two vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (16x f64, 16x f64) → 16x f64 (32 OPs)
  // Total of 64 OPs per loop iteration, ILP = 2
  size_t n_iterations = N_ITERATIONS/2;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fmla za.d[w8, 0, VGx2], {z0.d-z1.d}, {z0.d-z1.d}          \n"
    "  fmla za.d[w8, 1, VGx2], {z0.d-z1.d}, {z0.d-z1.d}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 32.0*2.0*(double)n_iterations;
}


static double fmla_za_f64_f64_vgx2_ilp3(const void*) {
  // FMLA (FP64, two vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (16x f64, 16x f64) → 16x f64 (32 OPs)
  // Total of 96 OPs per loop iteration, ILP = 3
  size_t n_iterations = N_ITERATIONS/3;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fmla za.d[w8, 0, VGx2], {z0.d-z1.d}, {z0.d-z1.d}          \n"
    "  fmla za.d[w8, 1, VGx2], {z0.d-z1.d}, {z0.d-z1.d}          \n"
    "  fmla za.d[w8, 2, VGx2], {z2.d-z3.d}, {z2.d-z3.d}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 32.0*3.0*(double)n_iterations;
}


static double fmla_za_f64_f64_vgx2_ilp4(const void*) {
  // FMLA (FP64, two vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (16x f64, 16x f64) → 16x f64 (32 OPs)
  // Total of 128 OPs per loop iteration, ILP = 4
  size_t n_iterations = N_ITERATIONS/4;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fmla za.d[w8, 0, VGx2], {z0.d-z1.d}, {z0.d-z1.d}          \n"
    "  fmla za.d[w8, 1, VGx2], {z0.d-z1.d}, {z0.d-z1.d}          \n"
    "  fmla za.d[w8, 2, VGx2], {z2.d-z3.d}, {z2.d-z3.d}          \n"
    "  fmla za.d[w8, 3, VGx2], {z2.d-z3.d}, {z2.d-z3.d}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 32.0*4.0*(double)n_iterations;
}


static double fmla_za_f64_f64_vgx2_ilp5(const void*) {
  // FMLA (FP64, two vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (16x f64, 16x f64) → 16x f64 (32 OPs)
  // Total of 160 OPs per loop iteration, ILP = 5
  size_t n_iterations = N_ITERATIONS/5;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fmla za.d[w8, 0, VGx2], {z0.d-z1.d}, {z0.d-z1.d}          \n"
    "  fmla za.d[w8, 1, VGx2], {z0.d-z1.d}, {z0.d-z1.d}          \n"
    "  fmla za.d[w8, 2, VGx2], {z2.d-z3.d}, {z2.d-z3.d}          \n"
    "  fmla za.d[w8, 3, VGx2], {z2.d-z3.d}, {z2.d-z3.d}          \n"
    "  fmla za.d[w8, 4, VGx2], {z4.d-z5.d}, {z4.d-z5.d}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 32.0*5.0*(double)n_iterations;
}


static double fmla_za_f64_f64_vgx2_ilp6(const void*) {
  // FMLA (FP64, two vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (16x f64, 16x f64) → 16x f64 (32 OPs)
  // Total of 192 OPs per loop iteration, ILP = 6
  size_t n_iterations = N_ITERATIONS/6;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fmla za.d[w8, 0, VGx2], {z0.d-z1.d}, {z0.d-z1.d}          \n"
    "  fmla za.d[w8, 1, VGx2], {z0.d-z1.d}, {z0.d-z1.d}          \n"
    "  fmla za.d[w8, 2, VGx2], {z2.d-z3.d}, {z2.d-z3.d}          \n"
    "  fmla za.d[w8, 3, VGx2], {z2.d-z3.d}, {z2.d-z3.d}          \n"
    "  fmla za.d[w8, 4, VGx2], {z4.d-z5.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 5, VGx2], {z4.d-z5.d}, {z4.d-z5.d}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 32.0*6.0*(double)n_iterations;
}


static double fmla_za_f64_f64_vgx2_ilp7(const void*) {
  // FMLA (FP64, two vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (16x f64, 16x f64) → 16x f64 (32 OPs)
  // Total of 224 OPs per loop iteration, ILP = 7
  size_t n_iterations = N_ITERATIONS/7;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fmla za.d[w8, 0, VGx2], {z0.d-z1.d}, {z0.d-z1.d}          \n"
    "  fmla za.d[w8, 1, VGx2], {z0.d-z1.d}, {z0.d-z1.d}          \n"
    "  fmla za.d[w8, 2, VGx2], {z2.d-z3.d}, {z2.d-z3.d}          \n"
    "  fmla za.d[w8, 3, VGx2], {z2.d-z3.d}, {z2.d-z3.d}          \n"
    "  fmla za.d[w8, 4, VGx2], {z4.d-z5.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 5, VGx2], {z4.d-z5.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 6, VGx2], {z6.d-z7.d}, {z6.d-z7.d}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 32.0*7.0*(double)n_iterations;
}


static double fmla_za_f64_f64_vgx2_ilp8(const void*) {
  // FMLA (FP64, two vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (16x f64, 16x f64) → 16x f64 (32 OPs)
  // Total of 256 OPs per loop iteration, ILP = 8
  size_t n_iterations = N_ITERATIONS/8;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fmla za.d[w8, 0, VGx2], {z0.d-z1.d}, {z0.d-z1.d}          \n"
    "  fmla za.d[w8, 1, VGx2], {z0.d-z1.d}, {z0.d-z1.d}          \n"
    "  fmla za.d[w8, 2, VGx2], {z2.d-z3.d}, {z2.d-z3.d}          \n"
    "  fmla za.d[w8, 3, VGx2], {z2.d-z3.d}, {z2.d-z3.d}          \n"
    "  fmla za.d[w8, 4, VGx2], {z4.d-z5.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 5, VGx2], {z4.d-z5.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 6, VGx2], {z6.d-z7.d}, {z6.d-z7.d}          \n"
    "  fmla za.d[w8, 7, VGx2], {z6.d-z7.d}, {z6.d-z7.d}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 32.0*8.0*(double)n_iterations;
}


static double fmla_za_f64_f64_vgx2_ilp9(const void*) {
  // FMLA (FP64, two vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (16x f64, 16x f64) → 16x f64 (32 OPs)
  // Total of 288 OPs per loop iteration, ILP = 9
  size_t n_iterations = N_ITERATIONS/9;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fmla za.d[w8, 0, VGx2], {z0.d-z1.d}, {z0.d-z1.d}          \n"
    "  fmla za.d[w8, 1, VGx2], {z0.d-z1.d}, {z0.d-z1.d}          \n"
    "  fmla za.d[w8, 2, VGx2], {z2.d-z3.d}, {z2.d-z3.d}          \n"
    "  fmla za.d[w8, 3, VGx2], {z2.d-z3.d}, {z2.d-z3.d}          \n"
    "  fmla za.d[w8, 4, VGx2], {z4.d-z5.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 5, VGx2], {z4.d-z5.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 6, VGx2], {z6.d-z7.d}, {z6.d-z7.d}          \n"
    "  fmla za.d[w8, 7, VGx2], {z6.d-z7.d}, {z6.d-z7.d}          \n"
    "  fmla za.d[w9, 0, VGx2], {z8.d-z9.d}, {z8.d-z9.d}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 32.0*9.0*(double)n_iterations;
}


static double fmla_za_f64_f64_vgx2_ilp10(const void*) {
  // FMLA (FP64, two vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (16x f64, 16x f64) → 16x f64 (32 OPs)
  // Total of 320 OPs per loop iteration, ILP = 10
  size_t n_iterations = N_ITERATIONS/10;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fmla za.d[w8, 0, VGx2], {z0.d-z1.d}, {z0.d-z1.d}          \n"
    "  fmla za.d[w8, 1, VGx2], {z0.d-z1.d}, {z0.d-z1.d}          \n"
    "  fmla za.d[w8, 2, VGx2], {z2.d-z3.d}, {z2.d-z3.d}          \n"
    "  fmla za.d[w8, 3, VGx2], {z2.d-z3.d}, {z2.d-z3.d}          \n"
    "  fmla za.d[w8, 4, VGx2], {z4.d-z5.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 5, VGx2], {z4.d-z5.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 6, VGx2], {z6.d-z7.d}, {z6.d-z7.d}          \n"
    "  fmla za.d[w8, 7, VGx2], {z6.d-z7.d}, {z6.d-z7.d}          \n"
    "  fmla za.d[w9, 0, VGx2], {z8.d-z9.d}, {z8.d-z9.d}          \n"
    "  fmla za.d[w9, 1, VGx2], {z8.d-z9.d}, {z8.d-z9.d}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 32.0*10.0*(double)n_iterations;
}


static double fmla_za_f64_f64_vgx2_ilp11(const void*) {
  // FMLA (FP64, two vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (16x f64, 16x f64) → 16x f64 (32 OPs)
  // Total of 352 OPs per loop iteration, ILP = 11
  size_t n_iterations = N_ITERATIONS/11;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fmla za.d[w8, 0, VGx2], {z0.d-z1.d}, {z0.d-z1.d}          \n"
    "  fmla za.d[w8, 1, VGx2], {z0.d-z1.d}, {z0.d-z1.d}          \n"
    "  fmla za.d[w8, 2, VGx2], {z2.d-z3.d}, {z2.d-z3.d}          \n"
    "  fmla za.d[w8, 3, VGx2], {z2.d-z3.d}, {z2.d-z3.d}          \n"
    "  fmla za.d[w8, 4, VGx2], {z4.d-z5.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 5, VGx2], {z4.d-z5.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 6, VGx2], {z6.d-z7.d}, {z6.d-z7.d}          \n"
    "  fmla za.d[w8, 7, VGx2], {z6.d-z7.d}, {z6.d-z7.d}          \n"
    "  fmla za.d[w9, 0, VGx2], {z8.d-z9.d}, {z8.d-z9.d}          \n"
    "  fmla za.d[w9, 1, VGx2], {z8.d-z9.d}, {z8.d-z9.d}          \n"
    "  fmla za.d[w9, 2, VGx2], {z10.d-z11.d}, {z10.d-z11.d}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 32.0*11.0*(double)n_iterations;
}


static double fmla_za_f64_f64_vgx2_ilp12(const void*) {
  // FMLA (FP64, two vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (16x f64, 16x f64) → 16x f64 (32 OPs)
  // Total of 384 OPs per loop iteration, ILP = 12
  size_t n_iterations = N_ITERATIONS/12;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fmla za.d[w8, 0, VGx2], {z0.d-z1.d}, {z0.d-z1.d}          \n"
    "  fmla za.d[w8, 1, VGx2], {z0.d-z1.d}, {z0.d-z1.d}          \n"
    "  fmla za.d[w8, 2, VGx2], {z2.d-z3.d}, {z2.d-z3.d}          \n"
    "  fmla za.d[w8, 3, VGx2], {z2.d-z3.d}, {z2.d-z3.d}          \n"
    "  fmla za.d[w8, 4, VGx2], {z4.d-z5.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 5, VGx2], {z4.d-z5.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 6, VGx2], {z6.d-z7.d}, {z6.d-z7.d}          \n"
    "  fmla za.d[w8, 7, VGx2], {z6.d-z7.d}, {z6.d-z7.d}          \n"
    "  fmla za.d[w9, 0, VGx2], {z8.d-z9.d}, {z8.d-z9.d}          \n"
    "  fmla za.d[w9, 1, VGx2], {z8.d-z9.d}, {z8.d-z9.d}          \n"
    "  fmla za.d[w9, 2, VGx2], {z10.d-z11.d}, {z10.d-z11.d}      \n"
    "  fmla za.d[w9, 3, VGx2], {z10.d-z11.d}, {z10.d-z11.d}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 32.0*12.0*(double)n_iterations;
}


static double fmla_za_f64_f64_vgx2_ilp13(const void*) {
  // FMLA (FP64, two vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (16x f64, 16x f64) → 16x f64 (32 OPs)
  // Total of 416 OPs per loop iteration, ILP = 13
  size_t n_iterations = N_ITERATIONS/13;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fmla za.d[w8, 0, VGx2], {z0.d-z1.d}, {z0.d-z1.d}          \n"
    "  fmla za.d[w8, 1, VGx2], {z0.d-z1.d}, {z0.d-z1.d}          \n"
    "  fmla za.d[w8, 2, VGx2], {z2.d-z3.d}, {z2.d-z3.d}          \n"
    "  fmla za.d[w8, 3, VGx2], {z2.d-z3.d}, {z2.d-z3.d}          \n"
    "  fmla za.d[w8, 4, VGx2], {z4.d-z5.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 5, VGx2], {z4.d-z5.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 6, VGx2], {z6.d-z7.d}, {z6.d-z7.d}          \n"
    "  fmla za.d[w8, 7, VGx2], {z6.d-z7.d}, {z6.d-z7.d}          \n"
    "  fmla za.d[w9, 0, VGx2], {z8.d-z9.d}, {z8.d-z9.d}          \n"
    "  fmla za.d[w9, 1, VGx2], {z8.d-z9.d}, {z8.d-z9.d}          \n"
    "  fmla za.d[w9, 2, VGx2], {z10.d-z11.d}, {z10.d-z11.d}      \n"
    "  fmla za.d[w9, 3, VGx2], {z10.d-z11.d}, {z10.d-z11.d}      \n"
    "  fmla za.d[w9, 4, VGx2], {z12.d-z13.d}, {z12.d-z13.d}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 32.0*13.0*(double)n_iterations;
}


static double fmla_za_f64_f64_vgx2_ilp14(const void*) {
  // FMLA (FP64, two vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (16x f64, 16x f64) → 16x f64 (32 OPs)
  // Total of 448 OPs per loop iteration, ILP = 14
  size_t n_iterations = N_ITERATIONS/14;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fmla za.d[w8, 0, VGx2], {z0.d-z1.d}, {z0.d-z1.d}          \n"
    "  fmla za.d[w8, 1, VGx2], {z0.d-z1.d}, {z0.d-z1.d}          \n"
    "  fmla za.d[w8, 2, VGx2], {z2.d-z3.d}, {z2.d-z3.d}          \n"
    "  fmla za.d[w8, 3, VGx2], {z2.d-z3.d}, {z2.d-z3.d}          \n"
    "  fmla za.d[w8, 4, VGx2], {z4.d-z5.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 5, VGx2], {z4.d-z5.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 6, VGx2], {z6.d-z7.d}, {z6.d-z7.d}          \n"
    "  fmla za.d[w8, 7, VGx2], {z6.d-z7.d}, {z6.d-z7.d}          \n"
    "  fmla za.d[w9, 0, VGx2], {z8.d-z9.d}, {z8.d-z9.d}          \n"
    "  fmla za.d[w9, 1, VGx2], {z8.d-z9.d}, {z8.d-z9.d}          \n"
    "  fmla za.d[w9, 2, VGx2], {z10.d-z11.d}, {z10.d-z11.d}      \n"
    "  fmla za.d[w9, 3, VGx2], {z10.d-z11.d}, {z10.d-z11.d}      \n"
    "  fmla za.d[w9, 4, VGx2], {z12.d-z13.d}, {z12.d-z13.d}      \n"
    "  fmla za.d[w9, 5, VGx2], {z12.d-z13.d}, {z12.d-z13.d}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 32.0*14.0*(double)n_iterations;
}


static double fmla_za_f64_f64_vgx2_ilp15(const void*) {
  // FMLA (FP64, two vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (16x f64, 16x f64) → 16x f64 (32 OPs)
  // Total of 480 OPs per loop iteration, ILP = 15
  size_t n_iterations = N_ITERATIONS/15;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fmla za.d[w8, 0, VGx2], {z0.d-z1.d}, {z0.d-z1.d}          \n"
    "  fmla za.d[w8, 1, VGx2], {z0.d-z1.d}, {z0.d-z1.d}          \n"
    "  fmla za.d[w8, 2, VGx2], {z2.d-z3.d}, {z2.d-z3.d}          \n"
    "  fmla za.d[w8, 3, VGx2], {z2.d-z3.d}, {z2.d-z3.d}          \n"
    "  fmla za.d[w8, 4, VGx2], {z4.d-z5.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 5, VGx2], {z4.d-z5.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 6, VGx2], {z6.d-z7.d}, {z6.d-z7.d}          \n"
    "  fmla za.d[w8, 7, VGx2], {z6.d-z7.d}, {z6.d-z7.d}          \n"
    "  fmla za.d[w9, 0, VGx2], {z8.d-z9.d}, {z8.d-z9.d}          \n"
    "  fmla za.d[w9, 1, VGx2], {z8.d-z9.d}, {z8.d-z9.d}          \n"
    "  fmla za.d[w9, 2, VGx2], {z10.d-z11.d}, {z10.d-z11.d}      \n"
    "  fmla za.d[w9, 3, VGx2], {z10.d-z11.d}, {z10.d-z11.d}      \n"
    "  fmla za.d[w9, 4, VGx2], {z12.d-z13.d}, {z12.d-z13.d}      \n"
    "  fmla za.d[w9, 5, VGx2], {z12.d-z13.d}, {z12.d-z13.d}      \n"
    "  fmla za.d[w9, 6, VGx2], {z14.d-z15.d}, {z14.d-z15.d}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 32.0*15.0*(double)n_iterations;
}


static double fmla_za_f64_f64_vgx2_ilp16(const void*) {
  // FMLA (FP64, two vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (16x f64, 16x f64) → 16x f64 (32 OPs)
  // Total of 512 OPs per loop iteration, ILP = 16
  size_t n_iterations = N_ITERATIONS/16;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fmla za.d[w8, 0, VGx2], {z0.d-z1.d}, {z0.d-z1.d}          \n"
    "  fmla za.d[w8, 1, VGx2], {z0.d-z1.d}, {z0.d-z1.d}          \n"
    "  fmla za.d[w8, 2, VGx2], {z2.d-z3.d}, {z2.d-z3.d}          \n"
    "  fmla za.d[w8, 3, VGx2], {z2.d-z3.d}, {z2.d-z3.d}          \n"
    "  fmla za.d[w8, 4, VGx2], {z4.d-z5.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 5, VGx2], {z4.d-z5.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 6, VGx2], {z6.d-z7.d}, {z6.d-z7.d}          \n"
    "  fmla za.d[w8, 7, VGx2], {z6.d-z7.d}, {z6.d-z7.d}          \n"
    "  fmla za.d[w9, 0, VGx2], {z8.d-z9.d}, {z8.d-z9.d}          \n"
    "  fmla za.d[w9, 1, VGx2], {z8.d-z9.d}, {z8.d-z9.d}          \n"
    "  fmla za.d[w9, 2, VGx2], {z10.d-z11.d}, {z10.d-z11.d}      \n"
    "  fmla za.d[w9, 3, VGx2], {z10.d-z11.d}, {z10.d-z11.d}      \n"
    "  fmla za.d[w9, 4, VGx2], {z12.d-z13.d}, {z12.d-z13.d}      \n"
    "  fmla za.d[w9, 5, VGx2], {z12.d-z13.d}, {z12.d-z13.d}      \n"
    "  fmla za.d[w9, 6, VGx2], {z14.d-z15.d}, {z14.d-z15.d}      \n"
    "  fmla za.d[w9, 7, VGx2], {z14.d-z15.d}, {z14.d-z15.d}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 32.0*16.0*(double)n_iterations;
}


static double fmla_za_f64_f64_vgx4_ilp1(const void*) {
  // FMLA (FP64, four vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (32x f64, 32x f64) → 32x f64 (64 OPs)
  // Total of 64 OPs per loop iteration, ILP = 1
  size_t n_iterations = N_ITERATIONS;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fmla za.d[w8, 0, VGx4], {z0.d-z3.d}, {z0.d-z3.d}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*1.0*(double)n_iterations;
}


static double fmla_za_f64_f64_vgx4_ilp2(const void*) {
  // FMLA (FP64, four vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (32x f64, 32x f64) → 32x f64 (64 OPs)
  // Total of 128 OPs per loop iteration, ILP = 2
  size_t n_iterations = N_ITERATIONS/2;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fmla za.d[w8, 0, VGx4], {z0.d-z3.d}, {z0.d-z3.d}          \n"
    "  fmla za.d[w8, 1, VGx4], {z0.d-z3.d}, {z0.d-z3.d}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*2.0*(double)n_iterations;
}


static double fmla_za_f64_f64_vgx4_ilp3(const void*) {
  // FMLA (FP64, four vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (32x f64, 32x f64) → 32x f64 (64 OPs)
  // Total of 192 OPs per loop iteration, ILP = 3
  size_t n_iterations = N_ITERATIONS/3;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fmla za.d[w8, 0, VGx4], {z0.d-z3.d}, {z0.d-z3.d}          \n"
    "  fmla za.d[w8, 1, VGx4], {z0.d-z3.d}, {z0.d-z3.d}          \n"
    "  fmla za.d[w8, 2, VGx4], {z0.d-z3.d}, {z0.d-z3.d}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*3.0*(double)n_iterations;
}


static double fmla_za_f64_f64_vgx4_ilp4(const void*) {
  // FMLA (FP64, four vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (32x f64, 32x f64) → 32x f64 (64 OPs)
  // Total of 256 OPs per loop iteration, ILP = 4
  size_t n_iterations = N_ITERATIONS/4;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fmla za.d[w8, 0, VGx4], {z0.d-z3.d}, {z0.d-z3.d}          \n"
    "  fmla za.d[w8, 1, VGx4], {z0.d-z3.d}, {z0.d-z3.d}          \n"
    "  fmla za.d[w8, 2, VGx4], {z0.d-z3.d}, {z0.d-z3.d}          \n"
    "  fmla za.d[w8, 3, VGx4], {z0.d-z3.d}, {z0.d-z3.d}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*4.0*(double)n_iterations;
}


static double fmla_za_f64_f64_vgx4_ilp5(const void*) {
  // FMLA (FP64, four vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (32x f64, 32x f64) → 32x f64 (64 OPs)
  // Total of 320 OPs per loop iteration, ILP = 5
  size_t n_iterations = N_ITERATIONS/5;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fmla za.d[w8, 0, VGx4], {z0.d-z3.d}, {z0.d-z3.d}          \n"
    "  fmla za.d[w8, 1, VGx4], {z0.d-z3.d}, {z0.d-z3.d}          \n"
    "  fmla za.d[w8, 2, VGx4], {z0.d-z3.d}, {z0.d-z3.d}          \n"
    "  fmla za.d[w8, 3, VGx4], {z0.d-z3.d}, {z0.d-z3.d}          \n"
    "  fmla za.d[w8, 4, VGx4], {z4.d-z7.d}, {z4.d-z7.d}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*5.0*(double)n_iterations;
}


static double fmla_za_f64_f64_vgx4_ilp6(const void*) {
  // FMLA (FP64, four vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (32x f64, 32x f64) → 32x f64 (64 OPs)
  // Total of 384 OPs per loop iteration, ILP = 6
  size_t n_iterations = N_ITERATIONS/6;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fmla za.d[w8, 0, VGx4], {z0.d-z3.d}, {z0.d-z3.d}          \n"
    "  fmla za.d[w8, 1, VGx4], {z0.d-z3.d}, {z0.d-z3.d}          \n"
    "  fmla za.d[w8, 2, VGx4], {z0.d-z3.d}, {z0.d-z3.d}          \n"
    "  fmla za.d[w8, 3, VGx4], {z0.d-z3.d}, {z0.d-z3.d}          \n"
    "  fmla za.d[w8, 4, VGx4], {z4.d-z7.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 5, VGx4], {z4.d-z7.d}, {z4.d-z7.d}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*6.0*(double)n_iterations;
}


static double fmla_za_f64_f64_vgx4_ilp7(const void*) {
  // FMLA (FP64, four vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (32x f64, 32x f64) → 32x f64 (64 OPs)
  // Total of 448 OPs per loop iteration, ILP = 7
  size_t n_iterations = N_ITERATIONS/7;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fmla za.d[w8, 0, VGx4], {z0.d-z3.d}, {z0.d-z3.d}          \n"
    "  fmla za.d[w8, 1, VGx4], {z0.d-z3.d}, {z0.d-z3.d}          \n"
    "  fmla za.d[w8, 2, VGx4], {z0.d-z3.d}, {z0.d-z3.d}          \n"
    "  fmla za.d[w8, 3, VGx4], {z0.d-z3.d}, {z0.d-z3.d}          \n"
    "  fmla za.d[w8, 4, VGx4], {z4.d-z7.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 5, VGx4], {z4.d-z7.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 6, VGx4], {z4.d-z7.d}, {z4.d-z7.d}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*7.0*(double)n_iterations;
}


static double fmla_za_f64_f64_vgx4_ilp8(const void*) {
  // FMLA (FP64, four vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (32x f64, 32x f64) → 32x f64 (64 OPs)
  // Total of 512 OPs per loop iteration, ILP = 8
  size_t n_iterations = N_ITERATIONS/8;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fmla za.d[w8, 0, VGx4], {z0.d-z3.d}, {z0.d-z3.d}          \n"
    "  fmla za.d[w8, 1, VGx4], {z0.d-z3.d}, {z0.d-z3.d}          \n"
    "  fmla za.d[w8, 2, VGx4], {z0.d-z3.d}, {z0.d-z3.d}          \n"
    "  fmla za.d[w8, 3, VGx4], {z0.d-z3.d}, {z0.d-z3.d}          \n"
    "  fmla za.d[w8, 4, VGx4], {z4.d-z7.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 5, VGx4], {z4.d-z7.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 6, VGx4], {z4.d-z7.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 7, VGx4], {z4.d-z7.d}, {z4.d-z7.d}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*8.0*(double)n_iterations;
}


static double fmla_za_f64_f64_vgx4_ilp9(const void*) {
  // FMLA (FP64, four vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (32x f64, 32x f64) → 32x f64 (64 OPs)
  // Total of 576 OPs per loop iteration, ILP = 9
  size_t n_iterations = N_ITERATIONS/9;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fmla za.d[w8, 0, VGx4], {z0.d-z3.d}, {z0.d-z3.d}          \n"
    "  fmla za.d[w8, 1, VGx4], {z0.d-z3.d}, {z0.d-z3.d}          \n"
    "  fmla za.d[w8, 2, VGx4], {z0.d-z3.d}, {z0.d-z3.d}          \n"
    "  fmla za.d[w8, 3, VGx4], {z0.d-z3.d}, {z0.d-z3.d}          \n"
    "  fmla za.d[w8, 4, VGx4], {z4.d-z7.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 5, VGx4], {z4.d-z7.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 6, VGx4], {z4.d-z7.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 7, VGx4], {z4.d-z7.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w9, 0, VGx4], {z8.d-z11.d}, {z8.d-z11.d}        \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*9.0*(double)n_iterations;
}


static double fmla_za_f64_f64_vgx4_ilp10(const void*) {
  // FMLA (FP64, four vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (32x f64, 32x f64) → 32x f64 (64 OPs)
  // Total of 640 OPs per loop iteration, ILP = 10
  size_t n_iterations = N_ITERATIONS/10;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fmla za.d[w8, 0, VGx4], {z0.d-z3.d}, {z0.d-z3.d}          \n"
    "  fmla za.d[w8, 1, VGx4], {z0.d-z3.d}, {z0.d-z3.d}          \n"
    "  fmla za.d[w8, 2, VGx4], {z0.d-z3.d}, {z0.d-z3.d}          \n"
    "  fmla za.d[w8, 3, VGx4], {z0.d-z3.d}, {z0.d-z3.d}          \n"
    "  fmla za.d[w8, 4, VGx4], {z4.d-z7.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 5, VGx4], {z4.d-z7.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 6, VGx4], {z4.d-z7.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 7, VGx4], {z4.d-z7.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w9, 0, VGx4], {z8.d-z11.d}, {z8.d-z11.d}        \n"
    "  fmla za.d[w9, 1, VGx4], {z8.d-z11.d}, {z8.d-z11.d}        \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*10.0*(double)n_iterations;
}


static double fmla_za_f64_f64_vgx4_ilp11(const void*) {
  // FMLA (FP64, four vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (32x f64, 32x f64) → 32x f64 (64 OPs)
  // Total of 704 OPs per loop iteration, ILP = 11
  size_t n_iterations = N_ITERATIONS/11;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fmla za.d[w8, 0, VGx4], {z0.d-z3.d}, {z0.d-z3.d}          \n"
    "  fmla za.d[w8, 1, VGx4], {z0.d-z3.d}, {z0.d-z3.d}          \n"
    "  fmla za.d[w8, 2, VGx4], {z0.d-z3.d}, {z0.d-z3.d}          \n"
    "  fmla za.d[w8, 3, VGx4], {z0.d-z3.d}, {z0.d-z3.d}          \n"
    "  fmla za.d[w8, 4, VGx4], {z4.d-z7.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 5, VGx4], {z4.d-z7.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 6, VGx4], {z4.d-z7.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 7, VGx4], {z4.d-z7.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w9, 0, VGx4], {z8.d-z11.d}, {z8.d-z11.d}        \n"
    "  fmla za.d[w9, 1, VGx4], {z8.d-z11.d}, {z8.d-z11.d}        \n"
    "  fmla za.d[w9, 2, VGx4], {z8.d-z11.d}, {z8.d-z11.d}        \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*11.0*(double)n_iterations;
}


static double fmla_za_f64_f64_vgx4_ilp12(const void*) {
  // FMLA (FP64, four vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (32x f64, 32x f64) → 32x f64 (64 OPs)
  // Total of 768 OPs per loop iteration, ILP = 12
  size_t n_iterations = N_ITERATIONS/12;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fmla za.d[w8, 0, VGx4], {z0.d-z3.d}, {z0.d-z3.d}          \n"
    "  fmla za.d[w8, 1, VGx4], {z0.d-z3.d}, {z0.d-z3.d}          \n"
    "  fmla za.d[w8, 2, VGx4], {z0.d-z3.d}, {z0.d-z3.d}          \n"
    "  fmla za.d[w8, 3, VGx4], {z0.d-z3.d}, {z0.d-z3.d}          \n"
    "  fmla za.d[w8, 4, VGx4], {z4.d-z7.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 5, VGx4], {z4.d-z7.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 6, VGx4], {z4.d-z7.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 7, VGx4], {z4.d-z7.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w9, 0, VGx4], {z8.d-z11.d}, {z8.d-z11.d}        \n"
    "  fmla za.d[w9, 1, VGx4], {z8.d-z11.d}, {z8.d-z11.d}        \n"
    "  fmla za.d[w9, 2, VGx4], {z8.d-z11.d}, {z8.d-z11.d}        \n"
    "  fmla za.d[w9, 3, VGx4], {z8.d-z11.d}, {z8.d-z11.d}        \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*12.0*(double)n_iterations;
}


static double fmla_za_f64_f64_vgx4_ilp13(const void*) {
  // FMLA (FP64, four vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (32x f64, 32x f64) → 32x f64 (64 OPs)
  // Total of 832 OPs per loop iteration, ILP = 13
  size_t n_iterations = N_ITERATIONS/13;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fmla za.d[w8, 0, VGx4], {z0.d-z3.d}, {z0.d-z3.d}          \n"
    "  fmla za.d[w8, 1, VGx4], {z0.d-z3.d}, {z0.d-z3.d}          \n"
    "  fmla za.d[w8, 2, VGx4], {z0.d-z3.d}, {z0.d-z3.d}          \n"
    "  fmla za.d[w8, 3, VGx4], {z0.d-z3.d}, {z0.d-z3.d}          \n"
    "  fmla za.d[w8, 4, VGx4], {z4.d-z7.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 5, VGx4], {z4.d-z7.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 6, VGx4], {z4.d-z7.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 7, VGx4], {z4.d-z7.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w9, 0, VGx4], {z8.d-z11.d}, {z8.d-z11.d}        \n"
    "  fmla za.d[w9, 1, VGx4], {z8.d-z11.d}, {z8.d-z11.d}        \n"
    "  fmla za.d[w9, 2, VGx4], {z8.d-z11.d}, {z8.d-z11.d}        \n"
    "  fmla za.d[w9, 3, VGx4], {z8.d-z11.d}, {z8.d-z11.d}        \n"
    "  fmla za.d[w9, 4, VGx4], {z12.d-z15.d}, {z12.d-z15.d}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*13.0*(double)n_iterations;
}


static double fmla_za_f64_f64_vgx4_ilp14(const void*) {
  // FMLA (FP64, four vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (32x f64, 32x f64) → 32x f64 (64 OPs)
  // Total of 896 OPs per loop iteration, ILP = 14
  size_t n_iterations = N_ITERATIONS/14;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fmla za.d[w8, 0, VGx4], {z0.d-z3.d}, {z0.d-z3.d}          \n"
    "  fmla za.d[w8, 1, VGx4], {z0.d-z3.d}, {z0.d-z3.d}          \n"
    "  fmla za.d[w8, 2, VGx4], {z0.d-z3.d}, {z0.d-z3.d}          \n"
    "  fmla za.d[w8, 3, VGx4], {z0.d-z3.d}, {z0.d-z3.d}          \n"
    "  fmla za.d[w8, 4, VGx4], {z4.d-z7.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 5, VGx4], {z4.d-z7.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 6, VGx4], {z4.d-z7.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 7, VGx4], {z4.d-z7.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w9, 0, VGx4], {z8.d-z11.d}, {z8.d-z11.d}        \n"
    "  fmla za.d[w9, 1, VGx4], {z8.d-z11.d}, {z8.d-z11.d}        \n"
    "  fmla za.d[w9, 2, VGx4], {z8.d-z11.d}, {z8.d-z11.d}        \n"
    "  fmla za.d[w9, 3, VGx4], {z8.d-z11.d}, {z8.d-z11.d}        \n"
    "  fmla za.d[w9, 4, VGx4], {z12.d-z15.d}, {z12.d-z15.d}      \n"
    "  fmla za.d[w9, 5, VGx4], {z12.d-z15.d}, {z12.d-z15.d}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*14.0*(double)n_iterations;
}


static double fmla_za_f64_f64_vgx4_ilp15(const void*) {
  // FMLA (FP64, four vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (32x f64, 32x f64) → 32x f64 (64 OPs)
  // Total of 960 OPs per loop iteration, ILP = 15
  size_t n_iterations = N_ITERATIONS/15;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fmla za.d[w8, 0, VGx4], {z0.d-z3.d}, {z0.d-z3.d}          \n"
    "  fmla za.d[w8, 1, VGx4], {z0.d-z3.d}, {z0.d-z3.d}          \n"
    "  fmla za.d[w8, 2, VGx4], {z0.d-z3.d}, {z0.d-z3.d}          \n"
    "  fmla za.d[w8, 3, VGx4], {z0.d-z3.d}, {z0.d-z3.d}          \n"
    "  fmla za.d[w8, 4, VGx4], {z4.d-z7.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 5, VGx4], {z4.d-z7.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 6, VGx4], {z4.d-z7.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 7, VGx4], {z4.d-z7.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w9, 0, VGx4], {z8.d-z11.d}, {z8.d-z11.d}        \n"
    "  fmla za.d[w9, 1, VGx4], {z8.d-z11.d}, {z8.d-z11.d}        \n"
    "  fmla za.d[w9, 2, VGx4], {z8.d-z11.d}, {z8.d-z11.d}        \n"
    "  fmla za.d[w9, 3, VGx4], {z8.d-z11.d}, {z8.d-z11.d}        \n"
    "  fmla za.d[w9, 4, VGx4], {z12.d-z15.d}, {z12.d-z15.d}      \n"
    "  fmla za.d[w9, 5, VGx4], {z12.d-z15.d}, {z12.d-z15.d}      \n"
    "  fmla za.d[w9, 6, VGx4], {z12.d-z15.d}, {z12.d-z15.d}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*15.0*(double)n_iterations;
}


static double fmla_za_f64_f64_vgx4_ilp16(const void*) {
  // FMLA (FP64, four vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (32x f64, 32x f64) → 32x f64 (64 OPs)
  // Total of 1024 OPs per loop iteration, ILP = 16
  size_t n_iterations = N_ITERATIONS/16;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fmla za.d[w8, 0, VGx4], {z0.d-z3.d}, {z0.d-z3.d}          \n"
    "  fmla za.d[w8, 1, VGx4], {z0.d-z3.d}, {z0.d-z3.d}          \n"
    "  fmla za.d[w8, 2, VGx4], {z0.d-z3.d}, {z0.d-z3.d}          \n"
    "  fmla za.d[w8, 3, VGx4], {z0.d-z3.d}, {z0.d-z3.d}          \n"
    "  fmla za.d[w8, 4, VGx4], {z4.d-z7.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 5, VGx4], {z4.d-z7.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 6, VGx4], {z4.d-z7.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 7, VGx4], {z4.d-z7.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w9, 0, VGx4], {z8.d-z11.d}, {z8.d-z11.d}        \n"
    "  fmla za.d[w9, 1, VGx4], {z8.d-z11.d}, {z8.d-z11.d}        \n"
    "  fmla za.d[w9, 2, VGx4], {z8.d-z11.d}, {z8.d-z11.d}        \n"
    "  fmla za.d[w9, 3, VGx4], {z8.d-z11.d}, {z8.d-z11.d}        \n"
    "  fmla za.d[w9, 4, VGx4], {z12.d-z15.d}, {z12.d-z15.d}      \n"
    "  fmla za.d[w9, 5, VGx4], {z12.d-z15.d}, {z12.d-z15.d}      \n"
    "  fmla za.d[w9, 6, VGx4], {z12.d-z15.d}, {z12.d-z15.d}      \n"
    "  fmla za.d[w9, 7, VGx4], {z12.d-z15.d}, {z12.d-z15.d}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*16.0*(double)n_iterations;
}


static double fmlal_za_f32_f16_vgx2_ilp1(const void*) {
  // FMLAL (FP16 to FP32, two vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (64x f16, 64x f16) → 64x f32 (128 OPs)
  // Total of 128 OPs per loop iteration, ILP = 1
  size_t n_iterations = N_ITERATIONS;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fmlal za.s[w8, 0:1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*1.0*(double)n_iterations;
}


static double fmlal_za_f32_f16_vgx2_ilp2(const void*) {
  // FMLAL (FP16 to FP32, two vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (64x f16, 64x f16) → 64x f32 (128 OPs)
  // Total of 256 OPs per loop iteration, ILP = 2
  size_t n_iterations = N_ITERATIONS/2;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fmlal za.s[w8, 0:1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}       \n"
    "  fmlal za.s[w8, 2:3, VGx2], {z0.h-z1.h}, {z0.h-z1.h}       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*2.0*(double)n_iterations;
}


static double fmlal_za_f32_f16_vgx2_ilp3(const void*) {
  // FMLAL (FP16 to FP32, two vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (64x f16, 64x f16) → 64x f32 (128 OPs)
  // Total of 384 OPs per loop iteration, ILP = 3
  size_t n_iterations = N_ITERATIONS/3;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fmlal za.s[w8, 0:1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}       \n"
    "  fmlal za.s[w8, 2:3, VGx2], {z0.h-z1.h}, {z0.h-z1.h}       \n"
    "  fmlal za.s[w8, 4:5, VGx2], {z2.h-z3.h}, {z2.h-z3.h}       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*3.0*(double)n_iterations;
}


static double fmlal_za_f32_f16_vgx2_ilp4(const void*) {
  // FMLAL (FP16 to FP32, two vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (64x f16, 64x f16) → 64x f32 (128 OPs)
  // Total of 512 OPs per loop iteration, ILP = 4
  size_t n_iterations = N_ITERATIONS/4;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fmlal za.s[w8, 0:1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}       \n"
    "  fmlal za.s[w8, 2:3, VGx2], {z0.h-z1.h}, {z0.h-z1.h}       \n"
    "  fmlal za.s[w8, 4:5, VGx2], {z2.h-z3.h}, {z2.h-z3.h}       \n"
    "  fmlal za.s[w8, 6:7, VGx2], {z2.h-z3.h}, {z2.h-z3.h}       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*4.0*(double)n_iterations;
}


static double fmlal_za_f32_f16_vgx2_ilp5(const void*) {
  // FMLAL (FP16 to FP32, two vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (64x f16, 64x f16) → 64x f32 (128 OPs)
  // Total of 640 OPs per loop iteration, ILP = 5
  size_t n_iterations = N_ITERATIONS/5;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fmlal za.s[w8, 0:1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}       \n"
    "  fmlal za.s[w8, 2:3, VGx2], {z0.h-z1.h}, {z0.h-z1.h}       \n"
    "  fmlal za.s[w8, 4:5, VGx2], {z2.h-z3.h}, {z2.h-z3.h}       \n"
    "  fmlal za.s[w8, 6:7, VGx2], {z2.h-z3.h}, {z2.h-z3.h}       \n"
    "  fmlal za.s[w9, 0:1, VGx2], {z4.h-z5.h}, {z4.h-z5.h}       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*5.0*(double)n_iterations;
}


static double fmlal_za_f32_f16_vgx2_ilp6(const void*) {
  // FMLAL (FP16 to FP32, two vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (64x f16, 64x f16) → 64x f32 (128 OPs)
  // Total of 768 OPs per loop iteration, ILP = 6
  size_t n_iterations = N_ITERATIONS/6;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fmlal za.s[w8, 0:1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}       \n"
    "  fmlal za.s[w8, 2:3, VGx2], {z0.h-z1.h}, {z0.h-z1.h}       \n"
    "  fmlal za.s[w8, 4:5, VGx2], {z2.h-z3.h}, {z2.h-z3.h}       \n"
    "  fmlal za.s[w8, 6:7, VGx2], {z2.h-z3.h}, {z2.h-z3.h}       \n"
    "  fmlal za.s[w9, 0:1, VGx2], {z4.h-z5.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w9, 2:3, VGx2], {z4.h-z5.h}, {z4.h-z5.h}       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*6.0*(double)n_iterations;
}


static double fmlal_za_f32_f16_vgx2_ilp7(const void*) {
  // FMLAL (FP16 to FP32, two vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (64x f16, 64x f16) → 64x f32 (128 OPs)
  // Total of 896 OPs per loop iteration, ILP = 7
  size_t n_iterations = N_ITERATIONS/7;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fmlal za.s[w8, 0:1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}       \n"
    "  fmlal za.s[w8, 2:3, VGx2], {z0.h-z1.h}, {z0.h-z1.h}       \n"
    "  fmlal za.s[w8, 4:5, VGx2], {z2.h-z3.h}, {z2.h-z3.h}       \n"
    "  fmlal za.s[w8, 6:7, VGx2], {z2.h-z3.h}, {z2.h-z3.h}       \n"
    "  fmlal za.s[w9, 0:1, VGx2], {z4.h-z5.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w9, 2:3, VGx2], {z4.h-z5.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w9, 4:5, VGx2], {z6.h-z7.h}, {z6.h-z7.h}       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*7.0*(double)n_iterations;
}


static double fmlal_za_f32_f16_vgx2_ilp8(const void*) {
  // FMLAL (FP16 to FP32, two vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (64x f16, 64x f16) → 64x f32 (128 OPs)
  // Total of 1024 OPs per loop iteration, ILP = 8
  size_t n_iterations = N_ITERATIONS/8;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fmlal za.s[w8, 0:1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}       \n"
    "  fmlal za.s[w8, 2:3, VGx2], {z0.h-z1.h}, {z0.h-z1.h}       \n"
    "  fmlal za.s[w8, 4:5, VGx2], {z2.h-z3.h}, {z2.h-z3.h}       \n"
    "  fmlal za.s[w8, 6:7, VGx2], {z2.h-z3.h}, {z2.h-z3.h}       \n"
    "  fmlal za.s[w9, 0:1, VGx2], {z4.h-z5.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w9, 2:3, VGx2], {z4.h-z5.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w9, 4:5, VGx2], {z6.h-z7.h}, {z6.h-z7.h}       \n"
    "  fmlal za.s[w9, 6:7, VGx2], {z6.h-z7.h}, {z6.h-z7.h}       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*8.0*(double)n_iterations;
}


static double fmlal_za_f32_f16_vgx2_ilp9(const void*) {
  // FMLAL (FP16 to FP32, two vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (64x f16, 64x f16) → 64x f32 (128 OPs)
  // Total of 1152 OPs per loop iteration, ILP = 9
  size_t n_iterations = N_ITERATIONS/9;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fmlal za.s[w8, 0:1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}       \n"
    "  fmlal za.s[w8, 2:3, VGx2], {z0.h-z1.h}, {z0.h-z1.h}       \n"
    "  fmlal za.s[w8, 4:5, VGx2], {z2.h-z3.h}, {z2.h-z3.h}       \n"
    "  fmlal za.s[w8, 6:7, VGx2], {z2.h-z3.h}, {z2.h-z3.h}       \n"
    "  fmlal za.s[w9, 0:1, VGx2], {z4.h-z5.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w9, 2:3, VGx2], {z4.h-z5.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w9, 4:5, VGx2], {z6.h-z7.h}, {z6.h-z7.h}       \n"
    "  fmlal za.s[w9, 6:7, VGx2], {z6.h-z7.h}, {z6.h-z7.h}       \n"
    "  fmlal za.s[w10, 0:1, VGx2], {z8.h-z9.h}, {z8.h-z9.h}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*9.0*(double)n_iterations;
}


static double fmlal_za_f32_f16_vgx2_ilp10(const void*) {
  // FMLAL (FP16 to FP32, two vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (64x f16, 64x f16) → 64x f32 (128 OPs)
  // Total of 1280 OPs per loop iteration, ILP = 10
  size_t n_iterations = N_ITERATIONS/10;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fmlal za.s[w8, 0:1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}       \n"
    "  fmlal za.s[w8, 2:3, VGx2], {z0.h-z1.h}, {z0.h-z1.h}       \n"
    "  fmlal za.s[w8, 4:5, VGx2], {z2.h-z3.h}, {z2.h-z3.h}       \n"
    "  fmlal za.s[w8, 6:7, VGx2], {z2.h-z3.h}, {z2.h-z3.h}       \n"
    "  fmlal za.s[w9, 0:1, VGx2], {z4.h-z5.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w9, 2:3, VGx2], {z4.h-z5.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w9, 4:5, VGx2], {z6.h-z7.h}, {z6.h-z7.h}       \n"
    "  fmlal za.s[w9, 6:7, VGx2], {z6.h-z7.h}, {z6.h-z7.h}       \n"
    "  fmlal za.s[w10, 0:1, VGx2], {z8.h-z9.h}, {z8.h-z9.h}      \n"
    "  fmlal za.s[w10, 2:3, VGx2], {z8.h-z9.h}, {z8.h-z9.h}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*10.0*(double)n_iterations;
}


static double fmlal_za_f32_f16_vgx2_ilp11(const void*) {
  // FMLAL (FP16 to FP32, two vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (64x f16, 64x f16) → 64x f32 (128 OPs)
  // Total of 1408 OPs per loop iteration, ILP = 11
  size_t n_iterations = N_ITERATIONS/11;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fmlal za.s[w8, 0:1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}       \n"
    "  fmlal za.s[w8, 2:3, VGx2], {z0.h-z1.h}, {z0.h-z1.h}       \n"
    "  fmlal za.s[w8, 4:5, VGx2], {z2.h-z3.h}, {z2.h-z3.h}       \n"
    "  fmlal za.s[w8, 6:7, VGx2], {z2.h-z3.h}, {z2.h-z3.h}       \n"
    "  fmlal za.s[w9, 0:1, VGx2], {z4.h-z5.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w9, 2:3, VGx2], {z4.h-z5.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w9, 4:5, VGx2], {z6.h-z7.h}, {z6.h-z7.h}       \n"
    "  fmlal za.s[w9, 6:7, VGx2], {z6.h-z7.h}, {z6.h-z7.h}       \n"
    "  fmlal za.s[w10, 0:1, VGx2], {z8.h-z9.h}, {z8.h-z9.h}      \n"
    "  fmlal za.s[w10, 2:3, VGx2], {z8.h-z9.h}, {z8.h-z9.h}      \n"
    "  fmlal za.s[w10, 4:5, VGx2], {z10.h-z11.h}, {z10.h-z11.h}  \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*11.0*(double)n_iterations;
}


static double fmlal_za_f32_f16_vgx2_ilp12(const void*) {
  // FMLAL (FP16 to FP32, two vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (64x f16, 64x f16) → 64x f32 (128 OPs)
  // Total of 1536 OPs per loop iteration, ILP = 12
  size_t n_iterations = N_ITERATIONS/12;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fmlal za.s[w8, 0:1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}       \n"
    "  fmlal za.s[w8, 2:3, VGx2], {z0.h-z1.h}, {z0.h-z1.h}       \n"
    "  fmlal za.s[w8, 4:5, VGx2], {z2.h-z3.h}, {z2.h-z3.h}       \n"
    "  fmlal za.s[w8, 6:7, VGx2], {z2.h-z3.h}, {z2.h-z3.h}       \n"
    "  fmlal za.s[w9, 0:1, VGx2], {z4.h-z5.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w9, 2:3, VGx2], {z4.h-z5.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w9, 4:5, VGx2], {z6.h-z7.h}, {z6.h-z7.h}       \n"
    "  fmlal za.s[w9, 6:7, VGx2], {z6.h-z7.h}, {z6.h-z7.h}       \n"
    "  fmlal za.s[w10, 0:1, VGx2], {z8.h-z9.h}, {z8.h-z9.h}      \n"
    "  fmlal za.s[w10, 2:3, VGx2], {z8.h-z9.h}, {z8.h-z9.h}      \n"
    "  fmlal za.s[w10, 4:5, VGx2], {z10.h-z11.h}, {z10.h-z11.h}  \n"
    "  fmlal za.s[w10, 6:7, VGx2], {z10.h-z11.h}, {z10.h-z11.h}  \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*12.0*(double)n_iterations;
}


static double fmlal_za_f32_f16_vgx2_ilp13(const void*) {
  // FMLAL (FP16 to FP32, two vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (64x f16, 64x f16) → 64x f32 (128 OPs)
  // Total of 1664 OPs per loop iteration, ILP = 13
  size_t n_iterations = N_ITERATIONS/13;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fmlal za.s[w8, 0:1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}       \n"
    "  fmlal za.s[w8, 2:3, VGx2], {z0.h-z1.h}, {z0.h-z1.h}       \n"
    "  fmlal za.s[w8, 4:5, VGx2], {z2.h-z3.h}, {z2.h-z3.h}       \n"
    "  fmlal za.s[w8, 6:7, VGx2], {z2.h-z3.h}, {z2.h-z3.h}       \n"
    "  fmlal za.s[w9, 0:1, VGx2], {z4.h-z5.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w9, 2:3, VGx2], {z4.h-z5.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w9, 4:5, VGx2], {z6.h-z7.h}, {z6.h-z7.h}       \n"
    "  fmlal za.s[w9, 6:7, VGx2], {z6.h-z7.h}, {z6.h-z7.h}       \n"
    "  fmlal za.s[w10, 0:1, VGx2], {z8.h-z9.h}, {z8.h-z9.h}      \n"
    "  fmlal za.s[w10, 2:3, VGx2], {z8.h-z9.h}, {z8.h-z9.h}      \n"
    "  fmlal za.s[w10, 4:5, VGx2], {z10.h-z11.h}, {z10.h-z11.h}  \n"
    "  fmlal za.s[w10, 6:7, VGx2], {z10.h-z11.h}, {z10.h-z11.h}  \n"
    "  fmlal za.s[w11, 0:1, VGx2], {z12.h-z13.h}, {z12.h-z13.h}  \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*13.0*(double)n_iterations;
}


static double fmlal_za_f32_f16_vgx2_ilp14(const void*) {
  // FMLAL (FP16 to FP32, two vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (64x f16, 64x f16) → 64x f32 (128 OPs)
  // Total of 1792 OPs per loop iteration, ILP = 14
  size_t n_iterations = N_ITERATIONS/14;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fmlal za.s[w8, 0:1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}       \n"
    "  fmlal za.s[w8, 2:3, VGx2], {z0.h-z1.h}, {z0.h-z1.h}       \n"
    "  fmlal za.s[w8, 4:5, VGx2], {z2.h-z3.h}, {z2.h-z3.h}       \n"
    "  fmlal za.s[w8, 6:7, VGx2], {z2.h-z3.h}, {z2.h-z3.h}       \n"
    "  fmlal za.s[w9, 0:1, VGx2], {z4.h-z5.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w9, 2:3, VGx2], {z4.h-z5.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w9, 4:5, VGx2], {z6.h-z7.h}, {z6.h-z7.h}       \n"
    "  fmlal za.s[w9, 6:7, VGx2], {z6.h-z7.h}, {z6.h-z7.h}       \n"
    "  fmlal za.s[w10, 0:1, VGx2], {z8.h-z9.h}, {z8.h-z9.h}      \n"
    "  fmlal za.s[w10, 2:3, VGx2], {z8.h-z9.h}, {z8.h-z9.h}      \n"
    "  fmlal za.s[w10, 4:5, VGx2], {z10.h-z11.h}, {z10.h-z11.h}  \n"
    "  fmlal za.s[w10, 6:7, VGx2], {z10.h-z11.h}, {z10.h-z11.h}  \n"
    "  fmlal za.s[w11, 0:1, VGx2], {z12.h-z13.h}, {z12.h-z13.h}  \n"
    "  fmlal za.s[w11, 2:3, VGx2], {z12.h-z13.h}, {z12.h-z13.h}  \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*14.0*(double)n_iterations;
}


static double fmlal_za_f32_f16_vgx2_ilp15(const void*) {
  // FMLAL (FP16 to FP32, two vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (64x f16, 64x f16) → 64x f32 (128 OPs)
  // Total of 1920 OPs per loop iteration, ILP = 15
  size_t n_iterations = N_ITERATIONS/15;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fmlal za.s[w8, 0:1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}       \n"
    "  fmlal za.s[w8, 2:3, VGx2], {z0.h-z1.h}, {z0.h-z1.h}       \n"
    "  fmlal za.s[w8, 4:5, VGx2], {z2.h-z3.h}, {z2.h-z3.h}       \n"
    "  fmlal za.s[w8, 6:7, VGx2], {z2.h-z3.h}, {z2.h-z3.h}       \n"
    "  fmlal za.s[w9, 0:1, VGx2], {z4.h-z5.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w9, 2:3, VGx2], {z4.h-z5.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w9, 4:5, VGx2], {z6.h-z7.h}, {z6.h-z7.h}       \n"
    "  fmlal za.s[w9, 6:7, VGx2], {z6.h-z7.h}, {z6.h-z7.h}       \n"
    "  fmlal za.s[w10, 0:1, VGx2], {z8.h-z9.h}, {z8.h-z9.h}      \n"
    "  fmlal za.s[w10, 2:3, VGx2], {z8.h-z9.h}, {z8.h-z9.h}      \n"
    "  fmlal za.s[w10, 4:5, VGx2], {z10.h-z11.h}, {z10.h-z11.h}  \n"
    "  fmlal za.s[w10, 6:7, VGx2], {z10.h-z11.h}, {z10.h-z11.h}  \n"
    "  fmlal za.s[w11, 0:1, VGx2], {z12.h-z13.h}, {z12.h-z13.h}  \n"
    "  fmlal za.s[w11, 2:3, VGx2], {z12.h-z13.h}, {z12.h-z13.h}  \n"
    "  fmlal za.s[w11, 4:5, VGx2], {z14.h-z15.h}, {z14.h-z15.h}  \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*15.0*(double)n_iterations;
}


static double fmlal_za_f32_f16_vgx2_ilp16(const void*) {
  // FMLAL (FP16 to FP32, two vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (64x f16, 64x f16) → 64x f32 (128 OPs)
  // Total of 2048 OPs per loop iteration, ILP = 16
  size_t n_iterations = N_ITERATIONS/16;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fmlal za.s[w8, 0:1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}       \n"
    "  fmlal za.s[w8, 2:3, VGx2], {z0.h-z1.h}, {z0.h-z1.h}       \n"
    "  fmlal za.s[w8, 4:5, VGx2], {z2.h-z3.h}, {z2.h-z3.h}       \n"
    "  fmlal za.s[w8, 6:7, VGx2], {z2.h-z3.h}, {z2.h-z3.h}       \n"
    "  fmlal za.s[w9, 0:1, VGx2], {z4.h-z5.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w9, 2:3, VGx2], {z4.h-z5.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w9, 4:5, VGx2], {z6.h-z7.h}, {z6.h-z7.h}       \n"
    "  fmlal za.s[w9, 6:7, VGx2], {z6.h-z7.h}, {z6.h-z7.h}       \n"
    "  fmlal za.s[w10, 0:1, VGx2], {z8.h-z9.h}, {z8.h-z9.h}      \n"
    "  fmlal za.s[w10, 2:3, VGx2], {z8.h-z9.h}, {z8.h-z9.h}      \n"
    "  fmlal za.s[w10, 4:5, VGx2], {z10.h-z11.h}, {z10.h-z11.h}  \n"
    "  fmlal za.s[w10, 6:7, VGx2], {z10.h-z11.h}, {z10.h-z11.h}  \n"
    "  fmlal za.s[w11, 0:1, VGx2], {z12.h-z13.h}, {z12.h-z13.h}  \n"
    "  fmlal za.s[w11, 2:3, VGx2], {z12.h-z13.h}, {z12.h-z13.h}  \n"
    "  fmlal za.s[w11, 4:5, VGx2], {z14.h-z15.h}, {z14.h-z15.h}  \n"
    "  fmlal za.s[w11, 6:7, VGx2], {z14.h-z15.h}, {z14.h-z15.h}  \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*16.0*(double)n_iterations;
}


static double fmlal_za_f32_f16_vgx4_ilp1(const void*) {
  // FMLAL (FP16 to FP32, four vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (128x f16, 128x f16) → 128x f32 (256 OPs)
  // Total of 256 OPs per loop iteration, ILP = 1
  size_t n_iterations = N_ITERATIONS;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fmlal za.s[w8, 0:1, VGx4], {z0.h-z3.h}, {z0.h-z3.h}       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*1.0*(double)n_iterations;
}


static double fmlal_za_f32_f16_vgx4_ilp2(const void*) {
  // FMLAL (FP16 to FP32, four vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (128x f16, 128x f16) → 128x f32 (256 OPs)
  // Total of 512 OPs per loop iteration, ILP = 2
  size_t n_iterations = N_ITERATIONS/2;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fmlal za.s[w8, 0:1, VGx4], {z0.h-z3.h}, {z0.h-z3.h}       \n"
    "  fmlal za.s[w8, 2:3, VGx4], {z0.h-z3.h}, {z0.h-z3.h}       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*2.0*(double)n_iterations;
}


static double fmlal_za_f32_f16_vgx4_ilp3(const void*) {
  // FMLAL (FP16 to FP32, four vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (128x f16, 128x f16) → 128x f32 (256 OPs)
  // Total of 768 OPs per loop iteration, ILP = 3
  size_t n_iterations = N_ITERATIONS/3;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fmlal za.s[w8, 0:1, VGx4], {z0.h-z3.h}, {z0.h-z3.h}       \n"
    "  fmlal za.s[w8, 2:3, VGx4], {z0.h-z3.h}, {z0.h-z3.h}       \n"
    "  fmlal za.s[w8, 4:5, VGx4], {z0.h-z3.h}, {z0.h-z3.h}       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*3.0*(double)n_iterations;
}


static double fmlal_za_f32_f16_vgx4_ilp4(const void*) {
  // FMLAL (FP16 to FP32, four vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (128x f16, 128x f16) → 128x f32 (256 OPs)
  // Total of 1024 OPs per loop iteration, ILP = 4
  size_t n_iterations = N_ITERATIONS/4;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fmlal za.s[w8, 0:1, VGx4], {z0.h-z3.h}, {z0.h-z3.h}       \n"
    "  fmlal za.s[w8, 2:3, VGx4], {z0.h-z3.h}, {z0.h-z3.h}       \n"
    "  fmlal za.s[w8, 4:5, VGx4], {z0.h-z3.h}, {z0.h-z3.h}       \n"
    "  fmlal za.s[w8, 6:7, VGx4], {z0.h-z3.h}, {z0.h-z3.h}       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*4.0*(double)n_iterations;
}


static double fmlal_za_f32_f16_vgx4_ilp5(const void*) {
  // FMLAL (FP16 to FP32, four vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (128x f16, 128x f16) → 128x f32 (256 OPs)
  // Total of 1280 OPs per loop iteration, ILP = 5
  size_t n_iterations = N_ITERATIONS/5;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fmlal za.s[w8, 0:1, VGx4], {z0.h-z3.h}, {z0.h-z3.h}       \n"
    "  fmlal za.s[w8, 2:3, VGx4], {z0.h-z3.h}, {z0.h-z3.h}       \n"
    "  fmlal za.s[w8, 4:5, VGx4], {z0.h-z3.h}, {z0.h-z3.h}       \n"
    "  fmlal za.s[w8, 6:7, VGx4], {z0.h-z3.h}, {z0.h-z3.h}       \n"
    "  fmlal za.s[w9, 0:1, VGx4], {z4.h-z7.h}, {z4.h-z7.h}       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*5.0*(double)n_iterations;
}


static double fmlal_za_f32_f16_vgx4_ilp6(const void*) {
  // FMLAL (FP16 to FP32, four vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (128x f16, 128x f16) → 128x f32 (256 OPs)
  // Total of 1536 OPs per loop iteration, ILP = 6
  size_t n_iterations = N_ITERATIONS/6;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fmlal za.s[w8, 0:1, VGx4], {z0.h-z3.h}, {z0.h-z3.h}       \n"
    "  fmlal za.s[w8, 2:3, VGx4], {z0.h-z3.h}, {z0.h-z3.h}       \n"
    "  fmlal za.s[w8, 4:5, VGx4], {z0.h-z3.h}, {z0.h-z3.h}       \n"
    "  fmlal za.s[w8, 6:7, VGx4], {z0.h-z3.h}, {z0.h-z3.h}       \n"
    "  fmlal za.s[w9, 0:1, VGx4], {z4.h-z7.h}, {z4.h-z7.h}       \n"
    "  fmlal za.s[w9, 2:3, VGx4], {z4.h-z7.h}, {z4.h-z7.h}       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*6.0*(double)n_iterations;
}


static double fmlal_za_f32_f16_vgx4_ilp7(const void*) {
  // FMLAL (FP16 to FP32, four vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (128x f16, 128x f16) → 128x f32 (256 OPs)
  // Total of 1792 OPs per loop iteration, ILP = 7
  size_t n_iterations = N_ITERATIONS/7;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fmlal za.s[w8, 0:1, VGx4], {z0.h-z3.h}, {z0.h-z3.h}       \n"
    "  fmlal za.s[w8, 2:3, VGx4], {z0.h-z3.h}, {z0.h-z3.h}       \n"
    "  fmlal za.s[w8, 4:5, VGx4], {z0.h-z3.h}, {z0.h-z3.h}       \n"
    "  fmlal za.s[w8, 6:7, VGx4], {z0.h-z3.h}, {z0.h-z3.h}       \n"
    "  fmlal za.s[w9, 0:1, VGx4], {z4.h-z7.h}, {z4.h-z7.h}       \n"
    "  fmlal za.s[w9, 2:3, VGx4], {z4.h-z7.h}, {z4.h-z7.h}       \n"
    "  fmlal za.s[w9, 4:5, VGx4], {z4.h-z7.h}, {z4.h-z7.h}       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*7.0*(double)n_iterations;
}


static double fmlal_za_f32_f16_vgx4_ilp8(const void*) {
  // FMLAL (FP16 to FP32, four vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (128x f16, 128x f16) → 128x f32 (256 OPs)
  // Total of 2048 OPs per loop iteration, ILP = 8
  size_t n_iterations = N_ITERATIONS/8;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  fmlal za.s[w8, 0:1, VGx4], {z0.h-z3.h}, {z0.h-z3.h}       \n"
    "  fmlal za.s[w8, 2:3, VGx4], {z0.h-z3.h}, {z0.h-z3.h}       \n"
    "  fmlal za.s[w8, 4:5, VGx4], {z0.h-z3.h}, {z0.h-z3.h}       \n"
    "  fmlal za.s[w8, 6:7, VGx4], {z0.h-z3.h}, {z0.h-z3.h}       \n"
    "  fmlal za.s[w9, 0:1, VGx4], {z4.h-z7.h}, {z4.h-z7.h}       \n"
    "  fmlal za.s[w9, 2:3, VGx4], {z4.h-z7.h}, {z4.h-z7.h}       \n"
    "  fmlal za.s[w9, 4:5, VGx4], {z4.h-z7.h}, {z4.h-z7.h}       \n"
    "  fmlal za.s[w9, 6:7, VGx4], {z4.h-z7.h}, {z4.h-z7.h}       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*8.0*(double)n_iterations;
}


static double bfmlal_za_f32_b16_vgx2_ilp1(const void*) {
  // BFMLAL (BF16 to FP32, two vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (64x b16, 64x b16) → 64x f32 (128 OPs)
  // Total of 128 OPs per loop iteration, ILP = 1
  size_t n_iterations = N_ITERATIONS;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  bfmlal za.s[w8, 0:1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*1.0*(double)n_iterations;
}


static double bfmlal_za_f32_b16_vgx2_ilp2(const void*) {
  // BFMLAL (BF16 to FP32, two vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (64x b16, 64x b16) → 64x f32 (128 OPs)
  // Total of 256 OPs per loop iteration, ILP = 2
  size_t n_iterations = N_ITERATIONS/2;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  bfmlal za.s[w8, 0:1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}      \n"
    "  bfmlal za.s[w8, 2:3, VGx2], {z0.h-z1.h}, {z0.h-z1.h}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*2.0*(double)n_iterations;
}


static double bfmlal_za_f32_b16_vgx2_ilp3(const void*) {
  // BFMLAL (BF16 to FP32, two vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (64x b16, 64x b16) → 64x f32 (128 OPs)
  // Total of 384 OPs per loop iteration, ILP = 3
  size_t n_iterations = N_ITERATIONS/3;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  bfmlal za.s[w8, 0:1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}      \n"
    "  bfmlal za.s[w8, 2:3, VGx2], {z0.h-z1.h}, {z0.h-z1.h}      \n"
    "  bfmlal za.s[w8, 4:5, VGx2], {z2.h-z3.h}, {z2.h-z3.h}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*3.0*(double)n_iterations;
}


static double bfmlal_za_f32_b16_vgx2_ilp4(const void*) {
  // BFMLAL (BF16 to FP32, two vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (64x b16, 64x b16) → 64x f32 (128 OPs)
  // Total of 512 OPs per loop iteration, ILP = 4
  size_t n_iterations = N_ITERATIONS/4;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  bfmlal za.s[w8, 0:1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}      \n"
    "  bfmlal za.s[w8, 2:3, VGx2], {z0.h-z1.h}, {z0.h-z1.h}      \n"
    "  bfmlal za.s[w8, 4:5, VGx2], {z2.h-z3.h}, {z2.h-z3.h}      \n"
    "  bfmlal za.s[w8, 6:7, VGx2], {z2.h-z3.h}, {z2.h-z3.h}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*4.0*(double)n_iterations;
}


static double bfmlal_za_f32_b16_vgx2_ilp5(const void*) {
  // BFMLAL (BF16 to FP32, two vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (64x b16, 64x b16) → 64x f32 (128 OPs)
  // Total of 640 OPs per loop iteration, ILP = 5
  size_t n_iterations = N_ITERATIONS/5;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  bfmlal za.s[w8, 0:1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}      \n"
    "  bfmlal za.s[w8, 2:3, VGx2], {z0.h-z1.h}, {z0.h-z1.h}      \n"
    "  bfmlal za.s[w8, 4:5, VGx2], {z2.h-z3.h}, {z2.h-z3.h}      \n"
    "  bfmlal za.s[w8, 6:7, VGx2], {z2.h-z3.h}, {z2.h-z3.h}      \n"
    "  bfmlal za.s[w9, 0:1, VGx2], {z4.h-z5.h}, {z4.h-z5.h}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*5.0*(double)n_iterations;
}


static double bfmlal_za_f32_b16_vgx2_ilp6(const void*) {
  // BFMLAL (BF16 to FP32, two vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (64x b16, 64x b16) → 64x f32 (128 OPs)
  // Total of 768 OPs per loop iteration, ILP = 6
  size_t n_iterations = N_ITERATIONS/6;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  bfmlal za.s[w8, 0:1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}      \n"
    "  bfmlal za.s[w8, 2:3, VGx2], {z0.h-z1.h}, {z0.h-z1.h}      \n"
    "  bfmlal za.s[w8, 4:5, VGx2], {z2.h-z3.h}, {z2.h-z3.h}      \n"
    "  bfmlal za.s[w8, 6:7, VGx2], {z2.h-z3.h}, {z2.h-z3.h}      \n"
    "  bfmlal za.s[w9, 0:1, VGx2], {z4.h-z5.h}, {z4.h-z5.h}      \n"
    "  bfmlal za.s[w9, 2:3, VGx2], {z4.h-z5.h}, {z4.h-z5.h}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*6.0*(double)n_iterations;
}


static double bfmlal_za_f32_b16_vgx2_ilp7(const void*) {
  // BFMLAL (BF16 to FP32, two vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (64x b16, 64x b16) → 64x f32 (128 OPs)
  // Total of 896 OPs per loop iteration, ILP = 7
  size_t n_iterations = N_ITERATIONS/7;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  bfmlal za.s[w8, 0:1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}      \n"
    "  bfmlal za.s[w8, 2:3, VGx2], {z0.h-z1.h}, {z0.h-z1.h}      \n"
    "  bfmlal za.s[w8, 4:5, VGx2], {z2.h-z3.h}, {z2.h-z3.h}      \n"
    "  bfmlal za.s[w8, 6:7, VGx2], {z2.h-z3.h}, {z2.h-z3.h}      \n"
    "  bfmlal za.s[w9, 0:1, VGx2], {z4.h-z5.h}, {z4.h-z5.h}      \n"
    "  bfmlal za.s[w9, 2:3, VGx2], {z4.h-z5.h}, {z4.h-z5.h}      \n"
    "  bfmlal za.s[w9, 4:5, VGx2], {z6.h-z7.h}, {z6.h-z7.h}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*7.0*(double)n_iterations;
}


static double bfmlal_za_f32_b16_vgx2_ilp8(const void*) {
  // BFMLAL (BF16 to FP32, two vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (64x b16, 64x b16) → 64x f32 (128 OPs)
  // Total of 1024 OPs per loop iteration, ILP = 8
  size_t n_iterations = N_ITERATIONS/8;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  bfmlal za.s[w8, 0:1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}      \n"
    "  bfmlal za.s[w8, 2:3, VGx2], {z0.h-z1.h}, {z0.h-z1.h}      \n"
    "  bfmlal za.s[w8, 4:5, VGx2], {z2.h-z3.h}, {z2.h-z3.h}      \n"
    "  bfmlal za.s[w8, 6:7, VGx2], {z2.h-z3.h}, {z2.h-z3.h}      \n"
    "  bfmlal za.s[w9, 0:1, VGx2], {z4.h-z5.h}, {z4.h-z5.h}      \n"
    "  bfmlal za.s[w9, 2:3, VGx2], {z4.h-z5.h}, {z4.h-z5.h}      \n"
    "  bfmlal za.s[w9, 4:5, VGx2], {z6.h-z7.h}, {z6.h-z7.h}      \n"
    "  bfmlal za.s[w9, 6:7, VGx2], {z6.h-z7.h}, {z6.h-z7.h}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*8.0*(double)n_iterations;
}


static double bfmlal_za_f32_b16_vgx2_ilp9(const void*) {
  // BFMLAL (BF16 to FP32, two vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (64x b16, 64x b16) → 64x f32 (128 OPs)
  // Total of 1152 OPs per loop iteration, ILP = 9
  size_t n_iterations = N_ITERATIONS/9;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  bfmlal za.s[w8, 0:1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}      \n"
    "  bfmlal za.s[w8, 2:3, VGx2], {z0.h-z1.h}, {z0.h-z1.h}      \n"
    "  bfmlal za.s[w8, 4:5, VGx2], {z2.h-z3.h}, {z2.h-z3.h}      \n"
    "  bfmlal za.s[w8, 6:7, VGx2], {z2.h-z3.h}, {z2.h-z3.h}      \n"
    "  bfmlal za.s[w9, 0:1, VGx2], {z4.h-z5.h}, {z4.h-z5.h}      \n"
    "  bfmlal za.s[w9, 2:3, VGx2], {z4.h-z5.h}, {z4.h-z5.h}      \n"
    "  bfmlal za.s[w9, 4:5, VGx2], {z6.h-z7.h}, {z6.h-z7.h}      \n"
    "  bfmlal za.s[w9, 6:7, VGx2], {z6.h-z7.h}, {z6.h-z7.h}      \n"
    "  bfmlal za.s[w10, 0:1, VGx2], {z8.h-z9.h}, {z8.h-z9.h}     \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*9.0*(double)n_iterations;
}


static double bfmlal_za_f32_b16_vgx2_ilp10(const void*) {
  // BFMLAL (BF16 to FP32, two vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (64x b16, 64x b16) → 64x f32 (128 OPs)
  // Total of 1280 OPs per loop iteration, ILP = 10
  size_t n_iterations = N_ITERATIONS/10;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  bfmlal za.s[w8, 0:1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}      \n"
    "  bfmlal za.s[w8, 2:3, VGx2], {z0.h-z1.h}, {z0.h-z1.h}      \n"
    "  bfmlal za.s[w8, 4:5, VGx2], {z2.h-z3.h}, {z2.h-z3.h}      \n"
    "  bfmlal za.s[w8, 6:7, VGx2], {z2.h-z3.h}, {z2.h-z3.h}      \n"
    "  bfmlal za.s[w9, 0:1, VGx2], {z4.h-z5.h}, {z4.h-z5.h}      \n"
    "  bfmlal za.s[w9, 2:3, VGx2], {z4.h-z5.h}, {z4.h-z5.h}      \n"
    "  bfmlal za.s[w9, 4:5, VGx2], {z6.h-z7.h}, {z6.h-z7.h}      \n"
    "  bfmlal za.s[w9, 6:7, VGx2], {z6.h-z7.h}, {z6.h-z7.h}      \n"
    "  bfmlal za.s[w10, 0:1, VGx2], {z8.h-z9.h}, {z8.h-z9.h}     \n"
    "  bfmlal za.s[w10, 2:3, VGx2], {z8.h-z9.h}, {z8.h-z9.h}     \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*10.0*(double)n_iterations;
}


static double bfmlal_za_f32_b16_vgx2_ilp11(const void*) {
  // BFMLAL (BF16 to FP32, two vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (64x b16, 64x b16) → 64x f32 (128 OPs)
  // Total of 1408 OPs per loop iteration, ILP = 11
  size_t n_iterations = N_ITERATIONS/11;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  bfmlal za.s[w8, 0:1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}      \n"
    "  bfmlal za.s[w8, 2:3, VGx2], {z0.h-z1.h}, {z0.h-z1.h}      \n"
    "  bfmlal za.s[w8, 4:5, VGx2], {z2.h-z3.h}, {z2.h-z3.h}      \n"
    "  bfmlal za.s[w8, 6:7, VGx2], {z2.h-z3.h}, {z2.h-z3.h}      \n"
    "  bfmlal za.s[w9, 0:1, VGx2], {z4.h-z5.h}, {z4.h-z5.h}      \n"
    "  bfmlal za.s[w9, 2:3, VGx2], {z4.h-z5.h}, {z4.h-z5.h}      \n"
    "  bfmlal za.s[w9, 4:5, VGx2], {z6.h-z7.h}, {z6.h-z7.h}      \n"
    "  bfmlal za.s[w9, 6:7, VGx2], {z6.h-z7.h}, {z6.h-z7.h}      \n"
    "  bfmlal za.s[w10, 0:1, VGx2], {z8.h-z9.h}, {z8.h-z9.h}     \n"
    "  bfmlal za.s[w10, 2:3, VGx2], {z8.h-z9.h}, {z8.h-z9.h}     \n"
    "  bfmlal za.s[w10, 4:5, VGx2], {z10.h-z11.h}, {z10.h-z11.h} \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*11.0*(double)n_iterations;
}


static double bfmlal_za_f32_b16_vgx2_ilp12(const void*) {
  // BFMLAL (BF16 to FP32, two vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (64x b16, 64x b16) → 64x f32 (128 OPs)
  // Total of 1536 OPs per loop iteration, ILP = 12
  size_t n_iterations = N_ITERATIONS/12;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  bfmlal za.s[w8, 0:1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}      \n"
    "  bfmlal za.s[w8, 2:3, VGx2], {z0.h-z1.h}, {z0.h-z1.h}      \n"
    "  bfmlal za.s[w8, 4:5, VGx2], {z2.h-z3.h}, {z2.h-z3.h}      \n"
    "  bfmlal za.s[w8, 6:7, VGx2], {z2.h-z3.h}, {z2.h-z3.h}      \n"
    "  bfmlal za.s[w9, 0:1, VGx2], {z4.h-z5.h}, {z4.h-z5.h}      \n"
    "  bfmlal za.s[w9, 2:3, VGx2], {z4.h-z5.h}, {z4.h-z5.h}      \n"
    "  bfmlal za.s[w9, 4:5, VGx2], {z6.h-z7.h}, {z6.h-z7.h}      \n"
    "  bfmlal za.s[w9, 6:7, VGx2], {z6.h-z7.h}, {z6.h-z7.h}      \n"
    "  bfmlal za.s[w10, 0:1, VGx2], {z8.h-z9.h}, {z8.h-z9.h}     \n"
    "  bfmlal za.s[w10, 2:3, VGx2], {z8.h-z9.h}, {z8.h-z9.h}     \n"
    "  bfmlal za.s[w10, 4:5, VGx2], {z10.h-z11.h}, {z10.h-z11.h} \n"
    "  bfmlal za.s[w10, 6:7, VGx2], {z10.h-z11.h}, {z10.h-z11.h} \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*12.0*(double)n_iterations;
}


static double bfmlal_za_f32_b16_vgx2_ilp13(const void*) {
  // BFMLAL (BF16 to FP32, two vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (64x b16, 64x b16) → 64x f32 (128 OPs)
  // Total of 1664 OPs per loop iteration, ILP = 13
  size_t n_iterations = N_ITERATIONS/13;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  bfmlal za.s[w8, 0:1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}      \n"
    "  bfmlal za.s[w8, 2:3, VGx2], {z0.h-z1.h}, {z0.h-z1.h}      \n"
    "  bfmlal za.s[w8, 4:5, VGx2], {z2.h-z3.h}, {z2.h-z3.h}      \n"
    "  bfmlal za.s[w8, 6:7, VGx2], {z2.h-z3.h}, {z2.h-z3.h}      \n"
    "  bfmlal za.s[w9, 0:1, VGx2], {z4.h-z5.h}, {z4.h-z5.h}      \n"
    "  bfmlal za.s[w9, 2:3, VGx2], {z4.h-z5.h}, {z4.h-z5.h}      \n"
    "  bfmlal za.s[w9, 4:5, VGx2], {z6.h-z7.h}, {z6.h-z7.h}      \n"
    "  bfmlal za.s[w9, 6:7, VGx2], {z6.h-z7.h}, {z6.h-z7.h}      \n"
    "  bfmlal za.s[w10, 0:1, VGx2], {z8.h-z9.h}, {z8.h-z9.h}     \n"
    "  bfmlal za.s[w10, 2:3, VGx2], {z8.h-z9.h}, {z8.h-z9.h}     \n"
    "  bfmlal za.s[w10, 4:5, VGx2], {z10.h-z11.h}, {z10.h-z11.h} \n"
    "  bfmlal za.s[w10, 6:7, VGx2], {z10.h-z11.h}, {z10.h-z11.h} \n"
    "  bfmlal za.s[w11, 0:1, VGx2], {z12.h-z13.h}, {z12.h-z13.h} \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*13.0*(double)n_iterations;
}


static double bfmlal_za_f32_b16_vgx2_ilp14(const void*) {
  // BFMLAL (BF16 to FP32, two vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (64x b16, 64x b16) → 64x f32 (128 OPs)
  // Total of 1792 OPs per loop iteration, ILP = 14
  size_t n_iterations = N_ITERATIONS/14;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  bfmlal za.s[w8, 0:1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}      \n"
    "  bfmlal za.s[w8, 2:3, VGx2], {z0.h-z1.h}, {z0.h-z1.h}      \n"
    "  bfmlal za.s[w8, 4:5, VGx2], {z2.h-z3.h}, {z2.h-z3.h}      \n"
    "  bfmlal za.s[w8, 6:7, VGx2], {z2.h-z3.h}, {z2.h-z3.h}      \n"
    "  bfmlal za.s[w9, 0:1, VGx2], {z4.h-z5.h}, {z4.h-z5.h}      \n"
    "  bfmlal za.s[w9, 2:3, VGx2], {z4.h-z5.h}, {z4.h-z5.h}      \n"
    "  bfmlal za.s[w9, 4:5, VGx2], {z6.h-z7.h}, {z6.h-z7.h}      \n"
    "  bfmlal za.s[w9, 6:7, VGx2], {z6.h-z7.h}, {z6.h-z7.h}      \n"
    "  bfmlal za.s[w10, 0:1, VGx2], {z8.h-z9.h}, {z8.h-z9.h}     \n"
    "  bfmlal za.s[w10, 2:3, VGx2], {z8.h-z9.h}, {z8.h-z9.h}     \n"
    "  bfmlal za.s[w10, 4:5, VGx2], {z10.h-z11.h}, {z10.h-z11.h} \n"
    "  bfmlal za.s[w10, 6:7, VGx2], {z10.h-z11.h}, {z10.h-z11.h} \n"
    "  bfmlal za.s[w11, 0:1, VGx2], {z12.h-z13.h}, {z12.h-z13.h} \n"
    "  bfmlal za.s[w11, 2:3, VGx2], {z12.h-z13.h}, {z12.h-z13.h} \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*14.0*(double)n_iterations;
}


static double bfmlal_za_f32_b16_vgx2_ilp15(const void*) {
  // BFMLAL (BF16 to FP32, two vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (64x b16, 64x b16) → 64x f32 (128 OPs)
  // Total of 1920 OPs per loop iteration, ILP = 15
  size_t n_iterations = N_ITERATIONS/15;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  bfmlal za.s[w8, 0:1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}      \n"
    "  bfmlal za.s[w8, 2:3, VGx2], {z0.h-z1.h}, {z0.h-z1.h}      \n"
    "  bfmlal za.s[w8, 4:5, VGx2], {z2.h-z3.h}, {z2.h-z3.h}      \n"
    "  bfmlal za.s[w8, 6:7, VGx2], {z2.h-z3.h}, {z2.h-z3.h}      \n"
    "  bfmlal za.s[w9, 0:1, VGx2], {z4.h-z5.h}, {z4.h-z5.h}      \n"
    "  bfmlal za.s[w9, 2:3, VGx2], {z4.h-z5.h}, {z4.h-z5.h}      \n"
    "  bfmlal za.s[w9, 4:5, VGx2], {z6.h-z7.h}, {z6.h-z7.h}      \n"
    "  bfmlal za.s[w9, 6:7, VGx2], {z6.h-z7.h}, {z6.h-z7.h}      \n"
    "  bfmlal za.s[w10, 0:1, VGx2], {z8.h-z9.h}, {z8.h-z9.h}     \n"
    "  bfmlal za.s[w10, 2:3, VGx2], {z8.h-z9.h}, {z8.h-z9.h}     \n"
    "  bfmlal za.s[w10, 4:5, VGx2], {z10.h-z11.h}, {z10.h-z11.h} \n"
    "  bfmlal za.s[w10, 6:7, VGx2], {z10.h-z11.h}, {z10.h-z11.h} \n"
    "  bfmlal za.s[w11, 0:1, VGx2], {z12.h-z13.h}, {z12.h-z13.h} \n"
    "  bfmlal za.s[w11, 2:3, VGx2], {z12.h-z13.h}, {z12.h-z13.h} \n"
    "  bfmlal za.s[w11, 4:5, VGx2], {z14.h-z15.h}, {z14.h-z15.h} \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*15.0*(double)n_iterations;
}


static double bfmlal_za_f32_b16_vgx2_ilp16(const void*) {
  // BFMLAL (BF16 to FP32, two vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (64x b16, 64x b16) → 64x f32 (128 OPs)
  // Total of 2048 OPs per loop iteration, ILP = 16
  size_t n_iterations = N_ITERATIONS/16;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  bfmlal za.s[w8, 0:1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}      \n"
    "  bfmlal za.s[w8, 2:3, VGx2], {z0.h-z1.h}, {z0.h-z1.h}      \n"
    "  bfmlal za.s[w8, 4:5, VGx2], {z2.h-z3.h}, {z2.h-z3.h}      \n"
    "  bfmlal za.s[w8, 6:7, VGx2], {z2.h-z3.h}, {z2.h-z3.h}      \n"
    "  bfmlal za.s[w9, 0:1, VGx2], {z4.h-z5.h}, {z4.h-z5.h}      \n"
    "  bfmlal za.s[w9, 2:3, VGx2], {z4.h-z5.h}, {z4.h-z5.h}      \n"
    "  bfmlal za.s[w9, 4:5, VGx2], {z6.h-z7.h}, {z6.h-z7.h}      \n"
    "  bfmlal za.s[w9, 6:7, VGx2], {z6.h-z7.h}, {z6.h-z7.h}      \n"
    "  bfmlal za.s[w10, 0:1, VGx2], {z8.h-z9.h}, {z8.h-z9.h}     \n"
    "  bfmlal za.s[w10, 2:3, VGx2], {z8.h-z9.h}, {z8.h-z9.h}     \n"
    "  bfmlal za.s[w10, 4:5, VGx2], {z10.h-z11.h}, {z10.h-z11.h} \n"
    "  bfmlal za.s[w10, 6:7, VGx2], {z10.h-z11.h}, {z10.h-z11.h} \n"
    "  bfmlal za.s[w11, 0:1, VGx2], {z12.h-z13.h}, {z12.h-z13.h} \n"
    "  bfmlal za.s[w11, 2:3, VGx2], {z12.h-z13.h}, {z12.h-z13.h} \n"
    "  bfmlal za.s[w11, 4:5, VGx2], {z14.h-z15.h}, {z14.h-z15.h} \n"
    "  bfmlal za.s[w11, 6:7, VGx2], {z14.h-z15.h}, {z14.h-z15.h} \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*16.0*(double)n_iterations;
}


static double bfmlal_za_f32_b16_vgx4_ilp1(const void*) {
  // BFMLAL (BF16 to FP32, four vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (128x b16, 128x b16) → 128x f32 (256 OPs)
  // Total of 256 OPs per loop iteration, ILP = 1
  size_t n_iterations = N_ITERATIONS;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  bfmlal za.s[w8, 0:1, VGx4], {z0.h-z3.h}, {z0.h-z3.h}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*1.0*(double)n_iterations;
}


static double bfmlal_za_f32_b16_vgx4_ilp2(const void*) {
  // BFMLAL (BF16 to FP32, four vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (128x b16, 128x b16) → 128x f32 (256 OPs)
  // Total of 512 OPs per loop iteration, ILP = 2
  size_t n_iterations = N_ITERATIONS/2;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  bfmlal za.s[w8, 0:1, VGx4], {z0.h-z3.h}, {z0.h-z3.h}      \n"
    "  bfmlal za.s[w8, 2:3, VGx4], {z0.h-z3.h}, {z0.h-z3.h}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*2.0*(double)n_iterations;
}


static double bfmlal_za_f32_b16_vgx4_ilp3(const void*) {
  // BFMLAL (BF16 to FP32, four vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (128x b16, 128x b16) → 128x f32 (256 OPs)
  // Total of 768 OPs per loop iteration, ILP = 3
  size_t n_iterations = N_ITERATIONS/3;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  bfmlal za.s[w8, 0:1, VGx4], {z0.h-z3.h}, {z0.h-z3.h}      \n"
    "  bfmlal za.s[w8, 2:3, VGx4], {z0.h-z3.h}, {z0.h-z3.h}      \n"
    "  bfmlal za.s[w8, 4:5, VGx4], {z0.h-z3.h}, {z0.h-z3.h}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*3.0*(double)n_iterations;
}


static double bfmlal_za_f32_b16_vgx4_ilp4(const void*) {
  // BFMLAL (BF16 to FP32, four vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (128x b16, 128x b16) → 128x f32 (256 OPs)
  // Total of 1024 OPs per loop iteration, ILP = 4
  size_t n_iterations = N_ITERATIONS/4;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  bfmlal za.s[w8, 0:1, VGx4], {z0.h-z3.h}, {z0.h-z3.h}      \n"
    "  bfmlal za.s[w8, 2:3, VGx4], {z0.h-z3.h}, {z0.h-z3.h}      \n"
    "  bfmlal za.s[w8, 4:5, VGx4], {z0.h-z3.h}, {z0.h-z3.h}      \n"
    "  bfmlal za.s[w8, 6:7, VGx4], {z0.h-z3.h}, {z0.h-z3.h}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*4.0*(double)n_iterations;
}


static double bfmlal_za_f32_b16_vgx4_ilp5(const void*) {
  // BFMLAL (BF16 to FP32, four vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (128x b16, 128x b16) → 128x f32 (256 OPs)
  // Total of 1280 OPs per loop iteration, ILP = 5
  size_t n_iterations = N_ITERATIONS/5;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  bfmlal za.s[w8, 0:1, VGx4], {z0.h-z3.h}, {z0.h-z3.h}      \n"
    "  bfmlal za.s[w8, 2:3, VGx4], {z0.h-z3.h}, {z0.h-z3.h}      \n"
    "  bfmlal za.s[w8, 4:5, VGx4], {z0.h-z3.h}, {z0.h-z3.h}      \n"
    "  bfmlal za.s[w8, 6:7, VGx4], {z0.h-z3.h}, {z0.h-z3.h}      \n"
    "  bfmlal za.s[w9, 0:1, VGx4], {z4.h-z7.h}, {z4.h-z7.h}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*5.0*(double)n_iterations;
}


static double bfmlal_za_f32_b16_vgx4_ilp6(const void*) {
  // BFMLAL (BF16 to FP32, four vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (128x b16, 128x b16) → 128x f32 (256 OPs)
  // Total of 1536 OPs per loop iteration, ILP = 6
  size_t n_iterations = N_ITERATIONS/6;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  bfmlal za.s[w8, 0:1, VGx4], {z0.h-z3.h}, {z0.h-z3.h}      \n"
    "  bfmlal za.s[w8, 2:3, VGx4], {z0.h-z3.h}, {z0.h-z3.h}      \n"
    "  bfmlal za.s[w8, 4:5, VGx4], {z0.h-z3.h}, {z0.h-z3.h}      \n"
    "  bfmlal za.s[w8, 6:7, VGx4], {z0.h-z3.h}, {z0.h-z3.h}      \n"
    "  bfmlal za.s[w9, 0:1, VGx4], {z4.h-z7.h}, {z4.h-z7.h}      \n"
    "  bfmlal za.s[w9, 2:3, VGx4], {z4.h-z7.h}, {z4.h-z7.h}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*6.0*(double)n_iterations;
}


static double bfmlal_za_f32_b16_vgx4_ilp7(const void*) {
  // BFMLAL (BF16 to FP32, four vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (128x b16, 128x b16) → 128x f32 (256 OPs)
  // Total of 1792 OPs per loop iteration, ILP = 7
  size_t n_iterations = N_ITERATIONS/7;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  bfmlal za.s[w8, 0:1, VGx4], {z0.h-z3.h}, {z0.h-z3.h}      \n"
    "  bfmlal za.s[w8, 2:3, VGx4], {z0.h-z3.h}, {z0.h-z3.h}      \n"
    "  bfmlal za.s[w8, 4:5, VGx4], {z0.h-z3.h}, {z0.h-z3.h}      \n"
    "  bfmlal za.s[w8, 6:7, VGx4], {z0.h-z3.h}, {z0.h-z3.h}      \n"
    "  bfmlal za.s[w9, 0:1, VGx4], {z4.h-z7.h}, {z4.h-z7.h}      \n"
    "  bfmlal za.s[w9, 2:3, VGx4], {z4.h-z7.h}, {z4.h-z7.h}      \n"
    "  bfmlal za.s[w9, 4:5, VGx4], {z4.h-z7.h}, {z4.h-z7.h}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*7.0*(double)n_iterations;
}


static double bfmlal_za_f32_b16_vgx4_ilp8(const void*) {
  // BFMLAL (BF16 to FP32, four vectors), Multiply-Accumulate (floating-point)
  //
  // Each instruction: (128x b16, 128x b16) → 128x f32 (256 OPs)
  // Total of 2048 OPs per loop iteration, ILP = 8
  size_t n_iterations = N_ITERATIONS/8;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  bfmlal za.s[w8, 0:1, VGx4], {z0.h-z3.h}, {z0.h-z3.h}      \n"
    "  bfmlal za.s[w8, 2:3, VGx4], {z0.h-z3.h}, {z0.h-z3.h}      \n"
    "  bfmlal za.s[w8, 4:5, VGx4], {z0.h-z3.h}, {z0.h-z3.h}      \n"
    "  bfmlal za.s[w8, 6:7, VGx4], {z0.h-z3.h}, {z0.h-z3.h}      \n"
    "  bfmlal za.s[w9, 0:1, VGx4], {z4.h-z7.h}, {z4.h-z7.h}      \n"
    "  bfmlal za.s[w9, 2:3, VGx4], {z4.h-z7.h}, {z4.h-z7.h}      \n"
    "  bfmlal za.s[w9, 4:5, VGx4], {z4.h-z7.h}, {z4.h-z7.h}      \n"
    "  bfmlal za.s[w9, 6:7, VGx4], {z4.h-z7.h}, {z4.h-z7.h}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*8.0*(double)n_iterations;
}


static double mla_i8_i8_ilp1(const void*) {
  // MLA (I8, one vector), Multiply-Accumulate (integer)
  //
  // Each instruction: (64x i8, 64x i8) → 64x i8 (128 OPs)
  // Total of 128 OPs per loop iteration, ILP = 1
  size_t n_iterations = N_ITERATIONS;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.b                                                  \n"
    "1:                                                          \n"
    "  mla z0.b, p0/m, z0.b, z0.b                                \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*1.0*(double)n_iterations;
}


static double mla_i8_i8_ilp2(const void*) {
  // MLA (I8, one vector), Multiply-Accumulate (integer)
  //
  // Each instruction: (64x i8, 64x i8) → 64x i8 (128 OPs)
  // Total of 256 OPs per loop iteration, ILP = 2
  size_t n_iterations = N_ITERATIONS/2;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.b                                                  \n"
    "1:                                                          \n"
    "  mla z0.b, p0/m, z0.b, z0.b                                \n"
    "  mla z1.b, p0/m, z1.b, z1.b                                \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*2.0*(double)n_iterations;
}


static double mla_i8_i8_ilp3(const void*) {
  // MLA (I8, one vector), Multiply-Accumulate (integer)
  //
  // Each instruction: (64x i8, 64x i8) → 64x i8 (128 OPs)
  // Total of 384 OPs per loop iteration, ILP = 3
  size_t n_iterations = N_ITERATIONS/3;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.b                                                  \n"
    "1:                                                          \n"
    "  mla z0.b, p0/m, z0.b, z0.b                                \n"
    "  mla z1.b, p0/m, z1.b, z1.b                                \n"
    "  mla z2.b, p0/m, z2.b, z2.b                                \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*3.0*(double)n_iterations;
}


static double mla_i8_i8_ilp4(const void*) {
  // MLA (I8, one vector), Multiply-Accumulate (integer)
  //
  // Each instruction: (64x i8, 64x i8) → 64x i8 (128 OPs)
  // Total of 512 OPs per loop iteration, ILP = 4
  size_t n_iterations = N_ITERATIONS/4;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.b                                                  \n"
    "1:                                                          \n"
    "  mla z0.b, p0/m, z0.b, z0.b                                \n"
    "  mla z1.b, p0/m, z1.b, z1.b                                \n"
    "  mla z2.b, p0/m, z2.b, z2.b                                \n"
    "  mla z3.b, p0/m, z3.b, z3.b                                \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*4.0*(double)n_iterations;
}


static double mla_i8_i8_ilp5(const void*) {
  // MLA (I8, one vector), Multiply-Accumulate (integer)
  //
  // Each instruction: (64x i8, 64x i8) → 64x i8 (128 OPs)
  // Total of 640 OPs per loop iteration, ILP = 5
  size_t n_iterations = N_ITERATIONS/5;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.b                                                  \n"
    "1:                                                          \n"
    "  mla z0.b, p0/m, z0.b, z0.b                                \n"
    "  mla z1.b, p0/m, z1.b, z1.b                                \n"
    "  mla z2.b, p0/m, z2.b, z2.b                                \n"
    "  mla z3.b, p0/m, z3.b, z3.b                                \n"
    "  mla z4.b, p0/m, z4.b, z4.b                                \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*5.0*(double)n_iterations;
}


static double mla_i8_i8_ilp6(const void*) {
  // MLA (I8, one vector), Multiply-Accumulate (integer)
  //
  // Each instruction: (64x i8, 64x i8) → 64x i8 (128 OPs)
  // Total of 768 OPs per loop iteration, ILP = 6
  size_t n_iterations = N_ITERATIONS/6;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.b                                                  \n"
    "1:                                                          \n"
    "  mla z0.b, p0/m, z0.b, z0.b                                \n"
    "  mla z1.b, p0/m, z1.b, z1.b                                \n"
    "  mla z2.b, p0/m, z2.b, z2.b                                \n"
    "  mla z3.b, p0/m, z3.b, z3.b                                \n"
    "  mla z4.b, p0/m, z4.b, z4.b                                \n"
    "  mla z5.b, p0/m, z5.b, z5.b                                \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*6.0*(double)n_iterations;
}


static double mla_i8_i8_ilp7(const void*) {
  // MLA (I8, one vector), Multiply-Accumulate (integer)
  //
  // Each instruction: (64x i8, 64x i8) → 64x i8 (128 OPs)
  // Total of 896 OPs per loop iteration, ILP = 7
  size_t n_iterations = N_ITERATIONS/7;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.b                                                  \n"
    "1:                                                          \n"
    "  mla z0.b, p0/m, z0.b, z0.b                                \n"
    "  mla z1.b, p0/m, z1.b, z1.b                                \n"
    "  mla z2.b, p0/m, z2.b, z2.b                                \n"
    "  mla z3.b, p0/m, z3.b, z3.b                                \n"
    "  mla z4.b, p0/m, z4.b, z4.b                                \n"
    "  mla z5.b, p0/m, z5.b, z5.b                                \n"
    "  mla z6.b, p0/m, z6.b, z6.b                                \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*7.0*(double)n_iterations;
}


static double mla_i8_i8_ilp8(const void*) {
  // MLA (I8, one vector), Multiply-Accumulate (integer)
  //
  // Each instruction: (64x i8, 64x i8) → 64x i8 (128 OPs)
  // Total of 1024 OPs per loop iteration, ILP = 8
  size_t n_iterations = N_ITERATIONS/8;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.b                                                  \n"
    "1:                                                          \n"
    "  mla z0.b, p0/m, z0.b, z0.b                                \n"
    "  mla z1.b, p0/m, z1.b, z1.b                                \n"
    "  mla z2.b, p0/m, z2.b, z2.b                                \n"
    "  mla z3.b, p0/m, z3.b, z3.b                                \n"
    "  mla z4.b, p0/m, z4.b, z4.b                                \n"
    "  mla z5.b, p0/m, z5.b, z5.b                                \n"
    "  mla z6.b, p0/m, z6.b, z6.b                                \n"
    "  mla z7.b, p0/m, z7.b, z7.b                                \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*8.0*(double)n_iterations;
}


static double mla_i8_i8_ilp9(const void*) {
  // MLA (I8, one vector), Multiply-Accumulate (integer)
  //
  // Each instruction: (64x i8, 64x i8) → 64x i8 (128 OPs)
  // Total of 1152 OPs per loop iteration, ILP = 9
  size_t n_iterations = N_ITERATIONS/9;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.b                                                  \n"
    "1:                                                          \n"
    "  mla z0.b, p0/m, z0.b, z0.b                                \n"
    "  mla z1.b, p0/m, z1.b, z1.b                                \n"
    "  mla z2.b, p0/m, z2.b, z2.b                                \n"
    "  mla z3.b, p0/m, z3.b, z3.b                                \n"
    "  mla z4.b, p0/m, z4.b, z4.b                                \n"
    "  mla z5.b, p0/m, z5.b, z5.b                                \n"
    "  mla z6.b, p0/m, z6.b, z6.b                                \n"
    "  mla z7.b, p0/m, z7.b, z7.b                                \n"
    "  mla z8.b, p0/m, z8.b, z8.b                                \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*9.0*(double)n_iterations;
}


static double mla_i8_i8_ilp10(const void*) {
  // MLA (I8, one vector), Multiply-Accumulate (integer)
  //
  // Each instruction: (64x i8, 64x i8) → 64x i8 (128 OPs)
  // Total of 1280 OPs per loop iteration, ILP = 10
  size_t n_iterations = N_ITERATIONS/10;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.b                                                  \n"
    "1:                                                          \n"
    "  mla z0.b, p0/m, z0.b, z0.b                                \n"
    "  mla z1.b, p0/m, z1.b, z1.b                                \n"
    "  mla z2.b, p0/m, z2.b, z2.b                                \n"
    "  mla z3.b, p0/m, z3.b, z3.b                                \n"
    "  mla z4.b, p0/m, z4.b, z4.b                                \n"
    "  mla z5.b, p0/m, z5.b, z5.b                                \n"
    "  mla z6.b, p0/m, z6.b, z6.b                                \n"
    "  mla z7.b, p0/m, z7.b, z7.b                                \n"
    "  mla z8.b, p0/m, z8.b, z8.b                                \n"
    "  mla z9.b, p0/m, z9.b, z9.b                                \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*10.0*(double)n_iterations;
}


static double mla_i8_i8_ilp11(const void*) {
  // MLA (I8, one vector), Multiply-Accumulate (integer)
  //
  // Each instruction: (64x i8, 64x i8) → 64x i8 (128 OPs)
  // Total of 1408 OPs per loop iteration, ILP = 11
  size_t n_iterations = N_ITERATIONS/11;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.b                                                  \n"
    "1:                                                          \n"
    "  mla z0.b, p0/m, z0.b, z0.b                                \n"
    "  mla z1.b, p0/m, z1.b, z1.b                                \n"
    "  mla z2.b, p0/m, z2.b, z2.b                                \n"
    "  mla z3.b, p0/m, z3.b, z3.b                                \n"
    "  mla z4.b, p0/m, z4.b, z4.b                                \n"
    "  mla z5.b, p0/m, z5.b, z5.b                                \n"
    "  mla z6.b, p0/m, z6.b, z6.b                                \n"
    "  mla z7.b, p0/m, z7.b, z7.b                                \n"
    "  mla z8.b, p0/m, z8.b, z8.b                                \n"
    "  mla z9.b, p0/m, z9.b, z9.b                                \n"
    "  mla z10.b, p0/m, z10.b, z10.b                             \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*11.0*(double)n_iterations;
}


static double mla_i8_i8_ilp12(const void*) {
  // MLA (I8, one vector), Multiply-Accumulate (integer)
  //
  // Each instruction: (64x i8, 64x i8) → 64x i8 (128 OPs)
  // Total of 1536 OPs per loop iteration, ILP = 12
  size_t n_iterations = N_ITERATIONS/12;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.b                                                  \n"
    "1:                                                          \n"
    "  mla z0.b, p0/m, z0.b, z0.b                                \n"
    "  mla z1.b, p0/m, z1.b, z1.b                                \n"
    "  mla z2.b, p0/m, z2.b, z2.b                                \n"
    "  mla z3.b, p0/m, z3.b, z3.b                                \n"
    "  mla z4.b, p0/m, z4.b, z4.b                                \n"
    "  mla z5.b, p0/m, z5.b, z5.b                                \n"
    "  mla z6.b, p0/m, z6.b, z6.b                                \n"
    "  mla z7.b, p0/m, z7.b, z7.b                                \n"
    "  mla z8.b, p0/m, z8.b, z8.b                                \n"
    "  mla z9.b, p0/m, z9.b, z9.b                                \n"
    "  mla z10.b, p0/m, z10.b, z10.b                             \n"
    "  mla z11.b, p0/m, z11.b, z11.b                             \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*12.0*(double)n_iterations;
}


static double mla_i8_i8_ilp13(const void*) {
  // MLA (I8, one vector), Multiply-Accumulate (integer)
  //
  // Each instruction: (64x i8, 64x i8) → 64x i8 (128 OPs)
  // Total of 1664 OPs per loop iteration, ILP = 13
  size_t n_iterations = N_ITERATIONS/13;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.b                                                  \n"
    "1:                                                          \n"
    "  mla z0.b, p0/m, z0.b, z0.b                                \n"
    "  mla z1.b, p0/m, z1.b, z1.b                                \n"
    "  mla z2.b, p0/m, z2.b, z2.b                                \n"
    "  mla z3.b, p0/m, z3.b, z3.b                                \n"
    "  mla z4.b, p0/m, z4.b, z4.b                                \n"
    "  mla z5.b, p0/m, z5.b, z5.b                                \n"
    "  mla z6.b, p0/m, z6.b, z6.b                                \n"
    "  mla z7.b, p0/m, z7.b, z7.b                                \n"
    "  mla z8.b, p0/m, z8.b, z8.b                                \n"
    "  mla z9.b, p0/m, z9.b, z9.b                                \n"
    "  mla z10.b, p0/m, z10.b, z10.b                             \n"
    "  mla z11.b, p0/m, z11.b, z11.b                             \n"
    "  mla z12.b, p0/m, z12.b, z12.b                             \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*13.0*(double)n_iterations;
}


static double mla_i8_i8_ilp14(const void*) {
  // MLA (I8, one vector), Multiply-Accumulate (integer)
  //
  // Each instruction: (64x i8, 64x i8) → 64x i8 (128 OPs)
  // Total of 1792 OPs per loop iteration, ILP = 14
  size_t n_iterations = N_ITERATIONS/14;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.b                                                  \n"
    "1:                                                          \n"
    "  mla z0.b, p0/m, z0.b, z0.b                                \n"
    "  mla z1.b, p0/m, z1.b, z1.b                                \n"
    "  mla z2.b, p0/m, z2.b, z2.b                                \n"
    "  mla z3.b, p0/m, z3.b, z3.b                                \n"
    "  mla z4.b, p0/m, z4.b, z4.b                                \n"
    "  mla z5.b, p0/m, z5.b, z5.b                                \n"
    "  mla z6.b, p0/m, z6.b, z6.b                                \n"
    "  mla z7.b, p0/m, z7.b, z7.b                                \n"
    "  mla z8.b, p0/m, z8.b, z8.b                                \n"
    "  mla z9.b, p0/m, z9.b, z9.b                                \n"
    "  mla z10.b, p0/m, z10.b, z10.b                             \n"
    "  mla z11.b, p0/m, z11.b, z11.b                             \n"
    "  mla z12.b, p0/m, z12.b, z12.b                             \n"
    "  mla z13.b, p0/m, z13.b, z13.b                             \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*14.0*(double)n_iterations;
}


static double mla_i8_i8_ilp15(const void*) {
  // MLA (I8, one vector), Multiply-Accumulate (integer)
  //
  // Each instruction: (64x i8, 64x i8) → 64x i8 (128 OPs)
  // Total of 1920 OPs per loop iteration, ILP = 15
  size_t n_iterations = N_ITERATIONS/15;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.b                                                  \n"
    "1:                                                          \n"
    "  mla z0.b, p0/m, z0.b, z0.b                                \n"
    "  mla z1.b, p0/m, z1.b, z1.b                                \n"
    "  mla z2.b, p0/m, z2.b, z2.b                                \n"
    "  mla z3.b, p0/m, z3.b, z3.b                                \n"
    "  mla z4.b, p0/m, z4.b, z4.b                                \n"
    "  mla z5.b, p0/m, z5.b, z5.b                                \n"
    "  mla z6.b, p0/m, z6.b, z6.b                                \n"
    "  mla z7.b, p0/m, z7.b, z7.b                                \n"
    "  mla z8.b, p0/m, z8.b, z8.b                                \n"
    "  mla z9.b, p0/m, z9.b, z9.b                                \n"
    "  mla z10.b, p0/m, z10.b, z10.b                             \n"
    "  mla z11.b, p0/m, z11.b, z11.b                             \n"
    "  mla z12.b, p0/m, z12.b, z12.b                             \n"
    "  mla z13.b, p0/m, z13.b, z13.b                             \n"
    "  mla z14.b, p0/m, z14.b, z14.b                             \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*15.0*(double)n_iterations;
}


static double mla_i8_i8_ilp16(const void*) {
  // MLA (I8, one vector), Multiply-Accumulate (integer)
  //
  // Each instruction: (64x i8, 64x i8) → 64x i8 (128 OPs)
  // Total of 2048 OPs per loop iteration, ILP = 16
  size_t n_iterations = N_ITERATIONS/16;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.b                                                  \n"
    "1:                                                          \n"
    "  mla z0.b, p0/m, z0.b, z0.b                                \n"
    "  mla z1.b, p0/m, z1.b, z1.b                                \n"
    "  mla z2.b, p0/m, z2.b, z2.b                                \n"
    "  mla z3.b, p0/m, z3.b, z3.b                                \n"
    "  mla z4.b, p0/m, z4.b, z4.b                                \n"
    "  mla z5.b, p0/m, z5.b, z5.b                                \n"
    "  mla z6.b, p0/m, z6.b, z6.b                                \n"
    "  mla z7.b, p0/m, z7.b, z7.b                                \n"
    "  mla z8.b, p0/m, z8.b, z8.b                                \n"
    "  mla z9.b, p0/m, z9.b, z9.b                                \n"
    "  mla z10.b, p0/m, z10.b, z10.b                             \n"
    "  mla z11.b, p0/m, z11.b, z11.b                             \n"
    "  mla z12.b, p0/m, z12.b, z12.b                             \n"
    "  mla z13.b, p0/m, z13.b, z13.b                             \n"
    "  mla z14.b, p0/m, z14.b, z14.b                             \n"
    "  mla z15.b, p0/m, z15.b, z15.b                             \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*16.0*(double)n_iterations;
}


static double mla_i16_i16_ilp1(const void*) {
  // MLA (I16, one vector), Multiply-Accumulate (integer)
  //
  // Each instruction: (32x i16, 32x i16) → 32x i16 (64 OPs)
  // Total of 64 OPs per loop iteration, ILP = 1
  size_t n_iterations = N_ITERATIONS;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.h                                                  \n"
    "1:                                                          \n"
    "  mla z0.h, p0/m, z0.h, z0.h                                \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*1.0*(double)n_iterations;
}


static double mla_i16_i16_ilp2(const void*) {
  // MLA (I16, one vector), Multiply-Accumulate (integer)
  //
  // Each instruction: (32x i16, 32x i16) → 32x i16 (64 OPs)
  // Total of 128 OPs per loop iteration, ILP = 2
  size_t n_iterations = N_ITERATIONS/2;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.h                                                  \n"
    "1:                                                          \n"
    "  mla z0.h, p0/m, z0.h, z0.h                                \n"
    "  mla z1.h, p0/m, z1.h, z1.h                                \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*2.0*(double)n_iterations;
}


static double mla_i16_i16_ilp3(const void*) {
  // MLA (I16, one vector), Multiply-Accumulate (integer)
  //
  // Each instruction: (32x i16, 32x i16) → 32x i16 (64 OPs)
  // Total of 192 OPs per loop iteration, ILP = 3
  size_t n_iterations = N_ITERATIONS/3;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.h                                                  \n"
    "1:                                                          \n"
    "  mla z0.h, p0/m, z0.h, z0.h                                \n"
    "  mla z1.h, p0/m, z1.h, z1.h                                \n"
    "  mla z2.h, p0/m, z2.h, z2.h                                \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*3.0*(double)n_iterations;
}


static double mla_i16_i16_ilp4(const void*) {
  // MLA (I16, one vector), Multiply-Accumulate (integer)
  //
  // Each instruction: (32x i16, 32x i16) → 32x i16 (64 OPs)
  // Total of 256 OPs per loop iteration, ILP = 4
  size_t n_iterations = N_ITERATIONS/4;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.h                                                  \n"
    "1:                                                          \n"
    "  mla z0.h, p0/m, z0.h, z0.h                                \n"
    "  mla z1.h, p0/m, z1.h, z1.h                                \n"
    "  mla z2.h, p0/m, z2.h, z2.h                                \n"
    "  mla z3.h, p0/m, z3.h, z3.h                                \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*4.0*(double)n_iterations;
}


static double mla_i16_i16_ilp5(const void*) {
  // MLA (I16, one vector), Multiply-Accumulate (integer)
  //
  // Each instruction: (32x i16, 32x i16) → 32x i16 (64 OPs)
  // Total of 320 OPs per loop iteration, ILP = 5
  size_t n_iterations = N_ITERATIONS/5;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.h                                                  \n"
    "1:                                                          \n"
    "  mla z0.h, p0/m, z0.h, z0.h                                \n"
    "  mla z1.h, p0/m, z1.h, z1.h                                \n"
    "  mla z2.h, p0/m, z2.h, z2.h                                \n"
    "  mla z3.h, p0/m, z3.h, z3.h                                \n"
    "  mla z4.h, p0/m, z4.h, z4.h                                \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*5.0*(double)n_iterations;
}


static double mla_i16_i16_ilp6(const void*) {
  // MLA (I16, one vector), Multiply-Accumulate (integer)
  //
  // Each instruction: (32x i16, 32x i16) → 32x i16 (64 OPs)
  // Total of 384 OPs per loop iteration, ILP = 6
  size_t n_iterations = N_ITERATIONS/6;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.h                                                  \n"
    "1:                                                          \n"
    "  mla z0.h, p0/m, z0.h, z0.h                                \n"
    "  mla z1.h, p0/m, z1.h, z1.h                                \n"
    "  mla z2.h, p0/m, z2.h, z2.h                                \n"
    "  mla z3.h, p0/m, z3.h, z3.h                                \n"
    "  mla z4.h, p0/m, z4.h, z4.h                                \n"
    "  mla z5.h, p0/m, z5.h, z5.h                                \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*6.0*(double)n_iterations;
}


static double mla_i16_i16_ilp7(const void*) {
  // MLA (I16, one vector), Multiply-Accumulate (integer)
  //
  // Each instruction: (32x i16, 32x i16) → 32x i16 (64 OPs)
  // Total of 448 OPs per loop iteration, ILP = 7
  size_t n_iterations = N_ITERATIONS/7;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.h                                                  \n"
    "1:                                                          \n"
    "  mla z0.h, p0/m, z0.h, z0.h                                \n"
    "  mla z1.h, p0/m, z1.h, z1.h                                \n"
    "  mla z2.h, p0/m, z2.h, z2.h                                \n"
    "  mla z3.h, p0/m, z3.h, z3.h                                \n"
    "  mla z4.h, p0/m, z4.h, z4.h                                \n"
    "  mla z5.h, p0/m, z5.h, z5.h                                \n"
    "  mla z6.h, p0/m, z6.h, z6.h                                \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*7.0*(double)n_iterations;
}


static double mla_i16_i16_ilp8(const void*) {
  // MLA (I16, one vector), Multiply-Accumulate (integer)
  //
  // Each instruction: (32x i16, 32x i16) → 32x i16 (64 OPs)
  // Total of 512 OPs per loop iteration, ILP = 8
  size_t n_iterations = N_ITERATIONS/8;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.h                                                  \n"
    "1:                                                          \n"
    "  mla z0.h, p0/m, z0.h, z0.h                                \n"
    "  mla z1.h, p0/m, z1.h, z1.h                                \n"
    "  mla z2.h, p0/m, z2.h, z2.h                                \n"
    "  mla z3.h, p0/m, z3.h, z3.h                                \n"
    "  mla z4.h, p0/m, z4.h, z4.h                                \n"
    "  mla z5.h, p0/m, z5.h, z5.h                                \n"
    "  mla z6.h, p0/m, z6.h, z6.h                                \n"
    "  mla z7.h, p0/m, z7.h, z7.h                                \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*8.0*(double)n_iterations;
}


static double mla_i16_i16_ilp9(const void*) {
  // MLA (I16, one vector), Multiply-Accumulate (integer)
  //
  // Each instruction: (32x i16, 32x i16) → 32x i16 (64 OPs)
  // Total of 576 OPs per loop iteration, ILP = 9
  size_t n_iterations = N_ITERATIONS/9;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.h                                                  \n"
    "1:                                                          \n"
    "  mla z0.h, p0/m, z0.h, z0.h                                \n"
    "  mla z1.h, p0/m, z1.h, z1.h                                \n"
    "  mla z2.h, p0/m, z2.h, z2.h                                \n"
    "  mla z3.h, p0/m, z3.h, z3.h                                \n"
    "  mla z4.h, p0/m, z4.h, z4.h                                \n"
    "  mla z5.h, p0/m, z5.h, z5.h                                \n"
    "  mla z6.h, p0/m, z6.h, z6.h                                \n"
    "  mla z7.h, p0/m, z7.h, z7.h                                \n"
    "  mla z8.h, p0/m, z8.h, z8.h                                \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*9.0*(double)n_iterations;
}


static double mla_i16_i16_ilp10(const void*) {
  // MLA (I16, one vector), Multiply-Accumulate (integer)
  //
  // Each instruction: (32x i16, 32x i16) → 32x i16 (64 OPs)
  // Total of 640 OPs per loop iteration, ILP = 10
  size_t n_iterations = N_ITERATIONS/10;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.h                                                  \n"
    "1:                                                          \n"
    "  mla z0.h, p0/m, z0.h, z0.h                                \n"
    "  mla z1.h, p0/m, z1.h, z1.h                                \n"
    "  mla z2.h, p0/m, z2.h, z2.h                                \n"
    "  mla z3.h, p0/m, z3.h, z3.h                                \n"
    "  mla z4.h, p0/m, z4.h, z4.h                                \n"
    "  mla z5.h, p0/m, z5.h, z5.h                                \n"
    "  mla z6.h, p0/m, z6.h, z6.h                                \n"
    "  mla z7.h, p0/m, z7.h, z7.h                                \n"
    "  mla z8.h, p0/m, z8.h, z8.h                                \n"
    "  mla z9.h, p0/m, z9.h, z9.h                                \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*10.0*(double)n_iterations;
}


static double mla_i16_i16_ilp11(const void*) {
  // MLA (I16, one vector), Multiply-Accumulate (integer)
  //
  // Each instruction: (32x i16, 32x i16) → 32x i16 (64 OPs)
  // Total of 704 OPs per loop iteration, ILP = 11
  size_t n_iterations = N_ITERATIONS/11;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.h                                                  \n"
    "1:                                                          \n"
    "  mla z0.h, p0/m, z0.h, z0.h                                \n"
    "  mla z1.h, p0/m, z1.h, z1.h                                \n"
    "  mla z2.h, p0/m, z2.h, z2.h                                \n"
    "  mla z3.h, p0/m, z3.h, z3.h                                \n"
    "  mla z4.h, p0/m, z4.h, z4.h                                \n"
    "  mla z5.h, p0/m, z5.h, z5.h                                \n"
    "  mla z6.h, p0/m, z6.h, z6.h                                \n"
    "  mla z7.h, p0/m, z7.h, z7.h                                \n"
    "  mla z8.h, p0/m, z8.h, z8.h                                \n"
    "  mla z9.h, p0/m, z9.h, z9.h                                \n"
    "  mla z10.h, p0/m, z10.h, z10.h                             \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*11.0*(double)n_iterations;
}


static double mla_i16_i16_ilp12(const void*) {
  // MLA (I16, one vector), Multiply-Accumulate (integer)
  //
  // Each instruction: (32x i16, 32x i16) → 32x i16 (64 OPs)
  // Total of 768 OPs per loop iteration, ILP = 12
  size_t n_iterations = N_ITERATIONS/12;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.h                                                  \n"
    "1:                                                          \n"
    "  mla z0.h, p0/m, z0.h, z0.h                                \n"
    "  mla z1.h, p0/m, z1.h, z1.h                                \n"
    "  mla z2.h, p0/m, z2.h, z2.h                                \n"
    "  mla z3.h, p0/m, z3.h, z3.h                                \n"
    "  mla z4.h, p0/m, z4.h, z4.h                                \n"
    "  mla z5.h, p0/m, z5.h, z5.h                                \n"
    "  mla z6.h, p0/m, z6.h, z6.h                                \n"
    "  mla z7.h, p0/m, z7.h, z7.h                                \n"
    "  mla z8.h, p0/m, z8.h, z8.h                                \n"
    "  mla z9.h, p0/m, z9.h, z9.h                                \n"
    "  mla z10.h, p0/m, z10.h, z10.h                             \n"
    "  mla z11.h, p0/m, z11.h, z11.h                             \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*12.0*(double)n_iterations;
}


static double mla_i16_i16_ilp13(const void*) {
  // MLA (I16, one vector), Multiply-Accumulate (integer)
  //
  // Each instruction: (32x i16, 32x i16) → 32x i16 (64 OPs)
  // Total of 832 OPs per loop iteration, ILP = 13
  size_t n_iterations = N_ITERATIONS/13;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.h                                                  \n"
    "1:                                                          \n"
    "  mla z0.h, p0/m, z0.h, z0.h                                \n"
    "  mla z1.h, p0/m, z1.h, z1.h                                \n"
    "  mla z2.h, p0/m, z2.h, z2.h                                \n"
    "  mla z3.h, p0/m, z3.h, z3.h                                \n"
    "  mla z4.h, p0/m, z4.h, z4.h                                \n"
    "  mla z5.h, p0/m, z5.h, z5.h                                \n"
    "  mla z6.h, p0/m, z6.h, z6.h                                \n"
    "  mla z7.h, p0/m, z7.h, z7.h                                \n"
    "  mla z8.h, p0/m, z8.h, z8.h                                \n"
    "  mla z9.h, p0/m, z9.h, z9.h                                \n"
    "  mla z10.h, p0/m, z10.h, z10.h                             \n"
    "  mla z11.h, p0/m, z11.h, z11.h                             \n"
    "  mla z12.h, p0/m, z12.h, z12.h                             \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*13.0*(double)n_iterations;
}


static double mla_i16_i16_ilp14(const void*) {
  // MLA (I16, one vector), Multiply-Accumulate (integer)
  //
  // Each instruction: (32x i16, 32x i16) → 32x i16 (64 OPs)
  // Total of 896 OPs per loop iteration, ILP = 14
  size_t n_iterations = N_ITERATIONS/14;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.h                                                  \n"
    "1:                                                          \n"
    "  mla z0.h, p0/m, z0.h, z0.h                                \n"
    "  mla z1.h, p0/m, z1.h, z1.h                                \n"
    "  mla z2.h, p0/m, z2.h, z2.h                                \n"
    "  mla z3.h, p0/m, z3.h, z3.h                                \n"
    "  mla z4.h, p0/m, z4.h, z4.h                                \n"
    "  mla z5.h, p0/m, z5.h, z5.h                                \n"
    "  mla z6.h, p0/m, z6.h, z6.h                                \n"
    "  mla z7.h, p0/m, z7.h, z7.h                                \n"
    "  mla z8.h, p0/m, z8.h, z8.h                                \n"
    "  mla z9.h, p0/m, z9.h, z9.h                                \n"
    "  mla z10.h, p0/m, z10.h, z10.h                             \n"
    "  mla z11.h, p0/m, z11.h, z11.h                             \n"
    "  mla z12.h, p0/m, z12.h, z12.h                             \n"
    "  mla z13.h, p0/m, z13.h, z13.h                             \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*14.0*(double)n_iterations;
}


static double mla_i16_i16_ilp15(const void*) {
  // MLA (I16, one vector), Multiply-Accumulate (integer)
  //
  // Each instruction: (32x i16, 32x i16) → 32x i16 (64 OPs)
  // Total of 960 OPs per loop iteration, ILP = 15
  size_t n_iterations = N_ITERATIONS/15;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.h                                                  \n"
    "1:                                                          \n"
    "  mla z0.h, p0/m, z0.h, z0.h                                \n"
    "  mla z1.h, p0/m, z1.h, z1.h                                \n"
    "  mla z2.h, p0/m, z2.h, z2.h                                \n"
    "  mla z3.h, p0/m, z3.h, z3.h                                \n"
    "  mla z4.h, p0/m, z4.h, z4.h                                \n"
    "  mla z5.h, p0/m, z5.h, z5.h                                \n"
    "  mla z6.h, p0/m, z6.h, z6.h                                \n"
    "  mla z7.h, p0/m, z7.h, z7.h                                \n"
    "  mla z8.h, p0/m, z8.h, z8.h                                \n"
    "  mla z9.h, p0/m, z9.h, z9.h                                \n"
    "  mla z10.h, p0/m, z10.h, z10.h                             \n"
    "  mla z11.h, p0/m, z11.h, z11.h                             \n"
    "  mla z12.h, p0/m, z12.h, z12.h                             \n"
    "  mla z13.h, p0/m, z13.h, z13.h                             \n"
    "  mla z14.h, p0/m, z14.h, z14.h                             \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*15.0*(double)n_iterations;
}


static double mla_i16_i16_ilp16(const void*) {
  // MLA (I16, one vector), Multiply-Accumulate (integer)
  //
  // Each instruction: (32x i16, 32x i16) → 32x i16 (64 OPs)
  // Total of 1024 OPs per loop iteration, ILP = 16
  size_t n_iterations = N_ITERATIONS/16;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.h                                                  \n"
    "1:                                                          \n"
    "  mla z0.h, p0/m, z0.h, z0.h                                \n"
    "  mla z1.h, p0/m, z1.h, z1.h                                \n"
    "  mla z2.h, p0/m, z2.h, z2.h                                \n"
    "  mla z3.h, p0/m, z3.h, z3.h                                \n"
    "  mla z4.h, p0/m, z4.h, z4.h                                \n"
    "  mla z5.h, p0/m, z5.h, z5.h                                \n"
    "  mla z6.h, p0/m, z6.h, z6.h                                \n"
    "  mla z7.h, p0/m, z7.h, z7.h                                \n"
    "  mla z8.h, p0/m, z8.h, z8.h                                \n"
    "  mla z9.h, p0/m, z9.h, z9.h                                \n"
    "  mla z10.h, p0/m, z10.h, z10.h                             \n"
    "  mla z11.h, p0/m, z11.h, z11.h                             \n"
    "  mla z12.h, p0/m, z12.h, z12.h                             \n"
    "  mla z13.h, p0/m, z13.h, z13.h                             \n"
    "  mla z14.h, p0/m, z14.h, z14.h                             \n"
    "  mla z15.h, p0/m, z15.h, z15.h                             \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 64.0*16.0*(double)n_iterations;
}


static double mla_i32_i32_ilp1(const void*) {
  // MLA (I32, one vector), Multiply-Accumulate (integer)
  //
  // Each instruction: (16x i32, 16x i32) → 16x i32 (32 OPs)
  // Total of 32 OPs per loop iteration, ILP = 1
  size_t n_iterations = N_ITERATIONS;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.s                                                  \n"
    "1:                                                          \n"
    "  mla z0.s, p0/m, z0.s, z0.s                                \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 32.0*1.0*(double)n_iterations;
}


static double mla_i32_i32_ilp2(const void*) {
  // MLA (I32, one vector), Multiply-Accumulate (integer)
  //
  // Each instruction: (16x i32, 16x i32) → 16x i32 (32 OPs)
  // Total of 64 OPs per loop iteration, ILP = 2
  size_t n_iterations = N_ITERATIONS/2;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.s                                                  \n"
    "1:                                                          \n"
    "  mla z0.s, p0/m, z0.s, z0.s                                \n"
    "  mla z1.s, p0/m, z1.s, z1.s                                \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 32.0*2.0*(double)n_iterations;
}


static double mla_i32_i32_ilp3(const void*) {
  // MLA (I32, one vector), Multiply-Accumulate (integer)
  //
  // Each instruction: (16x i32, 16x i32) → 16x i32 (32 OPs)
  // Total of 96 OPs per loop iteration, ILP = 3
  size_t n_iterations = N_ITERATIONS/3;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.s                                                  \n"
    "1:                                                          \n"
    "  mla z0.s, p0/m, z0.s, z0.s                                \n"
    "  mla z1.s, p0/m, z1.s, z1.s                                \n"
    "  mla z2.s, p0/m, z2.s, z2.s                                \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 32.0*3.0*(double)n_iterations;
}


static double mla_i32_i32_ilp4(const void*) {
  // MLA (I32, one vector), Multiply-Accumulate (integer)
  //
  // Each instruction: (16x i32, 16x i32) → 16x i32 (32 OPs)
  // Total of 128 OPs per loop iteration, ILP = 4
  size_t n_iterations = N_ITERATIONS/4;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.s                                                  \n"
    "1:                                                          \n"
    "  mla z0.s, p0/m, z0.s, z0.s                                \n"
    "  mla z1.s, p0/m, z1.s, z1.s                                \n"
    "  mla z2.s, p0/m, z2.s, z2.s                                \n"
    "  mla z3.s, p0/m, z3.s, z3.s                                \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 32.0*4.0*(double)n_iterations;
}


static double mla_i32_i32_ilp5(const void*) {
  // MLA (I32, one vector), Multiply-Accumulate (integer)
  //
  // Each instruction: (16x i32, 16x i32) → 16x i32 (32 OPs)
  // Total of 160 OPs per loop iteration, ILP = 5
  size_t n_iterations = N_ITERATIONS/5;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.s                                                  \n"
    "1:                                                          \n"
    "  mla z0.s, p0/m, z0.s, z0.s                                \n"
    "  mla z1.s, p0/m, z1.s, z1.s                                \n"
    "  mla z2.s, p0/m, z2.s, z2.s                                \n"
    "  mla z3.s, p0/m, z3.s, z3.s                                \n"
    "  mla z4.s, p0/m, z4.s, z4.s                                \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 32.0*5.0*(double)n_iterations;
}


static double mla_i32_i32_ilp6(const void*) {
  // MLA (I32, one vector), Multiply-Accumulate (integer)
  //
  // Each instruction: (16x i32, 16x i32) → 16x i32 (32 OPs)
  // Total of 192 OPs per loop iteration, ILP = 6
  size_t n_iterations = N_ITERATIONS/6;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.s                                                  \n"
    "1:                                                          \n"
    "  mla z0.s, p0/m, z0.s, z0.s                                \n"
    "  mla z1.s, p0/m, z1.s, z1.s                                \n"
    "  mla z2.s, p0/m, z2.s, z2.s                                \n"
    "  mla z3.s, p0/m, z3.s, z3.s                                \n"
    "  mla z4.s, p0/m, z4.s, z4.s                                \n"
    "  mla z5.s, p0/m, z5.s, z5.s                                \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 32.0*6.0*(double)n_iterations;
}


static double mla_i32_i32_ilp7(const void*) {
  // MLA (I32, one vector), Multiply-Accumulate (integer)
  //
  // Each instruction: (16x i32, 16x i32) → 16x i32 (32 OPs)
  // Total of 224 OPs per loop iteration, ILP = 7
  size_t n_iterations = N_ITERATIONS/7;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.s                                                  \n"
    "1:                                                          \n"
    "  mla z0.s, p0/m, z0.s, z0.s                                \n"
    "  mla z1.s, p0/m, z1.s, z1.s                                \n"
    "  mla z2.s, p0/m, z2.s, z2.s                                \n"
    "  mla z3.s, p0/m, z3.s, z3.s                                \n"
    "  mla z4.s, p0/m, z4.s, z4.s                                \n"
    "  mla z5.s, p0/m, z5.s, z5.s                                \n"
    "  mla z6.s, p0/m, z6.s, z6.s                                \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 32.0*7.0*(double)n_iterations;
}


static double mla_i32_i32_ilp8(const void*) {
  // MLA (I32, one vector), Multiply-Accumulate (integer)
  //
  // Each instruction: (16x i32, 16x i32) → 16x i32 (32 OPs)
  // Total of 256 OPs per loop iteration, ILP = 8
  size_t n_iterations = N_ITERATIONS/8;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.s                                                  \n"
    "1:                                                          \n"
    "  mla z0.s, p0/m, z0.s, z0.s                                \n"
    "  mla z1.s, p0/m, z1.s, z1.s                                \n"
    "  mla z2.s, p0/m, z2.s, z2.s                                \n"
    "  mla z3.s, p0/m, z3.s, z3.s                                \n"
    "  mla z4.s, p0/m, z4.s, z4.s                                \n"
    "  mla z5.s, p0/m, z5.s, z5.s                                \n"
    "  mla z6.s, p0/m, z6.s, z6.s                                \n"
    "  mla z7.s, p0/m, z7.s, z7.s                                \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 32.0*8.0*(double)n_iterations;
}


static double mla_i32_i32_ilp9(const void*) {
  // MLA (I32, one vector), Multiply-Accumulate (integer)
  //
  // Each instruction: (16x i32, 16x i32) → 16x i32 (32 OPs)
  // Total of 288 OPs per loop iteration, ILP = 9
  size_t n_iterations = N_ITERATIONS/9;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.s                                                  \n"
    "1:                                                          \n"
    "  mla z0.s, p0/m, z0.s, z0.s                                \n"
    "  mla z1.s, p0/m, z1.s, z1.s                                \n"
    "  mla z2.s, p0/m, z2.s, z2.s                                \n"
    "  mla z3.s, p0/m, z3.s, z3.s                                \n"
    "  mla z4.s, p0/m, z4.s, z4.s                                \n"
    "  mla z5.s, p0/m, z5.s, z5.s                                \n"
    "  mla z6.s, p0/m, z6.s, z6.s                                \n"
    "  mla z7.s, p0/m, z7.s, z7.s                                \n"
    "  mla z8.s, p0/m, z8.s, z8.s                                \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 32.0*9.0*(double)n_iterations;
}


static double mla_i32_i32_ilp10(const void*) {
  // MLA (I32, one vector), Multiply-Accumulate (integer)
  //
  // Each instruction: (16x i32, 16x i32) → 16x i32 (32 OPs)
  // Total of 320 OPs per loop iteration, ILP = 10
  size_t n_iterations = N_ITERATIONS/10;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.s                                                  \n"
    "1:                                                          \n"
    "  mla z0.s, p0/m, z0.s, z0.s                                \n"
    "  mla z1.s, p0/m, z1.s, z1.s                                \n"
    "  mla z2.s, p0/m, z2.s, z2.s                                \n"
    "  mla z3.s, p0/m, z3.s, z3.s                                \n"
    "  mla z4.s, p0/m, z4.s, z4.s                                \n"
    "  mla z5.s, p0/m, z5.s, z5.s                                \n"
    "  mla z6.s, p0/m, z6.s, z6.s                                \n"
    "  mla z7.s, p0/m, z7.s, z7.s                                \n"
    "  mla z8.s, p0/m, z8.s, z8.s                                \n"
    "  mla z9.s, p0/m, z9.s, z9.s                                \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 32.0*10.0*(double)n_iterations;
}


static double mla_i32_i32_ilp11(const void*) {
  // MLA (I32, one vector), Multiply-Accumulate (integer)
  //
  // Each instruction: (16x i32, 16x i32) → 16x i32 (32 OPs)
  // Total of 352 OPs per loop iteration, ILP = 11
  size_t n_iterations = N_ITERATIONS/11;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.s                                                  \n"
    "1:                                                          \n"
    "  mla z0.s, p0/m, z0.s, z0.s                                \n"
    "  mla z1.s, p0/m, z1.s, z1.s                                \n"
    "  mla z2.s, p0/m, z2.s, z2.s                                \n"
    "  mla z3.s, p0/m, z3.s, z3.s                                \n"
    "  mla z4.s, p0/m, z4.s, z4.s                                \n"
    "  mla z5.s, p0/m, z5.s, z5.s                                \n"
    "  mla z6.s, p0/m, z6.s, z6.s                                \n"
    "  mla z7.s, p0/m, z7.s, z7.s                                \n"
    "  mla z8.s, p0/m, z8.s, z8.s                                \n"
    "  mla z9.s, p0/m, z9.s, z9.s                                \n"
    "  mla z10.s, p0/m, z10.s, z10.s                             \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 32.0*11.0*(double)n_iterations;
}


static double mla_i32_i32_ilp12(const void*) {
  // MLA (I32, one vector), Multiply-Accumulate (integer)
  //
  // Each instruction: (16x i32, 16x i32) → 16x i32 (32 OPs)
  // Total of 384 OPs per loop iteration, ILP = 12
  size_t n_iterations = N_ITERATIONS/12;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.s                                                  \n"
    "1:                                                          \n"
    "  mla z0.s, p0/m, z0.s, z0.s                                \n"
    "  mla z1.s, p0/m, z1.s, z1.s                                \n"
    "  mla z2.s, p0/m, z2.s, z2.s                                \n"
    "  mla z3.s, p0/m, z3.s, z3.s                                \n"
    "  mla z4.s, p0/m, z4.s, z4.s                                \n"
    "  mla z5.s, p0/m, z5.s, z5.s                                \n"
    "  mla z6.s, p0/m, z6.s, z6.s                                \n"
    "  mla z7.s, p0/m, z7.s, z7.s                                \n"
    "  mla z8.s, p0/m, z8.s, z8.s                                \n"
    "  mla z9.s, p0/m, z9.s, z9.s                                \n"
    "  mla z10.s, p0/m, z10.s, z10.s                             \n"
    "  mla z11.s, p0/m, z11.s, z11.s                             \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 32.0*12.0*(double)n_iterations;
}


static double mla_i32_i32_ilp13(const void*) {
  // MLA (I32, one vector), Multiply-Accumulate (integer)
  //
  // Each instruction: (16x i32, 16x i32) → 16x i32 (32 OPs)
  // Total of 416 OPs per loop iteration, ILP = 13
  size_t n_iterations = N_ITERATIONS/13;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.s                                                  \n"
    "1:                                                          \n"
    "  mla z0.s, p0/m, z0.s, z0.s                                \n"
    "  mla z1.s, p0/m, z1.s, z1.s                                \n"
    "  mla z2.s, p0/m, z2.s, z2.s                                \n"
    "  mla z3.s, p0/m, z3.s, z3.s                                \n"
    "  mla z4.s, p0/m, z4.s, z4.s                                \n"
    "  mla z5.s, p0/m, z5.s, z5.s                                \n"
    "  mla z6.s, p0/m, z6.s, z6.s                                \n"
    "  mla z7.s, p0/m, z7.s, z7.s                                \n"
    "  mla z8.s, p0/m, z8.s, z8.s                                \n"
    "  mla z9.s, p0/m, z9.s, z9.s                                \n"
    "  mla z10.s, p0/m, z10.s, z10.s                             \n"
    "  mla z11.s, p0/m, z11.s, z11.s                             \n"
    "  mla z12.s, p0/m, z12.s, z12.s                             \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 32.0*13.0*(double)n_iterations;
}


static double mla_i32_i32_ilp14(const void*) {
  // MLA (I32, one vector), Multiply-Accumulate (integer)
  //
  // Each instruction: (16x i32, 16x i32) → 16x i32 (32 OPs)
  // Total of 448 OPs per loop iteration, ILP = 14
  size_t n_iterations = N_ITERATIONS/14;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.s                                                  \n"
    "1:                                                          \n"
    "  mla z0.s, p0/m, z0.s, z0.s                                \n"
    "  mla z1.s, p0/m, z1.s, z1.s                                \n"
    "  mla z2.s, p0/m, z2.s, z2.s                                \n"
    "  mla z3.s, p0/m, z3.s, z3.s                                \n"
    "  mla z4.s, p0/m, z4.s, z4.s                                \n"
    "  mla z5.s, p0/m, z5.s, z5.s                                \n"
    "  mla z6.s, p0/m, z6.s, z6.s                                \n"
    "  mla z7.s, p0/m, z7.s, z7.s                                \n"
    "  mla z8.s, p0/m, z8.s, z8.s                                \n"
    "  mla z9.s, p0/m, z9.s, z9.s                                \n"
    "  mla z10.s, p0/m, z10.s, z10.s                             \n"
    "  mla z11.s, p0/m, z11.s, z11.s                             \n"
    "  mla z12.s, p0/m, z12.s, z12.s                             \n"
    "  mla z13.s, p0/m, z13.s, z13.s                             \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 32.0*14.0*(double)n_iterations;
}


static double mla_i32_i32_ilp15(const void*) {
  // MLA (I32, one vector), Multiply-Accumulate (integer)
  //
  // Each instruction: (16x i32, 16x i32) → 16x i32 (32 OPs)
  // Total of 480 OPs per loop iteration, ILP = 15
  size_t n_iterations = N_ITERATIONS/15;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.s                                                  \n"
    "1:                                                          \n"
    "  mla z0.s, p0/m, z0.s, z0.s                                \n"
    "  mla z1.s, p0/m, z1.s, z1.s                                \n"
    "  mla z2.s, p0/m, z2.s, z2.s                                \n"
    "  mla z3.s, p0/m, z3.s, z3.s                                \n"
    "  mla z4.s, p0/m, z4.s, z4.s                                \n"
    "  mla z5.s, p0/m, z5.s, z5.s                                \n"
    "  mla z6.s, p0/m, z6.s, z6.s                                \n"
    "  mla z7.s, p0/m, z7.s, z7.s                                \n"
    "  mla z8.s, p0/m, z8.s, z8.s                                \n"
    "  mla z9.s, p0/m, z9.s, z9.s                                \n"
    "  mla z10.s, p0/m, z10.s, z10.s                             \n"
    "  mla z11.s, p0/m, z11.s, z11.s                             \n"
    "  mla z12.s, p0/m, z12.s, z12.s                             \n"
    "  mla z13.s, p0/m, z13.s, z13.s                             \n"
    "  mla z14.s, p0/m, z14.s, z14.s                             \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 32.0*15.0*(double)n_iterations;
}


static double mla_i32_i32_ilp16(const void*) {
  // MLA (I32, one vector), Multiply-Accumulate (integer)
  //
  // Each instruction: (16x i32, 16x i32) → 16x i32 (32 OPs)
  // Total of 512 OPs per loop iteration, ILP = 16
  size_t n_iterations = N_ITERATIONS/16;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.s                                                  \n"
    "1:                                                          \n"
    "  mla z0.s, p0/m, z0.s, z0.s                                \n"
    "  mla z1.s, p0/m, z1.s, z1.s                                \n"
    "  mla z2.s, p0/m, z2.s, z2.s                                \n"
    "  mla z3.s, p0/m, z3.s, z3.s                                \n"
    "  mla z4.s, p0/m, z4.s, z4.s                                \n"
    "  mla z5.s, p0/m, z5.s, z5.s                                \n"
    "  mla z6.s, p0/m, z6.s, z6.s                                \n"
    "  mla z7.s, p0/m, z7.s, z7.s                                \n"
    "  mla z8.s, p0/m, z8.s, z8.s                                \n"
    "  mla z9.s, p0/m, z9.s, z9.s                                \n"
    "  mla z10.s, p0/m, z10.s, z10.s                             \n"
    "  mla z11.s, p0/m, z11.s, z11.s                             \n"
    "  mla z12.s, p0/m, z12.s, z12.s                             \n"
    "  mla z13.s, p0/m, z13.s, z13.s                             \n"
    "  mla z14.s, p0/m, z14.s, z14.s                             \n"
    "  mla z15.s, p0/m, z15.s, z15.s                             \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 32.0*16.0*(double)n_iterations;
}


static double mla_i64_i64_ilp1(const void*) {
  // MLA (I64, one vector), Multiply-Accumulate (integer)
  //
  // Each instruction: (8x i64, 8x i64) → 8x i64 (16 OPs)
  // Total of 16 OPs per loop iteration, ILP = 1
  size_t n_iterations = N_ITERATIONS;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.d                                                  \n"
    "1:                                                          \n"
    "  mla z0.d, p0/m, z0.d, z0.d                                \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 16.0*1.0*(double)n_iterations;
}


static double mla_i64_i64_ilp2(const void*) {
  // MLA (I64, one vector), Multiply-Accumulate (integer)
  //
  // Each instruction: (8x i64, 8x i64) → 8x i64 (16 OPs)
  // Total of 32 OPs per loop iteration, ILP = 2
  size_t n_iterations = N_ITERATIONS/2;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.d                                                  \n"
    "1:                                                          \n"
    "  mla z0.d, p0/m, z0.d, z0.d                                \n"
    "  mla z1.d, p0/m, z1.d, z1.d                                \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 16.0*2.0*(double)n_iterations;
}


static double mla_i64_i64_ilp3(const void*) {
  // MLA (I64, one vector), Multiply-Accumulate (integer)
  //
  // Each instruction: (8x i64, 8x i64) → 8x i64 (16 OPs)
  // Total of 48 OPs per loop iteration, ILP = 3
  size_t n_iterations = N_ITERATIONS/3;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.d                                                  \n"
    "1:                                                          \n"
    "  mla z0.d, p0/m, z0.d, z0.d                                \n"
    "  mla z1.d, p0/m, z1.d, z1.d                                \n"
    "  mla z2.d, p0/m, z2.d, z2.d                                \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 16.0*3.0*(double)n_iterations;
}


static double mla_i64_i64_ilp4(const void*) {
  // MLA (I64, one vector), Multiply-Accumulate (integer)
  //
  // Each instruction: (8x i64, 8x i64) → 8x i64 (16 OPs)
  // Total of 64 OPs per loop iteration, ILP = 4
  size_t n_iterations = N_ITERATIONS/4;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.d                                                  \n"
    "1:                                                          \n"
    "  mla z0.d, p0/m, z0.d, z0.d                                \n"
    "  mla z1.d, p0/m, z1.d, z1.d                                \n"
    "  mla z2.d, p0/m, z2.d, z2.d                                \n"
    "  mla z3.d, p0/m, z3.d, z3.d                                \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 16.0*4.0*(double)n_iterations;
}


static double mla_i64_i64_ilp5(const void*) {
  // MLA (I64, one vector), Multiply-Accumulate (integer)
  //
  // Each instruction: (8x i64, 8x i64) → 8x i64 (16 OPs)
  // Total of 80 OPs per loop iteration, ILP = 5
  size_t n_iterations = N_ITERATIONS/5;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.d                                                  \n"
    "1:                                                          \n"
    "  mla z0.d, p0/m, z0.d, z0.d                                \n"
    "  mla z1.d, p0/m, z1.d, z1.d                                \n"
    "  mla z2.d, p0/m, z2.d, z2.d                                \n"
    "  mla z3.d, p0/m, z3.d, z3.d                                \n"
    "  mla z4.d, p0/m, z4.d, z4.d                                \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 16.0*5.0*(double)n_iterations;
}


static double mla_i64_i64_ilp6(const void*) {
  // MLA (I64, one vector), Multiply-Accumulate (integer)
  //
  // Each instruction: (8x i64, 8x i64) → 8x i64 (16 OPs)
  // Total of 96 OPs per loop iteration, ILP = 6
  size_t n_iterations = N_ITERATIONS/6;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.d                                                  \n"
    "1:                                                          \n"
    "  mla z0.d, p0/m, z0.d, z0.d                                \n"
    "  mla z1.d, p0/m, z1.d, z1.d                                \n"
    "  mla z2.d, p0/m, z2.d, z2.d                                \n"
    "  mla z3.d, p0/m, z3.d, z3.d                                \n"
    "  mla z4.d, p0/m, z4.d, z4.d                                \n"
    "  mla z5.d, p0/m, z5.d, z5.d                                \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 16.0*6.0*(double)n_iterations;
}


static double mla_i64_i64_ilp7(const void*) {
  // MLA (I64, one vector), Multiply-Accumulate (integer)
  //
  // Each instruction: (8x i64, 8x i64) → 8x i64 (16 OPs)
  // Total of 112 OPs per loop iteration, ILP = 7
  size_t n_iterations = N_ITERATIONS/7;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.d                                                  \n"
    "1:                                                          \n"
    "  mla z0.d, p0/m, z0.d, z0.d                                \n"
    "  mla z1.d, p0/m, z1.d, z1.d                                \n"
    "  mla z2.d, p0/m, z2.d, z2.d                                \n"
    "  mla z3.d, p0/m, z3.d, z3.d                                \n"
    "  mla z4.d, p0/m, z4.d, z4.d                                \n"
    "  mla z5.d, p0/m, z5.d, z5.d                                \n"
    "  mla z6.d, p0/m, z6.d, z6.d                                \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 16.0*7.0*(double)n_iterations;
}


static double mla_i64_i64_ilp8(const void*) {
  // MLA (I64, one vector), Multiply-Accumulate (integer)
  //
  // Each instruction: (8x i64, 8x i64) → 8x i64 (16 OPs)
  // Total of 128 OPs per loop iteration, ILP = 8
  size_t n_iterations = N_ITERATIONS/8;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.d                                                  \n"
    "1:                                                          \n"
    "  mla z0.d, p0/m, z0.d, z0.d                                \n"
    "  mla z1.d, p0/m, z1.d, z1.d                                \n"
    "  mla z2.d, p0/m, z2.d, z2.d                                \n"
    "  mla z3.d, p0/m, z3.d, z3.d                                \n"
    "  mla z4.d, p0/m, z4.d, z4.d                                \n"
    "  mla z5.d, p0/m, z5.d, z5.d                                \n"
    "  mla z6.d, p0/m, z6.d, z6.d                                \n"
    "  mla z7.d, p0/m, z7.d, z7.d                                \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 16.0*8.0*(double)n_iterations;
}


static double mla_i64_i64_ilp9(const void*) {
  // MLA (I64, one vector), Multiply-Accumulate (integer)
  //
  // Each instruction: (8x i64, 8x i64) → 8x i64 (16 OPs)
  // Total of 144 OPs per loop iteration, ILP = 9
  size_t n_iterations = N_ITERATIONS/9;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.d                                                  \n"
    "1:                                                          \n"
    "  mla z0.d, p0/m, z0.d, z0.d                                \n"
    "  mla z1.d, p0/m, z1.d, z1.d                                \n"
    "  mla z2.d, p0/m, z2.d, z2.d                                \n"
    "  mla z3.d, p0/m, z3.d, z3.d                                \n"
    "  mla z4.d, p0/m, z4.d, z4.d                                \n"
    "  mla z5.d, p0/m, z5.d, z5.d                                \n"
    "  mla z6.d, p0/m, z6.d, z6.d                                \n"
    "  mla z7.d, p0/m, z7.d, z7.d                                \n"
    "  mla z8.d, p0/m, z8.d, z8.d                                \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 16.0*9.0*(double)n_iterations;
}


static double mla_i64_i64_ilp10(const void*) {
  // MLA (I64, one vector), Multiply-Accumulate (integer)
  //
  // Each instruction: (8x i64, 8x i64) → 8x i64 (16 OPs)
  // Total of 160 OPs per loop iteration, ILP = 10
  size_t n_iterations = N_ITERATIONS/10;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.d                                                  \n"
    "1:                                                          \n"
    "  mla z0.d, p0/m, z0.d, z0.d                                \n"
    "  mla z1.d, p0/m, z1.d, z1.d                                \n"
    "  mla z2.d, p0/m, z2.d, z2.d                                \n"
    "  mla z3.d, p0/m, z3.d, z3.d                                \n"
    "  mla z4.d, p0/m, z4.d, z4.d                                \n"
    "  mla z5.d, p0/m, z5.d, z5.d                                \n"
    "  mla z6.d, p0/m, z6.d, z6.d                                \n"
    "  mla z7.d, p0/m, z7.d, z7.d                                \n"
    "  mla z8.d, p0/m, z8.d, z8.d                                \n"
    "  mla z9.d, p0/m, z9.d, z9.d                                \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 16.0*10.0*(double)n_iterations;
}


static double mla_i64_i64_ilp11(const void*) {
  // MLA (I64, one vector), Multiply-Accumulate (integer)
  //
  // Each instruction: (8x i64, 8x i64) → 8x i64 (16 OPs)
  // Total of 176 OPs per loop iteration, ILP = 11
  size_t n_iterations = N_ITERATIONS/11;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.d                                                  \n"
    "1:                                                          \n"
    "  mla z0.d, p0/m, z0.d, z0.d                                \n"
    "  mla z1.d, p0/m, z1.d, z1.d                                \n"
    "  mla z2.d, p0/m, z2.d, z2.d                                \n"
    "  mla z3.d, p0/m, z3.d, z3.d                                \n"
    "  mla z4.d, p0/m, z4.d, z4.d                                \n"
    "  mla z5.d, p0/m, z5.d, z5.d                                \n"
    "  mla z6.d, p0/m, z6.d, z6.d                                \n"
    "  mla z7.d, p0/m, z7.d, z7.d                                \n"
    "  mla z8.d, p0/m, z8.d, z8.d                                \n"
    "  mla z9.d, p0/m, z9.d, z9.d                                \n"
    "  mla z10.d, p0/m, z10.d, z10.d                             \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 16.0*11.0*(double)n_iterations;
}


static double mla_i64_i64_ilp12(const void*) {
  // MLA (I64, one vector), Multiply-Accumulate (integer)
  //
  // Each instruction: (8x i64, 8x i64) → 8x i64 (16 OPs)
  // Total of 192 OPs per loop iteration, ILP = 12
  size_t n_iterations = N_ITERATIONS/12;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.d                                                  \n"
    "1:                                                          \n"
    "  mla z0.d, p0/m, z0.d, z0.d                                \n"
    "  mla z1.d, p0/m, z1.d, z1.d                                \n"
    "  mla z2.d, p0/m, z2.d, z2.d                                \n"
    "  mla z3.d, p0/m, z3.d, z3.d                                \n"
    "  mla z4.d, p0/m, z4.d, z4.d                                \n"
    "  mla z5.d, p0/m, z5.d, z5.d                                \n"
    "  mla z6.d, p0/m, z6.d, z6.d                                \n"
    "  mla z7.d, p0/m, z7.d, z7.d                                \n"
    "  mla z8.d, p0/m, z8.d, z8.d                                \n"
    "  mla z9.d, p0/m, z9.d, z9.d                                \n"
    "  mla z10.d, p0/m, z10.d, z10.d                             \n"
    "  mla z11.d, p0/m, z11.d, z11.d                             \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 16.0*12.0*(double)n_iterations;
}


static double mla_i64_i64_ilp13(const void*) {
  // MLA (I64, one vector), Multiply-Accumulate (integer)
  //
  // Each instruction: (8x i64, 8x i64) → 8x i64 (16 OPs)
  // Total of 208 OPs per loop iteration, ILP = 13
  size_t n_iterations = N_ITERATIONS/13;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.d                                                  \n"
    "1:                                                          \n"
    "  mla z0.d, p0/m, z0.d, z0.d                                \n"
    "  mla z1.d, p0/m, z1.d, z1.d                                \n"
    "  mla z2.d, p0/m, z2.d, z2.d                                \n"
    "  mla z3.d, p0/m, z3.d, z3.d                                \n"
    "  mla z4.d, p0/m, z4.d, z4.d                                \n"
    "  mla z5.d, p0/m, z5.d, z5.d                                \n"
    "  mla z6.d, p0/m, z6.d, z6.d                                \n"
    "  mla z7.d, p0/m, z7.d, z7.d                                \n"
    "  mla z8.d, p0/m, z8.d, z8.d                                \n"
    "  mla z9.d, p0/m, z9.d, z9.d                                \n"
    "  mla z10.d, p0/m, z10.d, z10.d                             \n"
    "  mla z11.d, p0/m, z11.d, z11.d                             \n"
    "  mla z12.d, p0/m, z12.d, z12.d                             \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 16.0*13.0*(double)n_iterations;
}


static double mla_i64_i64_ilp14(const void*) {
  // MLA (I64, one vector), Multiply-Accumulate (integer)
  //
  // Each instruction: (8x i64, 8x i64) → 8x i64 (16 OPs)
  // Total of 224 OPs per loop iteration, ILP = 14
  size_t n_iterations = N_ITERATIONS/14;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.d                                                  \n"
    "1:                                                          \n"
    "  mla z0.d, p0/m, z0.d, z0.d                                \n"
    "  mla z1.d, p0/m, z1.d, z1.d                                \n"
    "  mla z2.d, p0/m, z2.d, z2.d                                \n"
    "  mla z3.d, p0/m, z3.d, z3.d                                \n"
    "  mla z4.d, p0/m, z4.d, z4.d                                \n"
    "  mla z5.d, p0/m, z5.d, z5.d                                \n"
    "  mla z6.d, p0/m, z6.d, z6.d                                \n"
    "  mla z7.d, p0/m, z7.d, z7.d                                \n"
    "  mla z8.d, p0/m, z8.d, z8.d                                \n"
    "  mla z9.d, p0/m, z9.d, z9.d                                \n"
    "  mla z10.d, p0/m, z10.d, z10.d                             \n"
    "  mla z11.d, p0/m, z11.d, z11.d                             \n"
    "  mla z12.d, p0/m, z12.d, z12.d                             \n"
    "  mla z13.d, p0/m, z13.d, z13.d                             \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 16.0*14.0*(double)n_iterations;
}


static double mla_i64_i64_ilp15(const void*) {
  // MLA (I64, one vector), Multiply-Accumulate (integer)
  //
  // Each instruction: (8x i64, 8x i64) → 8x i64 (16 OPs)
  // Total of 240 OPs per loop iteration, ILP = 15
  size_t n_iterations = N_ITERATIONS/15;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.d                                                  \n"
    "1:                                                          \n"
    "  mla z0.d, p0/m, z0.d, z0.d                                \n"
    "  mla z1.d, p0/m, z1.d, z1.d                                \n"
    "  mla z2.d, p0/m, z2.d, z2.d                                \n"
    "  mla z3.d, p0/m, z3.d, z3.d                                \n"
    "  mla z4.d, p0/m, z4.d, z4.d                                \n"
    "  mla z5.d, p0/m, z5.d, z5.d                                \n"
    "  mla z6.d, p0/m, z6.d, z6.d                                \n"
    "  mla z7.d, p0/m, z7.d, z7.d                                \n"
    "  mla z8.d, p0/m, z8.d, z8.d                                \n"
    "  mla z9.d, p0/m, z9.d, z9.d                                \n"
    "  mla z10.d, p0/m, z10.d, z10.d                             \n"
    "  mla z11.d, p0/m, z11.d, z11.d                             \n"
    "  mla z12.d, p0/m, z12.d, z12.d                             \n"
    "  mla z13.d, p0/m, z13.d, z13.d                             \n"
    "  mla z14.d, p0/m, z14.d, z14.d                             \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 16.0*15.0*(double)n_iterations;
}


static double mla_i64_i64_ilp16(const void*) {
  // MLA (I64, one vector), Multiply-Accumulate (integer)
  //
  // Each instruction: (8x i64, 8x i64) → 8x i64 (16 OPs)
  // Total of 256 OPs per loop iteration, ILP = 16
  size_t n_iterations = N_ITERATIONS/16;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.d                                                  \n"
    "1:                                                          \n"
    "  mla z0.d, p0/m, z0.d, z0.d                                \n"
    "  mla z1.d, p0/m, z1.d, z1.d                                \n"
    "  mla z2.d, p0/m, z2.d, z2.d                                \n"
    "  mla z3.d, p0/m, z3.d, z3.d                                \n"
    "  mla z4.d, p0/m, z4.d, z4.d                                \n"
    "  mla z5.d, p0/m, z5.d, z5.d                                \n"
    "  mla z6.d, p0/m, z6.d, z6.d                                \n"
    "  mla z7.d, p0/m, z7.d, z7.d                                \n"
    "  mla z8.d, p0/m, z8.d, z8.d                                \n"
    "  mla z9.d, p0/m, z9.d, z9.d                                \n"
    "  mla z10.d, p0/m, z10.d, z10.d                             \n"
    "  mla z11.d, p0/m, z11.d, z11.d                             \n"
    "  mla z12.d, p0/m, z12.d, z12.d                             \n"
    "  mla z13.d, p0/m, z13.d, z13.d                             \n"
    "  mla z14.d, p0/m, z14.d, z14.d                             \n"
    "  mla z15.d, p0/m, z15.d, z15.d                             \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 16.0*16.0*(double)n_iterations;
}


static double smlal_za_i32_i16_vgx2_ilp1(const void*) {
  // SMLAL (I16 to I32, two vectors), Multiply-Accumulate (integer)
  //
  // Each instruction: (64x i16, 64x i16) → 64x i32 (128 OPs)
  // Total of 128 OPs per loop iteration, ILP = 1
  size_t n_iterations = N_ITERATIONS;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  smlal za.s[w8, 0:1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*1.0*(double)n_iterations;
}


static double smlal_za_i32_i16_vgx2_ilp2(const void*) {
  // SMLAL (I16 to I32, two vectors), Multiply-Accumulate (integer)
  //
  // Each instruction: (64x i16, 64x i16) → 64x i32 (128 OPs)
  // Total of 256 OPs per loop iteration, ILP = 2
  size_t n_iterations = N_ITERATIONS/2;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  smlal za.s[w8, 0:1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}       \n"
    "  smlal za.s[w8, 2:3, VGx2], {z0.h-z1.h}, {z0.h-z1.h}       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*2.0*(double)n_iterations;
}


static double smlal_za_i32_i16_vgx2_ilp3(const void*) {
  // SMLAL (I16 to I32, two vectors), Multiply-Accumulate (integer)
  //
  // Each instruction: (64x i16, 64x i16) → 64x i32 (128 OPs)
  // Total of 384 OPs per loop iteration, ILP = 3
  size_t n_iterations = N_ITERATIONS/3;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  smlal za.s[w8, 0:1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}       \n"
    "  smlal za.s[w8, 2:3, VGx2], {z0.h-z1.h}, {z0.h-z1.h}       \n"
    "  smlal za.s[w8, 4:5, VGx2], {z2.h-z3.h}, {z2.h-z3.h}       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*3.0*(double)n_iterations;
}


static double smlal_za_i32_i16_vgx2_ilp4(const void*) {
  // SMLAL (I16 to I32, two vectors), Multiply-Accumulate (integer)
  //
  // Each instruction: (64x i16, 64x i16) → 64x i32 (128 OPs)
  // Total of 512 OPs per loop iteration, ILP = 4
  size_t n_iterations = N_ITERATIONS/4;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  smlal za.s[w8, 0:1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}       \n"
    "  smlal za.s[w8, 2:3, VGx2], {z0.h-z1.h}, {z0.h-z1.h}       \n"
    "  smlal za.s[w8, 4:5, VGx2], {z2.h-z3.h}, {z2.h-z3.h}       \n"
    "  smlal za.s[w8, 6:7, VGx2], {z2.h-z3.h}, {z2.h-z3.h}       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*4.0*(double)n_iterations;
}


static double smlal_za_i32_i16_vgx2_ilp5(const void*) {
  // SMLAL (I16 to I32, two vectors), Multiply-Accumulate (integer)
  //
  // Each instruction: (64x i16, 64x i16) → 64x i32 (128 OPs)
  // Total of 640 OPs per loop iteration, ILP = 5
  size_t n_iterations = N_ITERATIONS/5;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  smlal za.s[w8, 0:1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}       \n"
    "  smlal za.s[w8, 2:3, VGx2], {z0.h-z1.h}, {z0.h-z1.h}       \n"
    "  smlal za.s[w8, 4:5, VGx2], {z2.h-z3.h}, {z2.h-z3.h}       \n"
    "  smlal za.s[w8, 6:7, VGx2], {z2.h-z3.h}, {z2.h-z3.h}       \n"
    "  smlal za.s[w9, 0:1, VGx2], {z4.h-z5.h}, {z4.h-z5.h}       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*5.0*(double)n_iterations;
}


static double smlal_za_i32_i16_vgx2_ilp6(const void*) {
  // SMLAL (I16 to I32, two vectors), Multiply-Accumulate (integer)
  //
  // Each instruction: (64x i16, 64x i16) → 64x i32 (128 OPs)
  // Total of 768 OPs per loop iteration, ILP = 6
  size_t n_iterations = N_ITERATIONS/6;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  smlal za.s[w8, 0:1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}       \n"
    "  smlal za.s[w8, 2:3, VGx2], {z0.h-z1.h}, {z0.h-z1.h}       \n"
    "  smlal za.s[w8, 4:5, VGx2], {z2.h-z3.h}, {z2.h-z3.h}       \n"
    "  smlal za.s[w8, 6:7, VGx2], {z2.h-z3.h}, {z2.h-z3.h}       \n"
    "  smlal za.s[w9, 0:1, VGx2], {z4.h-z5.h}, {z4.h-z5.h}       \n"
    "  smlal za.s[w9, 2:3, VGx2], {z4.h-z5.h}, {z4.h-z5.h}       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*6.0*(double)n_iterations;
}


static double smlal_za_i32_i16_vgx2_ilp7(const void*) {
  // SMLAL (I16 to I32, two vectors), Multiply-Accumulate (integer)
  //
  // Each instruction: (64x i16, 64x i16) → 64x i32 (128 OPs)
  // Total of 896 OPs per loop iteration, ILP = 7
  size_t n_iterations = N_ITERATIONS/7;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  smlal za.s[w8, 0:1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}       \n"
    "  smlal za.s[w8, 2:3, VGx2], {z0.h-z1.h}, {z0.h-z1.h}       \n"
    "  smlal za.s[w8, 4:5, VGx2], {z2.h-z3.h}, {z2.h-z3.h}       \n"
    "  smlal za.s[w8, 6:7, VGx2], {z2.h-z3.h}, {z2.h-z3.h}       \n"
    "  smlal za.s[w9, 0:1, VGx2], {z4.h-z5.h}, {z4.h-z5.h}       \n"
    "  smlal za.s[w9, 2:3, VGx2], {z4.h-z5.h}, {z4.h-z5.h}       \n"
    "  smlal za.s[w9, 4:5, VGx2], {z6.h-z7.h}, {z6.h-z7.h}       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*7.0*(double)n_iterations;
}


static double smlal_za_i32_i16_vgx2_ilp8(const void*) {
  // SMLAL (I16 to I32, two vectors), Multiply-Accumulate (integer)
  //
  // Each instruction: (64x i16, 64x i16) → 64x i32 (128 OPs)
  // Total of 1024 OPs per loop iteration, ILP = 8
  size_t n_iterations = N_ITERATIONS/8;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  smlal za.s[w8, 0:1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}       \n"
    "  smlal za.s[w8, 2:3, VGx2], {z0.h-z1.h}, {z0.h-z1.h}       \n"
    "  smlal za.s[w8, 4:5, VGx2], {z2.h-z3.h}, {z2.h-z3.h}       \n"
    "  smlal za.s[w8, 6:7, VGx2], {z2.h-z3.h}, {z2.h-z3.h}       \n"
    "  smlal za.s[w9, 0:1, VGx2], {z4.h-z5.h}, {z4.h-z5.h}       \n"
    "  smlal za.s[w9, 2:3, VGx2], {z4.h-z5.h}, {z4.h-z5.h}       \n"
    "  smlal za.s[w9, 4:5, VGx2], {z6.h-z7.h}, {z6.h-z7.h}       \n"
    "  smlal za.s[w9, 6:7, VGx2], {z6.h-z7.h}, {z6.h-z7.h}       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*8.0*(double)n_iterations;
}


static double smlal_za_i32_i16_vgx2_ilp9(const void*) {
  // SMLAL (I16 to I32, two vectors), Multiply-Accumulate (integer)
  //
  // Each instruction: (64x i16, 64x i16) → 64x i32 (128 OPs)
  // Total of 1152 OPs per loop iteration, ILP = 9
  size_t n_iterations = N_ITERATIONS/9;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  smlal za.s[w8, 0:1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}       \n"
    "  smlal za.s[w8, 2:3, VGx2], {z0.h-z1.h}, {z0.h-z1.h}       \n"
    "  smlal za.s[w8, 4:5, VGx2], {z2.h-z3.h}, {z2.h-z3.h}       \n"
    "  smlal za.s[w8, 6:7, VGx2], {z2.h-z3.h}, {z2.h-z3.h}       \n"
    "  smlal za.s[w9, 0:1, VGx2], {z4.h-z5.h}, {z4.h-z5.h}       \n"
    "  smlal za.s[w9, 2:3, VGx2], {z4.h-z5.h}, {z4.h-z5.h}       \n"
    "  smlal za.s[w9, 4:5, VGx2], {z6.h-z7.h}, {z6.h-z7.h}       \n"
    "  smlal za.s[w9, 6:7, VGx2], {z6.h-z7.h}, {z6.h-z7.h}       \n"
    "  smlal za.s[w10, 0:1, VGx2], {z8.h-z9.h}, {z8.h-z9.h}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*9.0*(double)n_iterations;
}


static double smlal_za_i32_i16_vgx2_ilp10(const void*) {
  // SMLAL (I16 to I32, two vectors), Multiply-Accumulate (integer)
  //
  // Each instruction: (64x i16, 64x i16) → 64x i32 (128 OPs)
  // Total of 1280 OPs per loop iteration, ILP = 10
  size_t n_iterations = N_ITERATIONS/10;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  smlal za.s[w8, 0:1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}       \n"
    "  smlal za.s[w8, 2:3, VGx2], {z0.h-z1.h}, {z0.h-z1.h}       \n"
    "  smlal za.s[w8, 4:5, VGx2], {z2.h-z3.h}, {z2.h-z3.h}       \n"
    "  smlal za.s[w8, 6:7, VGx2], {z2.h-z3.h}, {z2.h-z3.h}       \n"
    "  smlal za.s[w9, 0:1, VGx2], {z4.h-z5.h}, {z4.h-z5.h}       \n"
    "  smlal za.s[w9, 2:3, VGx2], {z4.h-z5.h}, {z4.h-z5.h}       \n"
    "  smlal za.s[w9, 4:5, VGx2], {z6.h-z7.h}, {z6.h-z7.h}       \n"
    "  smlal za.s[w9, 6:7, VGx2], {z6.h-z7.h}, {z6.h-z7.h}       \n"
    "  smlal za.s[w10, 0:1, VGx2], {z8.h-z9.h}, {z8.h-z9.h}      \n"
    "  smlal za.s[w10, 2:3, VGx2], {z8.h-z9.h}, {z8.h-z9.h}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*10.0*(double)n_iterations;
}


static double smlal_za_i32_i16_vgx2_ilp11(const void*) {
  // SMLAL (I16 to I32, two vectors), Multiply-Accumulate (integer)
  //
  // Each instruction: (64x i16, 64x i16) → 64x i32 (128 OPs)
  // Total of 1408 OPs per loop iteration, ILP = 11
  size_t n_iterations = N_ITERATIONS/11;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  smlal za.s[w8, 0:1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}       \n"
    "  smlal za.s[w8, 2:3, VGx2], {z0.h-z1.h}, {z0.h-z1.h}       \n"
    "  smlal za.s[w8, 4:5, VGx2], {z2.h-z3.h}, {z2.h-z3.h}       \n"
    "  smlal za.s[w8, 6:7, VGx2], {z2.h-z3.h}, {z2.h-z3.h}       \n"
    "  smlal za.s[w9, 0:1, VGx2], {z4.h-z5.h}, {z4.h-z5.h}       \n"
    "  smlal za.s[w9, 2:3, VGx2], {z4.h-z5.h}, {z4.h-z5.h}       \n"
    "  smlal za.s[w9, 4:5, VGx2], {z6.h-z7.h}, {z6.h-z7.h}       \n"
    "  smlal za.s[w9, 6:7, VGx2], {z6.h-z7.h}, {z6.h-z7.h}       \n"
    "  smlal za.s[w10, 0:1, VGx2], {z8.h-z9.h}, {z8.h-z9.h}      \n"
    "  smlal za.s[w10, 2:3, VGx2], {z8.h-z9.h}, {z8.h-z9.h}      \n"
    "  smlal za.s[w10, 4:5, VGx2], {z10.h-z11.h}, {z10.h-z11.h}  \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*11.0*(double)n_iterations;
}


static double smlal_za_i32_i16_vgx2_ilp12(const void*) {
  // SMLAL (I16 to I32, two vectors), Multiply-Accumulate (integer)
  //
  // Each instruction: (64x i16, 64x i16) → 64x i32 (128 OPs)
  // Total of 1536 OPs per loop iteration, ILP = 12
  size_t n_iterations = N_ITERATIONS/12;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  smlal za.s[w8, 0:1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}       \n"
    "  smlal za.s[w8, 2:3, VGx2], {z0.h-z1.h}, {z0.h-z1.h}       \n"
    "  smlal za.s[w8, 4:5, VGx2], {z2.h-z3.h}, {z2.h-z3.h}       \n"
    "  smlal za.s[w8, 6:7, VGx2], {z2.h-z3.h}, {z2.h-z3.h}       \n"
    "  smlal za.s[w9, 0:1, VGx2], {z4.h-z5.h}, {z4.h-z5.h}       \n"
    "  smlal za.s[w9, 2:3, VGx2], {z4.h-z5.h}, {z4.h-z5.h}       \n"
    "  smlal za.s[w9, 4:5, VGx2], {z6.h-z7.h}, {z6.h-z7.h}       \n"
    "  smlal za.s[w9, 6:7, VGx2], {z6.h-z7.h}, {z6.h-z7.h}       \n"
    "  smlal za.s[w10, 0:1, VGx2], {z8.h-z9.h}, {z8.h-z9.h}      \n"
    "  smlal za.s[w10, 2:3, VGx2], {z8.h-z9.h}, {z8.h-z9.h}      \n"
    "  smlal za.s[w10, 4:5, VGx2], {z10.h-z11.h}, {z10.h-z11.h}  \n"
    "  smlal za.s[w10, 6:7, VGx2], {z10.h-z11.h}, {z10.h-z11.h}  \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*12.0*(double)n_iterations;
}


static double smlal_za_i32_i16_vgx2_ilp13(const void*) {
  // SMLAL (I16 to I32, two vectors), Multiply-Accumulate (integer)
  //
  // Each instruction: (64x i16, 64x i16) → 64x i32 (128 OPs)
  // Total of 1664 OPs per loop iteration, ILP = 13
  size_t n_iterations = N_ITERATIONS/13;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  smlal za.s[w8, 0:1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}       \n"
    "  smlal za.s[w8, 2:3, VGx2], {z0.h-z1.h}, {z0.h-z1.h}       \n"
    "  smlal za.s[w8, 4:5, VGx2], {z2.h-z3.h}, {z2.h-z3.h}       \n"
    "  smlal za.s[w8, 6:7, VGx2], {z2.h-z3.h}, {z2.h-z3.h}       \n"
    "  smlal za.s[w9, 0:1, VGx2], {z4.h-z5.h}, {z4.h-z5.h}       \n"
    "  smlal za.s[w9, 2:3, VGx2], {z4.h-z5.h}, {z4.h-z5.h}       \n"
    "  smlal za.s[w9, 4:5, VGx2], {z6.h-z7.h}, {z6.h-z7.h}       \n"
    "  smlal za.s[w9, 6:7, VGx2], {z6.h-z7.h}, {z6.h-z7.h}       \n"
    "  smlal za.s[w10, 0:1, VGx2], {z8.h-z9.h}, {z8.h-z9.h}      \n"
    "  smlal za.s[w10, 2:3, VGx2], {z8.h-z9.h}, {z8.h-z9.h}      \n"
    "  smlal za.s[w10, 4:5, VGx2], {z10.h-z11.h}, {z10.h-z11.h}  \n"
    "  smlal za.s[w10, 6:7, VGx2], {z10.h-z11.h}, {z10.h-z11.h}  \n"
    "  smlal za.s[w11, 0:1, VGx2], {z12.h-z13.h}, {z12.h-z13.h}  \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*13.0*(double)n_iterations;
}


static double smlal_za_i32_i16_vgx2_ilp14(const void*) {
  // SMLAL (I16 to I32, two vectors), Multiply-Accumulate (integer)
  //
  // Each instruction: (64x i16, 64x i16) → 64x i32 (128 OPs)
  // Total of 1792 OPs per loop iteration, ILP = 14
  size_t n_iterations = N_ITERATIONS/14;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  smlal za.s[w8, 0:1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}       \n"
    "  smlal za.s[w8, 2:3, VGx2], {z0.h-z1.h}, {z0.h-z1.h}       \n"
    "  smlal za.s[w8, 4:5, VGx2], {z2.h-z3.h}, {z2.h-z3.h}       \n"
    "  smlal za.s[w8, 6:7, VGx2], {z2.h-z3.h}, {z2.h-z3.h}       \n"
    "  smlal za.s[w9, 0:1, VGx2], {z4.h-z5.h}, {z4.h-z5.h}       \n"
    "  smlal za.s[w9, 2:3, VGx2], {z4.h-z5.h}, {z4.h-z5.h}       \n"
    "  smlal za.s[w9, 4:5, VGx2], {z6.h-z7.h}, {z6.h-z7.h}       \n"
    "  smlal za.s[w9, 6:7, VGx2], {z6.h-z7.h}, {z6.h-z7.h}       \n"
    "  smlal za.s[w10, 0:1, VGx2], {z8.h-z9.h}, {z8.h-z9.h}      \n"
    "  smlal za.s[w10, 2:3, VGx2], {z8.h-z9.h}, {z8.h-z9.h}      \n"
    "  smlal za.s[w10, 4:5, VGx2], {z10.h-z11.h}, {z10.h-z11.h}  \n"
    "  smlal za.s[w10, 6:7, VGx2], {z10.h-z11.h}, {z10.h-z11.h}  \n"
    "  smlal za.s[w11, 0:1, VGx2], {z12.h-z13.h}, {z12.h-z13.h}  \n"
    "  smlal za.s[w11, 2:3, VGx2], {z12.h-z13.h}, {z12.h-z13.h}  \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*14.0*(double)n_iterations;
}


static double smlal_za_i32_i16_vgx2_ilp15(const void*) {
  // SMLAL (I16 to I32, two vectors), Multiply-Accumulate (integer)
  //
  // Each instruction: (64x i16, 64x i16) → 64x i32 (128 OPs)
  // Total of 1920 OPs per loop iteration, ILP = 15
  size_t n_iterations = N_ITERATIONS/15;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  smlal za.s[w8, 0:1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}       \n"
    "  smlal za.s[w8, 2:3, VGx2], {z0.h-z1.h}, {z0.h-z1.h}       \n"
    "  smlal za.s[w8, 4:5, VGx2], {z2.h-z3.h}, {z2.h-z3.h}       \n"
    "  smlal za.s[w8, 6:7, VGx2], {z2.h-z3.h}, {z2.h-z3.h}       \n"
    "  smlal za.s[w9, 0:1, VGx2], {z4.h-z5.h}, {z4.h-z5.h}       \n"
    "  smlal za.s[w9, 2:3, VGx2], {z4.h-z5.h}, {z4.h-z5.h}       \n"
    "  smlal za.s[w9, 4:5, VGx2], {z6.h-z7.h}, {z6.h-z7.h}       \n"
    "  smlal za.s[w9, 6:7, VGx2], {z6.h-z7.h}, {z6.h-z7.h}       \n"
    "  smlal za.s[w10, 0:1, VGx2], {z8.h-z9.h}, {z8.h-z9.h}      \n"
    "  smlal za.s[w10, 2:3, VGx2], {z8.h-z9.h}, {z8.h-z9.h}      \n"
    "  smlal za.s[w10, 4:5, VGx2], {z10.h-z11.h}, {z10.h-z11.h}  \n"
    "  smlal za.s[w10, 6:7, VGx2], {z10.h-z11.h}, {z10.h-z11.h}  \n"
    "  smlal za.s[w11, 0:1, VGx2], {z12.h-z13.h}, {z12.h-z13.h}  \n"
    "  smlal za.s[w11, 2:3, VGx2], {z12.h-z13.h}, {z12.h-z13.h}  \n"
    "  smlal za.s[w11, 4:5, VGx2], {z14.h-z15.h}, {z14.h-z15.h}  \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*15.0*(double)n_iterations;
}


static double smlal_za_i32_i16_vgx2_ilp16(const void*) {
  // SMLAL (I16 to I32, two vectors), Multiply-Accumulate (integer)
  //
  // Each instruction: (64x i16, 64x i16) → 64x i32 (128 OPs)
  // Total of 2048 OPs per loop iteration, ILP = 16
  size_t n_iterations = N_ITERATIONS/16;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  smlal za.s[w8, 0:1, VGx2], {z0.h-z1.h}, {z0.h-z1.h}       \n"
    "  smlal za.s[w8, 2:3, VGx2], {z0.h-z1.h}, {z0.h-z1.h}       \n"
    "  smlal za.s[w8, 4:5, VGx2], {z2.h-z3.h}, {z2.h-z3.h}       \n"
    "  smlal za.s[w8, 6:7, VGx2], {z2.h-z3.h}, {z2.h-z3.h}       \n"
    "  smlal za.s[w9, 0:1, VGx2], {z4.h-z5.h}, {z4.h-z5.h}       \n"
    "  smlal za.s[w9, 2:3, VGx2], {z4.h-z5.h}, {z4.h-z5.h}       \n"
    "  smlal za.s[w9, 4:5, VGx2], {z6.h-z7.h}, {z6.h-z7.h}       \n"
    "  smlal za.s[w9, 6:7, VGx2], {z6.h-z7.h}, {z6.h-z7.h}       \n"
    "  smlal za.s[w10, 0:1, VGx2], {z8.h-z9.h}, {z8.h-z9.h}      \n"
    "  smlal za.s[w10, 2:3, VGx2], {z8.h-z9.h}, {z8.h-z9.h}      \n"
    "  smlal za.s[w10, 4:5, VGx2], {z10.h-z11.h}, {z10.h-z11.h}  \n"
    "  smlal za.s[w10, 6:7, VGx2], {z10.h-z11.h}, {z10.h-z11.h}  \n"
    "  smlal za.s[w11, 0:1, VGx2], {z12.h-z13.h}, {z12.h-z13.h}  \n"
    "  smlal za.s[w11, 2:3, VGx2], {z12.h-z13.h}, {z12.h-z13.h}  \n"
    "  smlal za.s[w11, 4:5, VGx2], {z14.h-z15.h}, {z14.h-z15.h}  \n"
    "  smlal za.s[w11, 6:7, VGx2], {z14.h-z15.h}, {z14.h-z15.h}  \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*16.0*(double)n_iterations;
}


static double smlal_za_i32_i16_vgx4_ilp1(const void*) {
  // SMLAL (I16 to I32, four vectors), Multiply-Accumulate (integer)
  //
  // Each instruction: (128x i16, 128x i16) → 128x i32 (256 OPs)
  // Total of 256 OPs per loop iteration, ILP = 1
  size_t n_iterations = N_ITERATIONS;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  smlal za.s[w8, 0:1, VGx4], {z0.h-z3.h}, {z0.h-z3.h}       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*1.0*(double)n_iterations;
}


static double smlal_za_i32_i16_vgx4_ilp2(const void*) {
  // SMLAL (I16 to I32, four vectors), Multiply-Accumulate (integer)
  //
  // Each instruction: (128x i16, 128x i16) → 128x i32 (256 OPs)
  // Total of 512 OPs per loop iteration, ILP = 2
  size_t n_iterations = N_ITERATIONS/2;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  smlal za.s[w8, 0:1, VGx4], {z0.h-z3.h}, {z0.h-z3.h}       \n"
    "  smlal za.s[w8, 2:3, VGx4], {z0.h-z3.h}, {z0.h-z3.h}       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*2.0*(double)n_iterations;
}


static double smlal_za_i32_i16_vgx4_ilp3(const void*) {
  // SMLAL (I16 to I32, four vectors), Multiply-Accumulate (integer)
  //
  // Each instruction: (128x i16, 128x i16) → 128x i32 (256 OPs)
  // Total of 768 OPs per loop iteration, ILP = 3
  size_t n_iterations = N_ITERATIONS/3;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  smlal za.s[w8, 0:1, VGx4], {z0.h-z3.h}, {z0.h-z3.h}       \n"
    "  smlal za.s[w8, 2:3, VGx4], {z0.h-z3.h}, {z0.h-z3.h}       \n"
    "  smlal za.s[w8, 4:5, VGx4], {z0.h-z3.h}, {z0.h-z3.h}       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*3.0*(double)n_iterations;
}


static double smlal_za_i32_i16_vgx4_ilp4(const void*) {
  // SMLAL (I16 to I32, four vectors), Multiply-Accumulate (integer)
  //
  // Each instruction: (128x i16, 128x i16) → 128x i32 (256 OPs)
  // Total of 1024 OPs per loop iteration, ILP = 4
  size_t n_iterations = N_ITERATIONS/4;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  smlal za.s[w8, 0:1, VGx4], {z0.h-z3.h}, {z0.h-z3.h}       \n"
    "  smlal za.s[w8, 2:3, VGx4], {z0.h-z3.h}, {z0.h-z3.h}       \n"
    "  smlal za.s[w8, 4:5, VGx4], {z0.h-z3.h}, {z0.h-z3.h}       \n"
    "  smlal za.s[w8, 6:7, VGx4], {z0.h-z3.h}, {z0.h-z3.h}       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*4.0*(double)n_iterations;
}


static double smlal_za_i32_i16_vgx4_ilp5(const void*) {
  // SMLAL (I16 to I32, four vectors), Multiply-Accumulate (integer)
  //
  // Each instruction: (128x i16, 128x i16) → 128x i32 (256 OPs)
  // Total of 1280 OPs per loop iteration, ILP = 5
  size_t n_iterations = N_ITERATIONS/5;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  smlal za.s[w8, 0:1, VGx4], {z0.h-z3.h}, {z0.h-z3.h}       \n"
    "  smlal za.s[w8, 2:3, VGx4], {z0.h-z3.h}, {z0.h-z3.h}       \n"
    "  smlal za.s[w8, 4:5, VGx4], {z0.h-z3.h}, {z0.h-z3.h}       \n"
    "  smlal za.s[w8, 6:7, VGx4], {z0.h-z3.h}, {z0.h-z3.h}       \n"
    "  smlal za.s[w9, 0:1, VGx4], {z4.h-z7.h}, {z4.h-z7.h}       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*5.0*(double)n_iterations;
}


static double smlal_za_i32_i16_vgx4_ilp6(const void*) {
  // SMLAL (I16 to I32, four vectors), Multiply-Accumulate (integer)
  //
  // Each instruction: (128x i16, 128x i16) → 128x i32 (256 OPs)
  // Total of 1536 OPs per loop iteration, ILP = 6
  size_t n_iterations = N_ITERATIONS/6;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  smlal za.s[w8, 0:1, VGx4], {z0.h-z3.h}, {z0.h-z3.h}       \n"
    "  smlal za.s[w8, 2:3, VGx4], {z0.h-z3.h}, {z0.h-z3.h}       \n"
    "  smlal za.s[w8, 4:5, VGx4], {z0.h-z3.h}, {z0.h-z3.h}       \n"
    "  smlal za.s[w8, 6:7, VGx4], {z0.h-z3.h}, {z0.h-z3.h}       \n"
    "  smlal za.s[w9, 0:1, VGx4], {z4.h-z7.h}, {z4.h-z7.h}       \n"
    "  smlal za.s[w9, 2:3, VGx4], {z4.h-z7.h}, {z4.h-z7.h}       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*6.0*(double)n_iterations;
}


static double smlal_za_i32_i16_vgx4_ilp7(const void*) {
  // SMLAL (I16 to I32, four vectors), Multiply-Accumulate (integer)
  //
  // Each instruction: (128x i16, 128x i16) → 128x i32 (256 OPs)
  // Total of 1792 OPs per loop iteration, ILP = 7
  size_t n_iterations = N_ITERATIONS/7;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  smlal za.s[w8, 0:1, VGx4], {z0.h-z3.h}, {z0.h-z3.h}       \n"
    "  smlal za.s[w8, 2:3, VGx4], {z0.h-z3.h}, {z0.h-z3.h}       \n"
    "  smlal za.s[w8, 4:5, VGx4], {z0.h-z3.h}, {z0.h-z3.h}       \n"
    "  smlal za.s[w8, 6:7, VGx4], {z0.h-z3.h}, {z0.h-z3.h}       \n"
    "  smlal za.s[w9, 0:1, VGx4], {z4.h-z7.h}, {z4.h-z7.h}       \n"
    "  smlal za.s[w9, 2:3, VGx4], {z4.h-z7.h}, {z4.h-z7.h}       \n"
    "  smlal za.s[w9, 4:5, VGx4], {z4.h-z7.h}, {z4.h-z7.h}       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*7.0*(double)n_iterations;
}


static double smlal_za_i32_i16_vgx4_ilp8(const void*) {
  // SMLAL (I16 to I32, four vectors), Multiply-Accumulate (integer)
  //
  // Each instruction: (128x i16, 128x i16) → 128x i32 (256 OPs)
  // Total of 2048 OPs per loop iteration, ILP = 8
  size_t n_iterations = N_ITERATIONS/8;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  smlal za.s[w8, 0:1, VGx4], {z0.h-z3.h}, {z0.h-z3.h}       \n"
    "  smlal za.s[w8, 2:3, VGx4], {z0.h-z3.h}, {z0.h-z3.h}       \n"
    "  smlal za.s[w8, 4:5, VGx4], {z0.h-z3.h}, {z0.h-z3.h}       \n"
    "  smlal za.s[w8, 6:7, VGx4], {z0.h-z3.h}, {z0.h-z3.h}       \n"
    "  smlal za.s[w9, 0:1, VGx4], {z4.h-z7.h}, {z4.h-z7.h}       \n"
    "  smlal za.s[w9, 2:3, VGx4], {z4.h-z7.h}, {z4.h-z7.h}       \n"
    "  smlal za.s[w9, 4:5, VGx4], {z4.h-z7.h}, {z4.h-z7.h}       \n"
    "  smlal za.s[w9, 6:7, VGx4], {z4.h-z7.h}, {z4.h-z7.h}       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*8.0*(double)n_iterations;
}


static double smlall_za_i32_i8_vgx2_ilp1(const void*) {
  // SMLALL (I8 to I32, two vectors), Multiply-Accumulate (integer)
  //
  // Each instruction: (128x i8, 128x i8) → 128x i32 (256 OPs)
  // Total of 256 OPs per loop iteration, ILP = 1
  size_t n_iterations = N_ITERATIONS;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  smlall za.s[w8, 0:3, VGx2], {z0.b-z1.b}, {z0.b-z1.b}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*1.0*(double)n_iterations;
}


static double smlall_za_i32_i8_vgx2_ilp2(const void*) {
  // SMLALL (I8 to I32, two vectors), Multiply-Accumulate (integer)
  //
  // Each instruction: (128x i8, 128x i8) → 128x i32 (256 OPs)
  // Total of 512 OPs per loop iteration, ILP = 2
  size_t n_iterations = N_ITERATIONS/2;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  smlall za.s[w8, 0:3, VGx2], {z0.b-z1.b}, {z0.b-z1.b}      \n"
    "  smlall za.s[w8, 4:7, VGx2], {z0.b-z1.b}, {z0.b-z1.b}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*2.0*(double)n_iterations;
}


static double smlall_za_i32_i8_vgx2_ilp3(const void*) {
  // SMLALL (I8 to I32, two vectors), Multiply-Accumulate (integer)
  //
  // Each instruction: (128x i8, 128x i8) → 128x i32 (256 OPs)
  // Total of 768 OPs per loop iteration, ILP = 3
  size_t n_iterations = N_ITERATIONS/3;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  smlall za.s[w8, 0:3, VGx2], {z0.b-z1.b}, {z0.b-z1.b}      \n"
    "  smlall za.s[w8, 4:7, VGx2], {z0.b-z1.b}, {z0.b-z1.b}      \n"
    "  smlall za.s[w9, 0:3, VGx2], {z2.b-z3.b}, {z2.b-z3.b}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*3.0*(double)n_iterations;
}


static double smlall_za_i32_i8_vgx2_ilp4(const void*) {
  // SMLALL (I8 to I32, two vectors), Multiply-Accumulate (integer)
  //
  // Each instruction: (128x i8, 128x i8) → 128x i32 (256 OPs)
  // Total of 1024 OPs per loop iteration, ILP = 4
  size_t n_iterations = N_ITERATIONS/4;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  smlall za.s[w8, 0:3, VGx2], {z0.b-z1.b}, {z0.b-z1.b}      \n"
    "  smlall za.s[w8, 4:7, VGx2], {z0.b-z1.b}, {z0.b-z1.b}      \n"
    "  smlall za.s[w9, 0:3, VGx2], {z2.b-z3.b}, {z2.b-z3.b}      \n"
    "  smlall za.s[w9, 4:7, VGx2], {z2.b-z3.b}, {z2.b-z3.b}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*4.0*(double)n_iterations;
}


static double smlall_za_i32_i8_vgx2_ilp5(const void*) {
  // SMLALL (I8 to I32, two vectors), Multiply-Accumulate (integer)
  //
  // Each instruction: (128x i8, 128x i8) → 128x i32 (256 OPs)
  // Total of 1280 OPs per loop iteration, ILP = 5
  size_t n_iterations = N_ITERATIONS/5;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  smlall za.s[w8, 0:3, VGx2], {z0.b-z1.b}, {z0.b-z1.b}      \n"
    "  smlall za.s[w8, 4:7, VGx2], {z0.b-z1.b}, {z0.b-z1.b}      \n"
    "  smlall za.s[w9, 0:3, VGx2], {z2.b-z3.b}, {z2.b-z3.b}      \n"
    "  smlall za.s[w9, 4:7, VGx2], {z2.b-z3.b}, {z2.b-z3.b}      \n"
    "  smlall za.s[w10, 0:3, VGx2], {z4.b-z5.b}, {z4.b-z5.b}     \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*5.0*(double)n_iterations;
}


static double smlall_za_i32_i8_vgx2_ilp6(const void*) {
  // SMLALL (I8 to I32, two vectors), Multiply-Accumulate (integer)
  //
  // Each instruction: (128x i8, 128x i8) → 128x i32 (256 OPs)
  // Total of 1536 OPs per loop iteration, ILP = 6
  size_t n_iterations = N_ITERATIONS/6;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  smlall za.s[w8, 0:3, VGx2], {z0.b-z1.b}, {z0.b-z1.b}      \n"
    "  smlall za.s[w8, 4:7, VGx2], {z0.b-z1.b}, {z0.b-z1.b}      \n"
    "  smlall za.s[w9, 0:3, VGx2], {z2.b-z3.b}, {z2.b-z3.b}      \n"
    "  smlall za.s[w9, 4:7, VGx2], {z2.b-z3.b}, {z2.b-z3.b}      \n"
    "  smlall za.s[w10, 0:3, VGx2], {z4.b-z5.b}, {z4.b-z5.b}     \n"
    "  smlall za.s[w10, 4:7, VGx2], {z4.b-z5.b}, {z4.b-z5.b}     \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*6.0*(double)n_iterations;
}


static double smlall_za_i32_i8_vgx2_ilp7(const void*) {
  // SMLALL (I8 to I32, two vectors), Multiply-Accumulate (integer)
  //
  // Each instruction: (128x i8, 128x i8) → 128x i32 (256 OPs)
  // Total of 1792 OPs per loop iteration, ILP = 7
  size_t n_iterations = N_ITERATIONS/7;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  smlall za.s[w8, 0:3, VGx2], {z0.b-z1.b}, {z0.b-z1.b}      \n"
    "  smlall za.s[w8, 4:7, VGx2], {z0.b-z1.b}, {z0.b-z1.b}      \n"
    "  smlall za.s[w9, 0:3, VGx2], {z2.b-z3.b}, {z2.b-z3.b}      \n"
    "  smlall za.s[w9, 4:7, VGx2], {z2.b-z3.b}, {z2.b-z3.b}      \n"
    "  smlall za.s[w10, 0:3, VGx2], {z4.b-z5.b}, {z4.b-z5.b}     \n"
    "  smlall za.s[w10, 4:7, VGx2], {z4.b-z5.b}, {z4.b-z5.b}     \n"
    "  smlall za.s[w11, 0:3, VGx2], {z6.b-z7.b}, {z6.b-z7.b}     \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*7.0*(double)n_iterations;
}


static double smlall_za_i32_i8_vgx2_ilp8(const void*) {
  // SMLALL (I8 to I32, two vectors), Multiply-Accumulate (integer)
  //
  // Each instruction: (128x i8, 128x i8) → 128x i32 (256 OPs)
  // Total of 2048 OPs per loop iteration, ILP = 8
  size_t n_iterations = N_ITERATIONS/8;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  smlall za.s[w8, 0:3, VGx2], {z0.b-z1.b}, {z0.b-z1.b}      \n"
    "  smlall za.s[w8, 4:7, VGx2], {z0.b-z1.b}, {z0.b-z1.b}      \n"
    "  smlall za.s[w9, 0:3, VGx2], {z2.b-z3.b}, {z2.b-z3.b}      \n"
    "  smlall za.s[w9, 4:7, VGx2], {z2.b-z3.b}, {z2.b-z3.b}      \n"
    "  smlall za.s[w10, 0:3, VGx2], {z4.b-z5.b}, {z4.b-z5.b}     \n"
    "  smlall za.s[w10, 4:7, VGx2], {z4.b-z5.b}, {z4.b-z5.b}     \n"
    "  smlall za.s[w11, 0:3, VGx2], {z6.b-z7.b}, {z6.b-z7.b}     \n"
    "  smlall za.s[w11, 4:7, VGx2], {z6.b-z7.b}, {z6.b-z7.b}     \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*8.0*(double)n_iterations;
}


static double smlall_za_i32_i8_vgx4_ilp1(const void*) {
  // SMLALL (I8 to I32, four vectors), Multiply-Accumulate (integer)
  //
  // Each instruction: (256x i8, 256x i8) → 256x i32 (512 OPs)
  // Total of 512 OPs per loop iteration, ILP = 1
  size_t n_iterations = N_ITERATIONS;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  smlall za.s[w8, 0:3, VGx4], {z0.b-z3.b}, {z0.b-z3.b}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 512.0*1.0*(double)n_iterations;
}


static double smlall_za_i32_i8_vgx4_ilp2(const void*) {
  // SMLALL (I8 to I32, four vectors), Multiply-Accumulate (integer)
  //
  // Each instruction: (256x i8, 256x i8) → 256x i32 (512 OPs)
  // Total of 1024 OPs per loop iteration, ILP = 2
  size_t n_iterations = N_ITERATIONS/2;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  smlall za.s[w8, 0:3, VGx4], {z0.b-z3.b}, {z0.b-z3.b}      \n"
    "  smlall za.s[w8, 4:7, VGx4], {z0.b-z3.b}, {z0.b-z3.b}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 512.0*2.0*(double)n_iterations;
}


static double smlall_za_i32_i8_vgx4_ilp3(const void*) {
  // SMLALL (I8 to I32, four vectors), Multiply-Accumulate (integer)
  //
  // Each instruction: (256x i8, 256x i8) → 256x i32 (512 OPs)
  // Total of 1536 OPs per loop iteration, ILP = 3
  size_t n_iterations = N_ITERATIONS/3;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  smlall za.s[w8, 0:3, VGx4], {z0.b-z3.b}, {z0.b-z3.b}      \n"
    "  smlall za.s[w8, 4:7, VGx4], {z0.b-z3.b}, {z0.b-z3.b}      \n"
    "  smlall za.s[w9, 0:3, VGx4], {z0.b-z3.b}, {z0.b-z3.b}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 512.0*3.0*(double)n_iterations;
}


static double smlall_za_i32_i8_vgx4_ilp4(const void*) {
  // SMLALL (I8 to I32, four vectors), Multiply-Accumulate (integer)
  //
  // Each instruction: (256x i8, 256x i8) → 256x i32 (512 OPs)
  // Total of 2048 OPs per loop iteration, ILP = 4
  size_t n_iterations = N_ITERATIONS/4;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  smlall za.s[w8, 0:3, VGx4], {z0.b-z3.b}, {z0.b-z3.b}      \n"
    "  smlall za.s[w8, 4:7, VGx4], {z0.b-z3.b}, {z0.b-z3.b}      \n"
    "  smlall za.s[w9, 0:3, VGx4], {z0.b-z3.b}, {z0.b-z3.b}      \n"
    "  smlall za.s[w9, 4:7, VGx4], {z0.b-z3.b}, {z0.b-z3.b}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 512.0*4.0*(double)n_iterations;
}


static double smlall_za_i64_i16_vgx2_ilp1(const void*) {
  // SMLALL (I16 to I64, two vectors), Multiply-Accumulate (integer)
  //
  // Each instruction: (64x i16, 64x i16) → 64x i64 (128 OPs)
  // Total of 128 OPs per loop iteration, ILP = 1
  size_t n_iterations = N_ITERATIONS;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  smlall za.d[w8, 0:3, VGx2], {z0.h-z1.h}, {z0.h-z1.h}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*1.0*(double)n_iterations;
}


static double smlall_za_i64_i16_vgx2_ilp2(const void*) {
  // SMLALL (I16 to I64, two vectors), Multiply-Accumulate (integer)
  //
  // Each instruction: (64x i16, 64x i16) → 64x i64 (128 OPs)
  // Total of 256 OPs per loop iteration, ILP = 2
  size_t n_iterations = N_ITERATIONS/2;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  smlall za.d[w8, 0:3, VGx2], {z0.h-z1.h}, {z0.h-z1.h}      \n"
    "  smlall za.d[w8, 4:7, VGx2], {z0.h-z1.h}, {z0.h-z1.h}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*2.0*(double)n_iterations;
}


static double smlall_za_i64_i16_vgx2_ilp3(const void*) {
  // SMLALL (I16 to I64, two vectors), Multiply-Accumulate (integer)
  //
  // Each instruction: (64x i16, 64x i16) → 64x i64 (128 OPs)
  // Total of 384 OPs per loop iteration, ILP = 3
  size_t n_iterations = N_ITERATIONS/3;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  smlall za.d[w8, 0:3, VGx2], {z0.h-z1.h}, {z0.h-z1.h}      \n"
    "  smlall za.d[w8, 4:7, VGx2], {z0.h-z1.h}, {z0.h-z1.h}      \n"
    "  smlall za.d[w9, 0:3, VGx2], {z2.h-z3.h}, {z2.h-z3.h}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*3.0*(double)n_iterations;
}


static double smlall_za_i64_i16_vgx2_ilp4(const void*) {
  // SMLALL (I16 to I64, two vectors), Multiply-Accumulate (integer)
  //
  // Each instruction: (64x i16, 64x i16) → 64x i64 (128 OPs)
  // Total of 512 OPs per loop iteration, ILP = 4
  size_t n_iterations = N_ITERATIONS/4;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  smlall za.d[w8, 0:3, VGx2], {z0.h-z1.h}, {z0.h-z1.h}      \n"
    "  smlall za.d[w8, 4:7, VGx2], {z0.h-z1.h}, {z0.h-z1.h}      \n"
    "  smlall za.d[w9, 0:3, VGx2], {z2.h-z3.h}, {z2.h-z3.h}      \n"
    "  smlall za.d[w9, 4:7, VGx2], {z2.h-z3.h}, {z2.h-z3.h}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*4.0*(double)n_iterations;
}


static double smlall_za_i64_i16_vgx2_ilp5(const void*) {
  // SMLALL (I16 to I64, two vectors), Multiply-Accumulate (integer)
  //
  // Each instruction: (64x i16, 64x i16) → 64x i64 (128 OPs)
  // Total of 640 OPs per loop iteration, ILP = 5
  size_t n_iterations = N_ITERATIONS/5;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  smlall za.d[w8, 0:3, VGx2], {z0.h-z1.h}, {z0.h-z1.h}      \n"
    "  smlall za.d[w8, 4:7, VGx2], {z0.h-z1.h}, {z0.h-z1.h}      \n"
    "  smlall za.d[w9, 0:3, VGx2], {z2.h-z3.h}, {z2.h-z3.h}      \n"
    "  smlall za.d[w9, 4:7, VGx2], {z2.h-z3.h}, {z2.h-z3.h}      \n"
    "  smlall za.d[w10, 0:3, VGx2], {z4.h-z5.h}, {z4.h-z5.h}     \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*5.0*(double)n_iterations;
}


static double smlall_za_i64_i16_vgx2_ilp6(const void*) {
  // SMLALL (I16 to I64, two vectors), Multiply-Accumulate (integer)
  //
  // Each instruction: (64x i16, 64x i16) → 64x i64 (128 OPs)
  // Total of 768 OPs per loop iteration, ILP = 6
  size_t n_iterations = N_ITERATIONS/6;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  smlall za.d[w8, 0:3, VGx2], {z0.h-z1.h}, {z0.h-z1.h}      \n"
    "  smlall za.d[w8, 4:7, VGx2], {z0.h-z1.h}, {z0.h-z1.h}      \n"
    "  smlall za.d[w9, 0:3, VGx2], {z2.h-z3.h}, {z2.h-z3.h}      \n"
    "  smlall za.d[w9, 4:7, VGx2], {z2.h-z3.h}, {z2.h-z3.h}      \n"
    "  smlall za.d[w10, 0:3, VGx2], {z4.h-z5.h}, {z4.h-z5.h}     \n"
    "  smlall za.d[w10, 4:7, VGx2], {z4.h-z5.h}, {z4.h-z5.h}     \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*6.0*(double)n_iterations;
}


static double smlall_za_i64_i16_vgx2_ilp7(const void*) {
  // SMLALL (I16 to I64, two vectors), Multiply-Accumulate (integer)
  //
  // Each instruction: (64x i16, 64x i16) → 64x i64 (128 OPs)
  // Total of 896 OPs per loop iteration, ILP = 7
  size_t n_iterations = N_ITERATIONS/7;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  smlall za.d[w8, 0:3, VGx2], {z0.h-z1.h}, {z0.h-z1.h}      \n"
    "  smlall za.d[w8, 4:7, VGx2], {z0.h-z1.h}, {z0.h-z1.h}      \n"
    "  smlall za.d[w9, 0:3, VGx2], {z2.h-z3.h}, {z2.h-z3.h}      \n"
    "  smlall za.d[w9, 4:7, VGx2], {z2.h-z3.h}, {z2.h-z3.h}      \n"
    "  smlall za.d[w10, 0:3, VGx2], {z4.h-z5.h}, {z4.h-z5.h}     \n"
    "  smlall za.d[w10, 4:7, VGx2], {z4.h-z5.h}, {z4.h-z5.h}     \n"
    "  smlall za.d[w11, 0:3, VGx2], {z6.h-z7.h}, {z6.h-z7.h}     \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*7.0*(double)n_iterations;
}


static double smlall_za_i64_i16_vgx2_ilp8(const void*) {
  // SMLALL (I16 to I64, two vectors), Multiply-Accumulate (integer)
  //
  // Each instruction: (64x i16, 64x i16) → 64x i64 (128 OPs)
  // Total of 1024 OPs per loop iteration, ILP = 8
  size_t n_iterations = N_ITERATIONS/8;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  smlall za.d[w8, 0:3, VGx2], {z0.h-z1.h}, {z0.h-z1.h}      \n"
    "  smlall za.d[w8, 4:7, VGx2], {z0.h-z1.h}, {z0.h-z1.h}      \n"
    "  smlall za.d[w9, 0:3, VGx2], {z2.h-z3.h}, {z2.h-z3.h}      \n"
    "  smlall za.d[w9, 4:7, VGx2], {z2.h-z3.h}, {z2.h-z3.h}      \n"
    "  smlall za.d[w10, 0:3, VGx2], {z4.h-z5.h}, {z4.h-z5.h}     \n"
    "  smlall za.d[w10, 4:7, VGx2], {z4.h-z5.h}, {z4.h-z5.h}     \n"
    "  smlall za.d[w11, 0:3, VGx2], {z6.h-z7.h}, {z6.h-z7.h}     \n"
    "  smlall za.d[w11, 4:7, VGx2], {z6.h-z7.h}, {z6.h-z7.h}     \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*8.0*(double)n_iterations;
}


static double smlall_za_i64_i16_vgx4_ilp1(const void*) {
  // SMLALL (I16 to I64, four vectors), Multiply-Accumulate (integer)
  //
  // Each instruction: (128x i16, 128x i16) → 128x i64 (256 OPs)
  // Total of 256 OPs per loop iteration, ILP = 1
  size_t n_iterations = N_ITERATIONS;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  smlall za.d[w8, 0:3, VGx4], {z0.h-z3.h}, {z0.h-z3.h}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*1.0*(double)n_iterations;
}


static double smlall_za_i64_i16_vgx4_ilp2(const void*) {
  // SMLALL (I16 to I64, four vectors), Multiply-Accumulate (integer)
  //
  // Each instruction: (128x i16, 128x i16) → 128x i64 (256 OPs)
  // Total of 512 OPs per loop iteration, ILP = 2
  size_t n_iterations = N_ITERATIONS/2;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  smlall za.d[w8, 0:3, VGx4], {z0.h-z3.h}, {z0.h-z3.h}      \n"
    "  smlall za.d[w8, 4:7, VGx4], {z0.h-z3.h}, {z0.h-z3.h}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*2.0*(double)n_iterations;
}


static double smlall_za_i64_i16_vgx4_ilp3(const void*) {
  // SMLALL (I16 to I64, four vectors), Multiply-Accumulate (integer)
  //
  // Each instruction: (128x i16, 128x i16) → 128x i64 (256 OPs)
  // Total of 768 OPs per loop iteration, ILP = 3
  size_t n_iterations = N_ITERATIONS/3;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  smlall za.d[w8, 0:3, VGx4], {z0.h-z3.h}, {z0.h-z3.h}      \n"
    "  smlall za.d[w8, 4:7, VGx4], {z0.h-z3.h}, {z0.h-z3.h}      \n"
    "  smlall za.d[w9, 0:3, VGx4], {z0.h-z3.h}, {z0.h-z3.h}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*3.0*(double)n_iterations;
}


static double smlall_za_i64_i16_vgx4_ilp4(const void*) {
  // SMLALL (I16 to I64, four vectors), Multiply-Accumulate (integer)
  //
  // Each instruction: (128x i16, 128x i16) → 128x i64 (256 OPs)
  // Total of 1024 OPs per loop iteration, ILP = 4
  size_t n_iterations = N_ITERATIONS/4;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "mov x8, 0                                                   \n"
    "mov x9, 8                                                   \n"
    "mov x10, 16                                                 \n"
    "mov x11, 24                                                 \n"
    "1:                                                          \n"
    "  smlall za.d[w8, 0:3, VGx4], {z0.h-z3.h}, {z0.h-z3.h}      \n"
    "  smlall za.d[w8, 4:7, VGx4], {z0.h-z3.h}, {z0.h-z3.h}      \n"
    "  smlall za.d[w9, 0:3, VGx4], {z0.h-z3.h}, {z0.h-z3.h}      \n"
    "  smlall za.d[w9, 4:7, VGx4], {z0.h-z3.h}, {z0.h-z3.h}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0", "x8", "x9", "x10", "x11"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 256.0*4.0*(double)n_iterations;
}


static double fmopa_za_f16_f16_ilp1(const void*) {
  // FMOPA (FP16), Outer Product (floating-point)
  //
  // Each instruction: (32x f16, 32x f16) → 1024x f16 (2048 OPs)
  // Total of 2048 OPs per loop iteration, ILP = 1
  size_t n_iterations = N_ITERATIONS;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.h                                                  \n"
    "ptrue p1.h                                                  \n"
    "1:                                                          \n"
    "  fmopa za0.h, p0/m, p1/m, z0.h, z0.h                       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 2048.0*1.0*(double)n_iterations;
}


static double fmopa_za_f16_f16_ilp2(const void*) {
  // FMOPA (FP16), Outer Product (floating-point)
  //
  // Each instruction: (32x f16, 32x f16) → 1024x f16 (2048 OPs)
  // Total of 4096 OPs per loop iteration, ILP = 2
  size_t n_iterations = N_ITERATIONS/2;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.h                                                  \n"
    "ptrue p1.h                                                  \n"
    "1:                                                          \n"
    "  fmopa za0.h, p0/m, p1/m, z0.h, z0.h                       \n"
    "  fmopa za1.h, p0/m, p1/m, z1.h, z1.h                       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 2048.0*2.0*(double)n_iterations;
}


static double fmopa_za_f32_f32_ilp1(const void*) {
  // FMOPA (FP32), Outer Product (floating-point)
  //
  // Each instruction: (16x f32, 16x f32) → 256x f32 (512 OPs)
  // Total of 512 OPs per loop iteration, ILP = 1
  size_t n_iterations = N_ITERATIONS;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.s                                                  \n"
    "ptrue p1.s                                                  \n"
    "1:                                                          \n"
    "  fmopa za0.s, p0/m, p1/m, z0.s, z0.s                       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 512.0*1.0*(double)n_iterations;
}


static double fmopa_za_f32_f32_ilp2(const void*) {
  // FMOPA (FP32), Outer Product (floating-point)
  //
  // Each instruction: (16x f32, 16x f32) → 256x f32 (512 OPs)
  // Total of 1024 OPs per loop iteration, ILP = 2
  size_t n_iterations = N_ITERATIONS/2;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.s                                                  \n"
    "ptrue p1.s                                                  \n"
    "1:                                                          \n"
    "  fmopa za0.s, p0/m, p1/m, z0.s, z0.s                       \n"
    "  fmopa za1.s, p0/m, p1/m, z1.s, z1.s                       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 512.0*2.0*(double)n_iterations;
}


static double fmopa_za_f32_f32_ilp3(const void*) {
  // FMOPA (FP32), Outer Product (floating-point)
  //
  // Each instruction: (16x f32, 16x f32) → 256x f32 (512 OPs)
  // Total of 1536 OPs per loop iteration, ILP = 3
  size_t n_iterations = N_ITERATIONS/3;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.s                                                  \n"
    "ptrue p1.s                                                  \n"
    "1:                                                          \n"
    "  fmopa za0.s, p0/m, p1/m, z0.s, z0.s                       \n"
    "  fmopa za1.s, p0/m, p1/m, z1.s, z1.s                       \n"
    "  fmopa za2.s, p0/m, p1/m, z2.s, z2.s                       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 512.0*3.0*(double)n_iterations;
}


static double fmopa_za_f32_f32_ilp4(const void*) {
  // FMOPA (FP32), Outer Product (floating-point)
  //
  // Each instruction: (16x f32, 16x f32) → 256x f32 (512 OPs)
  // Total of 2048 OPs per loop iteration, ILP = 4
  size_t n_iterations = N_ITERATIONS/4;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.s                                                  \n"
    "ptrue p1.s                                                  \n"
    "1:                                                          \n"
    "  fmopa za0.s, p0/m, p1/m, z0.s, z0.s                       \n"
    "  fmopa za1.s, p0/m, p1/m, z1.s, z1.s                       \n"
    "  fmopa za2.s, p0/m, p1/m, z2.s, z2.s                       \n"
    "  fmopa za3.s, p0/m, p1/m, z3.s, z3.s                       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 512.0*4.0*(double)n_iterations;
}


static double fmopa_za_f64_f64_ilp1(const void*) {
  // FMOPA (FP64), Outer Product (floating-point)
  //
  // Each instruction: (8x f64, 8x f64) → 64x f64 (128 OPs)
  // Total of 128 OPs per loop iteration, ILP = 1
  size_t n_iterations = N_ITERATIONS;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.d                                                  \n"
    "ptrue p1.d                                                  \n"
    "1:                                                          \n"
    "  fmopa za0.d, p0/m, p1/m, z0.d, z0.d                       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*1.0*(double)n_iterations;
}


static double fmopa_za_f64_f64_ilp2(const void*) {
  // FMOPA (FP64), Outer Product (floating-point)
  //
  // Each instruction: (8x f64, 8x f64) → 64x f64 (128 OPs)
  // Total of 256 OPs per loop iteration, ILP = 2
  size_t n_iterations = N_ITERATIONS/2;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.d                                                  \n"
    "ptrue p1.d                                                  \n"
    "1:                                                          \n"
    "  fmopa za0.d, p0/m, p1/m, z0.d, z0.d                       \n"
    "  fmopa za1.d, p0/m, p1/m, z1.d, z1.d                       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*2.0*(double)n_iterations;
}


static double fmopa_za_f64_f64_ilp3(const void*) {
  // FMOPA (FP64), Outer Product (floating-point)
  //
  // Each instruction: (8x f64, 8x f64) → 64x f64 (128 OPs)
  // Total of 384 OPs per loop iteration, ILP = 3
  size_t n_iterations = N_ITERATIONS/3;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.d                                                  \n"
    "ptrue p1.d                                                  \n"
    "1:                                                          \n"
    "  fmopa za0.d, p0/m, p1/m, z0.d, z0.d                       \n"
    "  fmopa za1.d, p0/m, p1/m, z1.d, z1.d                       \n"
    "  fmopa za2.d, p0/m, p1/m, z2.d, z2.d                       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*3.0*(double)n_iterations;
}


static double fmopa_za_f64_f64_ilp4(const void*) {
  // FMOPA (FP64), Outer Product (floating-point)
  //
  // Each instruction: (8x f64, 8x f64) → 64x f64 (128 OPs)
  // Total of 512 OPs per loop iteration, ILP = 4
  size_t n_iterations = N_ITERATIONS/4;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.d                                                  \n"
    "ptrue p1.d                                                  \n"
    "1:                                                          \n"
    "  fmopa za0.d, p0/m, p1/m, z0.d, z0.d                       \n"
    "  fmopa za1.d, p0/m, p1/m, z1.d, z1.d                       \n"
    "  fmopa za2.d, p0/m, p1/m, z2.d, z2.d                       \n"
    "  fmopa za3.d, p0/m, p1/m, z3.d, z3.d                       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*4.0*(double)n_iterations;
}


static double fmopa_za_f64_f64_ilp5(const void*) {
  // FMOPA (FP64), Outer Product (floating-point)
  //
  // Each instruction: (8x f64, 8x f64) → 64x f64 (128 OPs)
  // Total of 640 OPs per loop iteration, ILP = 5
  size_t n_iterations = N_ITERATIONS/5;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.d                                                  \n"
    "ptrue p1.d                                                  \n"
    "1:                                                          \n"
    "  fmopa za0.d, p0/m, p1/m, z0.d, z0.d                       \n"
    "  fmopa za1.d, p0/m, p1/m, z1.d, z1.d                       \n"
    "  fmopa za2.d, p0/m, p1/m, z2.d, z2.d                       \n"
    "  fmopa za3.d, p0/m, p1/m, z3.d, z3.d                       \n"
    "  fmopa za4.d, p0/m, p1/m, z4.d, z4.d                       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*5.0*(double)n_iterations;
}


static double fmopa_za_f64_f64_ilp6(const void*) {
  // FMOPA (FP64), Outer Product (floating-point)
  //
  // Each instruction: (8x f64, 8x f64) → 64x f64 (128 OPs)
  // Total of 768 OPs per loop iteration, ILP = 6
  size_t n_iterations = N_ITERATIONS/6;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.d                                                  \n"
    "ptrue p1.d                                                  \n"
    "1:                                                          \n"
    "  fmopa za0.d, p0/m, p1/m, z0.d, z0.d                       \n"
    "  fmopa za1.d, p0/m, p1/m, z1.d, z1.d                       \n"
    "  fmopa za2.d, p0/m, p1/m, z2.d, z2.d                       \n"
    "  fmopa za3.d, p0/m, p1/m, z3.d, z3.d                       \n"
    "  fmopa za4.d, p0/m, p1/m, z4.d, z4.d                       \n"
    "  fmopa za5.d, p0/m, p1/m, z5.d, z5.d                       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*6.0*(double)n_iterations;
}


static double fmopa_za_f64_f64_ilp7(const void*) {
  // FMOPA (FP64), Outer Product (floating-point)
  //
  // Each instruction: (8x f64, 8x f64) → 64x f64 (128 OPs)
  // Total of 896 OPs per loop iteration, ILP = 7
  size_t n_iterations = N_ITERATIONS/7;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.d                                                  \n"
    "ptrue p1.d                                                  \n"
    "1:                                                          \n"
    "  fmopa za0.d, p0/m, p1/m, z0.d, z0.d                       \n"
    "  fmopa za1.d, p0/m, p1/m, z1.d, z1.d                       \n"
    "  fmopa za2.d, p0/m, p1/m, z2.d, z2.d                       \n"
    "  fmopa za3.d, p0/m, p1/m, z3.d, z3.d                       \n"
    "  fmopa za4.d, p0/m, p1/m, z4.d, z4.d                       \n"
    "  fmopa za5.d, p0/m, p1/m, z5.d, z5.d                       \n"
    "  fmopa za6.d, p0/m, p1/m, z6.d, z6.d                       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*7.0*(double)n_iterations;
}


static double fmopa_za_f64_f64_ilp8(const void*) {
  // FMOPA (FP64), Outer Product (floating-point)
  //
  // Each instruction: (8x f64, 8x f64) → 64x f64 (128 OPs)
  // Total of 1024 OPs per loop iteration, ILP = 8
  size_t n_iterations = N_ITERATIONS/8;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.d                                                  \n"
    "ptrue p1.d                                                  \n"
    "1:                                                          \n"
    "  fmopa za0.d, p0/m, p1/m, z0.d, z0.d                       \n"
    "  fmopa za1.d, p0/m, p1/m, z1.d, z1.d                       \n"
    "  fmopa za2.d, p0/m, p1/m, z2.d, z2.d                       \n"
    "  fmopa za3.d, p0/m, p1/m, z3.d, z3.d                       \n"
    "  fmopa za4.d, p0/m, p1/m, z4.d, z4.d                       \n"
    "  fmopa za5.d, p0/m, p1/m, z5.d, z5.d                       \n"
    "  fmopa za6.d, p0/m, p1/m, z6.d, z6.d                       \n"
    "  fmopa za7.d, p0/m, p1/m, z7.d, z7.d                       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 128.0*8.0*(double)n_iterations;
}


static double fmopa_za_f32_f16_ilp1(const void*) {
  // FMOPA (FP16 into FP32, 2-way), Outer Product (floating-point)
  //
  // Each instruction: (32x f16, 32x f16) → 256x f32 (1024 OPs)
  // Total of 1024 OPs per loop iteration, ILP = 1
  size_t n_iterations = N_ITERATIONS;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.s                                                  \n"
    "ptrue p1.s                                                  \n"
    "1:                                                          \n"
    "  fmopa za0.s, p0/m, p1/m, z0.h, z0.h                       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 1024.0*1.0*(double)n_iterations;
}


static double fmopa_za_f32_f16_ilp2(const void*) {
  // FMOPA (FP16 into FP32, 2-way), Outer Product (floating-point)
  //
  // Each instruction: (32x f16, 32x f16) → 256x f32 (1024 OPs)
  // Total of 2048 OPs per loop iteration, ILP = 2
  size_t n_iterations = N_ITERATIONS/2;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.s                                                  \n"
    "ptrue p1.s                                                  \n"
    "1:                                                          \n"
    "  fmopa za0.s, p0/m, p1/m, z0.h, z0.h                       \n"
    "  fmopa za1.s, p0/m, p1/m, z1.h, z1.h                       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 1024.0*2.0*(double)n_iterations;
}


static double fmopa_za_f32_f16_ilp3(const void*) {
  // FMOPA (FP16 into FP32, 2-way), Outer Product (floating-point)
  //
  // Each instruction: (32x f16, 32x f16) → 256x f32 (1024 OPs)
  // Total of 3072 OPs per loop iteration, ILP = 3
  size_t n_iterations = N_ITERATIONS/3;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.s                                                  \n"
    "ptrue p1.s                                                  \n"
    "1:                                                          \n"
    "  fmopa za0.s, p0/m, p1/m, z0.h, z0.h                       \n"
    "  fmopa za1.s, p0/m, p1/m, z1.h, z1.h                       \n"
    "  fmopa za2.s, p0/m, p1/m, z2.h, z2.h                       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 1024.0*3.0*(double)n_iterations;
}


static double fmopa_za_f32_f16_ilp4(const void*) {
  // FMOPA (FP16 into FP32, 2-way), Outer Product (floating-point)
  //
  // Each instruction: (32x f16, 32x f16) → 256x f32 (1024 OPs)
  // Total of 4096 OPs per loop iteration, ILP = 4
  size_t n_iterations = N_ITERATIONS/4;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.s                                                  \n"
    "ptrue p1.s                                                  \n"
    "1:                                                          \n"
    "  fmopa za0.s, p0/m, p1/m, z0.h, z0.h                       \n"
    "  fmopa za1.s, p0/m, p1/m, z1.h, z1.h                       \n"
    "  fmopa za2.s, p0/m, p1/m, z2.h, z2.h                       \n"
    "  fmopa za3.s, p0/m, p1/m, z3.h, z3.h                       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 1024.0*4.0*(double)n_iterations;
}


static double bfmopa_za_f32_b16_ilp1(const void*) {
  // BFMOPA (BF16 into FP32, 2-way), Outer Product (floating-point)
  //
  // Each instruction: (32x b16, 32x b16) → 256x f32 (1024 OPs)
  // Total of 1024 OPs per loop iteration, ILP = 1
  size_t n_iterations = N_ITERATIONS;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.s                                                  \n"
    "ptrue p1.s                                                  \n"
    "1:                                                          \n"
    "  bfmopa za0.s, p0/m, p1/m, z0.h, z0.h                      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 1024.0*1.0*(double)n_iterations;
}


static double bfmopa_za_f32_b16_ilp2(const void*) {
  // BFMOPA (BF16 into FP32, 2-way), Outer Product (floating-point)
  //
  // Each instruction: (32x b16, 32x b16) → 256x f32 (1024 OPs)
  // Total of 2048 OPs per loop iteration, ILP = 2
  size_t n_iterations = N_ITERATIONS/2;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.s                                                  \n"
    "ptrue p1.s                                                  \n"
    "1:                                                          \n"
    "  bfmopa za0.s, p0/m, p1/m, z0.h, z0.h                      \n"
    "  bfmopa za1.s, p0/m, p1/m, z1.h, z1.h                      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 1024.0*2.0*(double)n_iterations;
}


static double bfmopa_za_f32_b16_ilp3(const void*) {
  // BFMOPA (BF16 into FP32, 2-way), Outer Product (floating-point)
  //
  // Each instruction: (32x b16, 32x b16) → 256x f32 (1024 OPs)
  // Total of 3072 OPs per loop iteration, ILP = 3
  size_t n_iterations = N_ITERATIONS/3;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.s                                                  \n"
    "ptrue p1.s                                                  \n"
    "1:                                                          \n"
    "  bfmopa za0.s, p0/m, p1/m, z0.h, z0.h                      \n"
    "  bfmopa za1.s, p0/m, p1/m, z1.h, z1.h                      \n"
    "  bfmopa za2.s, p0/m, p1/m, z2.h, z2.h                      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 1024.0*3.0*(double)n_iterations;
}


static double bfmopa_za_f32_b16_ilp4(const void*) {
  // BFMOPA (BF16 into FP32, 2-way), Outer Product (floating-point)
  //
  // Each instruction: (32x b16, 32x b16) → 256x f32 (1024 OPs)
  // Total of 4096 OPs per loop iteration, ILP = 4
  size_t n_iterations = N_ITERATIONS/4;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.s                                                  \n"
    "ptrue p1.s                                                  \n"
    "1:                                                          \n"
    "  bfmopa za0.s, p0/m, p1/m, z0.h, z0.h                      \n"
    "  bfmopa za1.s, p0/m, p1/m, z1.h, z1.h                      \n"
    "  bfmopa za2.s, p0/m, p1/m, z2.h, z2.h                      \n"
    "  bfmopa za3.s, p0/m, p1/m, z3.h, z3.h                      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 1024.0*4.0*(double)n_iterations;
}


static double smopa_za_i32_i16_ilp1(const void*) {
  // SMOPA (I16 into I32, 2-way), Outer Product (integer)
  //
  // Each instruction: (32x i16, 32x i16) → 256x i32 (1024 OPs)
  // Total of 1024 OPs per loop iteration, ILP = 1
  size_t n_iterations = N_ITERATIONS;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.s                                                  \n"
    "ptrue p1.s                                                  \n"
    "1:                                                          \n"
    "  smopa za0.s, p0/m, p1/m, z0.h, z0.h                       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 1024.0*1.0*(double)n_iterations;
}


static double smopa_za_i32_i16_ilp2(const void*) {
  // SMOPA (I16 into I32, 2-way), Outer Product (integer)
  //
  // Each instruction: (32x i16, 32x i16) → 256x i32 (1024 OPs)
  // Total of 2048 OPs per loop iteration, ILP = 2
  size_t n_iterations = N_ITERATIONS/2;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.s                                                  \n"
    "ptrue p1.s                                                  \n"
    "1:                                                          \n"
    "  smopa za0.s, p0/m, p1/m, z0.h, z0.h                       \n"
    "  smopa za1.s, p0/m, p1/m, z1.h, z1.h                       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 1024.0*2.0*(double)n_iterations;
}


static double smopa_za_i32_i16_ilp3(const void*) {
  // SMOPA (I16 into I32, 2-way), Outer Product (integer)
  //
  // Each instruction: (32x i16, 32x i16) → 256x i32 (1024 OPs)
  // Total of 3072 OPs per loop iteration, ILP = 3
  size_t n_iterations = N_ITERATIONS/3;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.s                                                  \n"
    "ptrue p1.s                                                  \n"
    "1:                                                          \n"
    "  smopa za0.s, p0/m, p1/m, z0.h, z0.h                       \n"
    "  smopa za1.s, p0/m, p1/m, z1.h, z1.h                       \n"
    "  smopa za2.s, p0/m, p1/m, z2.h, z2.h                       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 1024.0*3.0*(double)n_iterations;
}


static double smopa_za_i32_i16_ilp4(const void*) {
  // SMOPA (I16 into I32, 2-way), Outer Product (integer)
  //
  // Each instruction: (32x i16, 32x i16) → 256x i32 (1024 OPs)
  // Total of 4096 OPs per loop iteration, ILP = 4
  size_t n_iterations = N_ITERATIONS/4;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.s                                                  \n"
    "ptrue p1.s                                                  \n"
    "1:                                                          \n"
    "  smopa za0.s, p0/m, p1/m, z0.h, z0.h                       \n"
    "  smopa za1.s, p0/m, p1/m, z1.h, z1.h                       \n"
    "  smopa za2.s, p0/m, p1/m, z2.h, z2.h                       \n"
    "  smopa za3.s, p0/m, p1/m, z3.h, z3.h                       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 1024.0*4.0*(double)n_iterations;
}


static double smopa_za_i32_i8_ilp1(const void*) {
  // SMOPA (I8 into I32, 4-way), Outer Product (integer)
  //
  // Each instruction: (64x i8, 64x i8) → 256x i32 (2048 OPs)
  // Total of 2048 OPs per loop iteration, ILP = 1
  size_t n_iterations = N_ITERATIONS;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.s                                                  \n"
    "ptrue p1.s                                                  \n"
    "1:                                                          \n"
    "  smopa za0.s, p0/m, p1/m, z0.b, z0.b                       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 2048.0*1.0*(double)n_iterations;
}


static double smopa_za_i32_i8_ilp2(const void*) {
  // SMOPA (I8 into I32, 4-way), Outer Product (integer)
  //
  // Each instruction: (64x i8, 64x i8) → 256x i32 (2048 OPs)
  // Total of 4096 OPs per loop iteration, ILP = 2
  size_t n_iterations = N_ITERATIONS/2;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.s                                                  \n"
    "ptrue p1.s                                                  \n"
    "1:                                                          \n"
    "  smopa za0.s, p0/m, p1/m, z0.b, z0.b                       \n"
    "  smopa za1.s, p0/m, p1/m, z1.b, z1.b                       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 2048.0*2.0*(double)n_iterations;
}


static double smopa_za_i32_i8_ilp3(const void*) {
  // SMOPA (I8 into I32, 4-way), Outer Product (integer)
  //
  // Each instruction: (64x i8, 64x i8) → 256x i32 (2048 OPs)
  // Total of 6144 OPs per loop iteration, ILP = 3
  size_t n_iterations = N_ITERATIONS/3;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.s                                                  \n"
    "ptrue p1.s                                                  \n"
    "1:                                                          \n"
    "  smopa za0.s, p0/m, p1/m, z0.b, z0.b                       \n"
    "  smopa za1.s, p0/m, p1/m, z1.b, z1.b                       \n"
    "  smopa za2.s, p0/m, p1/m, z2.b, z2.b                       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 2048.0*3.0*(double)n_iterations;
}


static double smopa_za_i32_i8_ilp4(const void*) {
  // SMOPA (I8 into I32, 4-way), Outer Product (integer)
  //
  // Each instruction: (64x i8, 64x i8) → 256x i32 (2048 OPs)
  // Total of 8192 OPs per loop iteration, ILP = 4
  size_t n_iterations = N_ITERATIONS/4;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.s                                                  \n"
    "ptrue p1.s                                                  \n"
    "1:                                                          \n"
    "  smopa za0.s, p0/m, p1/m, z0.b, z0.b                       \n"
    "  smopa za1.s, p0/m, p1/m, z1.b, z1.b                       \n"
    "  smopa za2.s, p0/m, p1/m, z2.b, z2.b                       \n"
    "  smopa za3.s, p0/m, p1/m, z3.b, z3.b                       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 2048.0*4.0*(double)n_iterations;
}


static double smopa_za_i64_i16_ilp1(const void*) {
  // SMOPA (I16 into I64, 4-way), Outer Product (integer)
  //
  // Each instruction: (32x i16, 32x i16) → 64x i64 (512 OPs)
  // Total of 512 OPs per loop iteration, ILP = 1
  size_t n_iterations = N_ITERATIONS;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.d                                                  \n"
    "ptrue p1.d                                                  \n"
    "1:                                                          \n"
    "  smopa za0.d, p0/m, p1/m, z0.h, z0.h                       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 512.0*1.0*(double)n_iterations;
}


static double smopa_za_i64_i16_ilp2(const void*) {
  // SMOPA (I16 into I64, 4-way), Outer Product (integer)
  //
  // Each instruction: (32x i16, 32x i16) → 64x i64 (512 OPs)
  // Total of 1024 OPs per loop iteration, ILP = 2
  size_t n_iterations = N_ITERATIONS/2;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.d                                                  \n"
    "ptrue p1.d                                                  \n"
    "1:                                                          \n"
    "  smopa za0.d, p0/m, p1/m, z0.h, z0.h                       \n"
    "  smopa za1.d, p0/m, p1/m, z1.h, z1.h                       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 512.0*2.0*(double)n_iterations;
}


static double smopa_za_i64_i16_ilp3(const void*) {
  // SMOPA (I16 into I64, 4-way), Outer Product (integer)
  //
  // Each instruction: (32x i16, 32x i16) → 64x i64 (512 OPs)
  // Total of 1536 OPs per loop iteration, ILP = 3
  size_t n_iterations = N_ITERATIONS/3;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.d                                                  \n"
    "ptrue p1.d                                                  \n"
    "1:                                                          \n"
    "  smopa za0.d, p0/m, p1/m, z0.h, z0.h                       \n"
    "  smopa za1.d, p0/m, p1/m, z1.h, z1.h                       \n"
    "  smopa za2.d, p0/m, p1/m, z2.h, z2.h                       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 512.0*3.0*(double)n_iterations;
}


static double smopa_za_i64_i16_ilp4(const void*) {
  // SMOPA (I16 into I64, 4-way), Outer Product (integer)
  //
  // Each instruction: (32x i16, 32x i16) → 64x i64 (512 OPs)
  // Total of 2048 OPs per loop iteration, ILP = 4
  size_t n_iterations = N_ITERATIONS/4;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.d                                                  \n"
    "ptrue p1.d                                                  \n"
    "1:                                                          \n"
    "  smopa za0.d, p0/m, p1/m, z0.h, z0.h                       \n"
    "  smopa za1.d, p0/m, p1/m, z1.h, z1.h                       \n"
    "  smopa za2.d, p0/m, p1/m, z2.h, z2.h                       \n"
    "  smopa za3.d, p0/m, p1/m, z3.h, z3.h                       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 512.0*4.0*(double)n_iterations;
}


static double smopa_za_i64_i16_ilp5(const void*) {
  // SMOPA (I16 into I64, 4-way), Outer Product (integer)
  //
  // Each instruction: (32x i16, 32x i16) → 64x i64 (512 OPs)
  // Total of 2560 OPs per loop iteration, ILP = 5
  size_t n_iterations = N_ITERATIONS/5;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.d                                                  \n"
    "ptrue p1.d                                                  \n"
    "1:                                                          \n"
    "  smopa za0.d, p0/m, p1/m, z0.h, z0.h                       \n"
    "  smopa za1.d, p0/m, p1/m, z1.h, z1.h                       \n"
    "  smopa za2.d, p0/m, p1/m, z2.h, z2.h                       \n"
    "  smopa za3.d, p0/m, p1/m, z3.h, z3.h                       \n"
    "  smopa za4.d, p0/m, p1/m, z4.h, z4.h                       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 512.0*5.0*(double)n_iterations;
}


static double smopa_za_i64_i16_ilp6(const void*) {
  // SMOPA (I16 into I64, 4-way), Outer Product (integer)
  //
  // Each instruction: (32x i16, 32x i16) → 64x i64 (512 OPs)
  // Total of 3072 OPs per loop iteration, ILP = 6
  size_t n_iterations = N_ITERATIONS/6;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.d                                                  \n"
    "ptrue p1.d                                                  \n"
    "1:                                                          \n"
    "  smopa za0.d, p0/m, p1/m, z0.h, z0.h                       \n"
    "  smopa za1.d, p0/m, p1/m, z1.h, z1.h                       \n"
    "  smopa za2.d, p0/m, p1/m, z2.h, z2.h                       \n"
    "  smopa za3.d, p0/m, p1/m, z3.h, z3.h                       \n"
    "  smopa za4.d, p0/m, p1/m, z4.h, z4.h                       \n"
    "  smopa za5.d, p0/m, p1/m, z5.h, z5.h                       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 512.0*6.0*(double)n_iterations;
}


static double smopa_za_i64_i16_ilp7(const void*) {
  // SMOPA (I16 into I64, 4-way), Outer Product (integer)
  //
  // Each instruction: (32x i16, 32x i16) → 64x i64 (512 OPs)
  // Total of 3584 OPs per loop iteration, ILP = 7
  size_t n_iterations = N_ITERATIONS/7;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.d                                                  \n"
    "ptrue p1.d                                                  \n"
    "1:                                                          \n"
    "  smopa za0.d, p0/m, p1/m, z0.h, z0.h                       \n"
    "  smopa za1.d, p0/m, p1/m, z1.h, z1.h                       \n"
    "  smopa za2.d, p0/m, p1/m, z2.h, z2.h                       \n"
    "  smopa za3.d, p0/m, p1/m, z3.h, z3.h                       \n"
    "  smopa za4.d, p0/m, p1/m, z4.h, z4.h                       \n"
    "  smopa za5.d, p0/m, p1/m, z5.h, z5.h                       \n"
    "  smopa za6.d, p0/m, p1/m, z6.h, z6.h                       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 512.0*7.0*(double)n_iterations;
}


static double smopa_za_i64_i16_ilp8(const void*) {
  // SMOPA (I16 into I64, 4-way), Outer Product (integer)
  //
  // Each instruction: (32x i16, 32x i16) → 64x i64 (512 OPs)
  // Total of 4096 OPs per loop iteration, ILP = 8
  size_t n_iterations = N_ITERATIONS/8;

  __asm__ __volatile__ (
    "smstart                                                     \n"
    "mov x0, %[n]                                                \n"
    "ptrue p0.d                                                  \n"
    "ptrue p1.d                                                  \n"
    "1:                                                          \n"
    "  smopa za0.d, p0/m, p1/m, z0.h, z0.h                       \n"
    "  smopa za1.d, p0/m, p1/m, z1.h, z1.h                       \n"
    "  smopa za2.d, p0/m, p1/m, z2.h, z2.h                       \n"
    "  smopa za3.d, p0/m, p1/m, z3.h, z3.h                       \n"
    "  smopa za4.d, p0/m, p1/m, z4.h, z4.h                       \n"
    "  smopa za5.d, p0/m, p1/m, z5.h, z5.h                       \n"
    "  smopa za6.d, p0/m, p1/m, z6.h, z6.h                       \n"
    "  smopa za7.d, p0/m, p1/m, z7.h, z7.h                       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne 1b                                                   \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (n_iterations)
    : "x0"
  );

  // number of OPS executed (ops_per_instruction*ILP*iterations)
  return 512.0*8.0*(double)n_iterations;
}


// benchmark setup
static void* setup(const void* params) {
  assert(params == nullptr);
  return nullptr;
}

static void teardown(void* data) {
  assert(data == nullptr);
}

// benchmark table
static const op_benchmark_t benchmarks[] = {
  {{ &setup, &fdot_f32_f16_ilp1, &teardown }, "Dot Product (floating-point)", "FDOT (FP16 to FP32, 2-way, one vector)", "FEAT_SME2", "z-register", "fdot", "f32", 16, 1, "f16", 64, 2, 64, 1},
  {{ &setup, &fdot_f32_f16_ilp2, &teardown }, "Dot Product (floating-point)", "FDOT (FP16 to FP32, 2-way, one vector)", "FEAT_SME2", "z-register", "fdot", "f32", 16, 1, "f16", 64, 2, 64, 2},
  {{ &setup, &fdot_f32_f16_ilp3, &teardown }, "Dot Product (floating-point)", "FDOT (FP16 to FP32, 2-way, one vector)", "FEAT_SME2", "z-register", "fdot", "f32", 16, 1, "f16", 64, 2, 64, 3},
  {{ &setup, &fdot_f32_f16_ilp4, &teardown }, "Dot Product (floating-point)", "FDOT (FP16 to FP32, 2-way, one vector)", "FEAT_SME2", "z-register", "fdot", "f32", 16, 1, "f16", 64, 2, 64, 4},
  {{ &setup, &fdot_f32_f16_ilp5, &teardown }, "Dot Product (floating-point)", "FDOT (FP16 to FP32, 2-way, one vector)", "FEAT_SME2", "z-register", "fdot", "f32", 16, 1, "f16", 64, 2, 64, 5},
  {{ &setup, &fdot_f32_f16_ilp6, &teardown }, "Dot Product (floating-point)", "FDOT (FP16 to FP32, 2-way, one vector)", "FEAT_SME2", "z-register", "fdot", "f32", 16, 1, "f16", 64, 2, 64, 6},
  {{ &setup, &fdot_f32_f16_ilp7, &teardown }, "Dot Product (floating-point)", "FDOT (FP16 to FP32, 2-way, one vector)", "FEAT_SME2", "z-register", "fdot", "f32", 16, 1, "f16", 64, 2, 64, 7},
  {{ &setup, &fdot_f32_f16_ilp8, &teardown }, "Dot Product (floating-point)", "FDOT (FP16 to FP32, 2-way, one vector)", "FEAT_SME2", "z-register", "fdot", "f32", 16, 1, "f16", 64, 2, 64, 8},
  {{ &setup, &fdot_f32_f16_ilp9, &teardown }, "Dot Product (floating-point)", "FDOT (FP16 to FP32, 2-way, one vector)", "FEAT_SME2", "z-register", "fdot", "f32", 16, 1, "f16", 64, 2, 64, 9},
  {{ &setup, &fdot_f32_f16_ilp10, &teardown }, "Dot Product (floating-point)", "FDOT (FP16 to FP32, 2-way, one vector)", "FEAT_SME2", "z-register", "fdot", "f32", 16, 1, "f16", 64, 2, 64, 10},
  {{ &setup, &fdot_f32_f16_ilp11, &teardown }, "Dot Product (floating-point)", "FDOT (FP16 to FP32, 2-way, one vector)", "FEAT_SME2", "z-register", "fdot", "f32", 16, 1, "f16", 64, 2, 64, 11},
  {{ &setup, &fdot_f32_f16_ilp12, &teardown }, "Dot Product (floating-point)", "FDOT (FP16 to FP32, 2-way, one vector)", "FEAT_SME2", "z-register", "fdot", "f32", 16, 1, "f16", 64, 2, 64, 12},
  {{ &setup, &fdot_f32_f16_ilp13, &teardown }, "Dot Product (floating-point)", "FDOT (FP16 to FP32, 2-way, one vector)", "FEAT_SME2", "z-register", "fdot", "f32", 16, 1, "f16", 64, 2, 64, 13},
  {{ &setup, &fdot_f32_f16_ilp14, &teardown }, "Dot Product (floating-point)", "FDOT (FP16 to FP32, 2-way, one vector)", "FEAT_SME2", "z-register", "fdot", "f32", 16, 1, "f16", 64, 2, 64, 14},
  {{ &setup, &fdot_f32_f16_ilp15, &teardown }, "Dot Product (floating-point)", "FDOT (FP16 to FP32, 2-way, one vector)", "FEAT_SME2", "z-register", "fdot", "f32", 16, 1, "f16", 64, 2, 64, 15},
  {{ &setup, &fdot_f32_f16_ilp16, &teardown }, "Dot Product (floating-point)", "FDOT (FP16 to FP32, 2-way, one vector)", "FEAT_SME2", "z-register", "fdot", "f32", 16, 1, "f16", 64, 2, 64, 16},
  {{ &setup, &bfdot_f32_b16_ilp1, &teardown }, "Dot Product (floating-point)", "BFDOT (BF16 to FP32, 2-way, one vector)", "FEAT_SME2", "z-register", "bfdot", "f32", 16, 1, "b16", 64, 2, 64, 1},
  {{ &setup, &bfdot_f32_b16_ilp2, &teardown }, "Dot Product (floating-point)", "BFDOT (BF16 to FP32, 2-way, one vector)", "FEAT_SME2", "z-register", "bfdot", "f32", 16, 1, "b16", 64, 2, 64, 2},
  {{ &setup, &bfdot_f32_b16_ilp3, &teardown }, "Dot Product (floating-point)", "BFDOT (BF16 to FP32, 2-way, one vector)", "FEAT_SME2", "z-register", "bfdot", "f32", 16, 1, "b16", 64, 2, 64, 3},
  {{ &setup, &bfdot_f32_b16_ilp4, &teardown }, "Dot Product (floating-point)", "BFDOT (BF16 to FP32, 2-way, one vector)", "FEAT_SME2", "z-register", "bfdot", "f32", 16, 1, "b16", 64, 2, 64, 4},
  {{ &setup, &bfdot_f32_b16_ilp5, &teardown }, "Dot Product (floating-point)", "BFDOT (BF16 to FP32, 2-way, one vector)", "FEAT_SME2", "z-register", "bfdot", "f32", 16, 1, "b16", 64, 2, 64, 5},
  {{ &setup, &bfdot_f32_b16_ilp6, &teardown }, "Dot Product (floating-point)", "BFDOT (BF16 to FP32, 2-way, one vector)", "FEAT_SME2", "z-register", "bfdot", "f32", 16, 1, "b16", 64, 2, 64, 6},
  {{ &setup, &bfdot_f32_b16_ilp7, &teardown }, "Dot Product (floating-point)", "BFDOT (BF16 to FP32, 2-way, one vector)", "FEAT_SME2", "z-register", "bfdot", "f32", 16, 1, "b16", 64, 2, 64, 7},
  {{ &setup, &bfdot_f32_b16_ilp8, &teardown }, "Dot Product (floating-point)", "BFDOT (BF16 to FP32, 2-way, one vector)", "FEAT_SME2", "z-register", "bfdot", "f32", 16, 1, "b16", 64, 2, 64, 8},
  {{ &setup, &bfdot_f32_b16_ilp9, &teardown }, "Dot Product (floating-point)", "BFDOT (BF16 to FP32, 2-way, one vector)", "FEAT_SME2", "z-register", "bfdot", "f32", 16, 1, "b16", 64, 2, 64, 9},
  {{ &setup, &bfdot_f32_b16_ilp10, &teardown }, "Dot Product (floating-point)", "BFDOT (BF16 to FP32, 2-way, one vector)", "FEAT_SME2", "z-register", "bfdot", "f32", 16, 1, "b16", 64, 2, 64, 10},
  {{ &setup, &bfdot_f32_b16_ilp11, &teardown }, "Dot Product (floating-point)", "BFDOT (BF16 to FP32, 2-way, one vector)", "FEAT_SME2", "z-register", "bfdot", "f32", 16, 1, "b16", 64, 2, 64, 11},
  {{ &setup, &bfdot_f32_b16_ilp12, &teardown }, "Dot Product (floating-point)", "BFDOT (BF16 to FP32, 2-way, one vector)", "FEAT_SME2", "z-register", "bfdot", "f32", 16, 1, "b16", 64, 2, 64, 12},
  {{ &setup, &bfdot_f32_b16_ilp13, &teardown }, "Dot Product (floating-point)", "BFDOT (BF16 to FP32, 2-way, one vector)", "FEAT_SME2", "z-register", "bfdot", "f32", 16, 1, "b16", 64, 2, 64, 13},
  {{ &setup, &bfdot_f32_b16_ilp14, &teardown }, "Dot Product (floating-point)", "BFDOT (BF16 to FP32, 2-way, one vector)", "FEAT_SME2", "z-register", "bfdot", "f32", 16, 1, "b16", 64, 2, 64, 14},
  {{ &setup, &bfdot_f32_b16_ilp15, &teardown }, "Dot Product (floating-point)", "BFDOT (BF16 to FP32, 2-way, one vector)", "FEAT_SME2", "z-register", "bfdot", "f32", 16, 1, "b16", 64, 2, 64, 15},
  {{ &setup, &bfdot_f32_b16_ilp16, &teardown }, "Dot Product (floating-point)", "BFDOT (BF16 to FP32, 2-way, one vector)", "FEAT_SME2", "z-register", "bfdot", "f32", 16, 1, "b16", 64, 2, 64, 16},
  {{ &setup, &fdot_za_f32_f16_vgx2_ilp1, &teardown }, "Dot Product (floating-point)", "FDOT (FP16 to FP32, 2-way, two vectors)", "FEAT_SME2", "za-vector", "fdot", "f32", 32, 2, "f16", 128, 4, 128, 1},
  {{ &setup, &fdot_za_f32_f16_vgx2_ilp2, &teardown }, "Dot Product (floating-point)", "FDOT (FP16 to FP32, 2-way, two vectors)", "FEAT_SME2", "za-vector", "fdot", "f32", 32, 2, "f16", 128, 4, 128, 2},
  {{ &setup, &fdot_za_f32_f16_vgx2_ilp3, &teardown }, "Dot Product (floating-point)", "FDOT (FP16 to FP32, 2-way, two vectors)", "FEAT_SME2", "za-vector", "fdot", "f32", 32, 2, "f16", 128, 4, 128, 3},
  {{ &setup, &fdot_za_f32_f16_vgx2_ilp4, &teardown }, "Dot Product (floating-point)", "FDOT (FP16 to FP32, 2-way, two vectors)", "FEAT_SME2", "za-vector", "fdot", "f32", 32, 2, "f16", 128, 4, 128, 4},
  {{ &setup, &fdot_za_f32_f16_vgx2_ilp5, &teardown }, "Dot Product (floating-point)", "FDOT (FP16 to FP32, 2-way, two vectors)", "FEAT_SME2", "za-vector", "fdot", "f32", 32, 2, "f16", 128, 4, 128, 5},
  {{ &setup, &fdot_za_f32_f16_vgx2_ilp6, &teardown }, "Dot Product (floating-point)", "FDOT (FP16 to FP32, 2-way, two vectors)", "FEAT_SME2", "za-vector", "fdot", "f32", 32, 2, "f16", 128, 4, 128, 6},
  {{ &setup, &fdot_za_f32_f16_vgx2_ilp7, &teardown }, "Dot Product (floating-point)", "FDOT (FP16 to FP32, 2-way, two vectors)", "FEAT_SME2", "za-vector", "fdot", "f32", 32, 2, "f16", 128, 4, 128, 7},
  {{ &setup, &fdot_za_f32_f16_vgx2_ilp8, &teardown }, "Dot Product (floating-point)", "FDOT (FP16 to FP32, 2-way, two vectors)", "FEAT_SME2", "za-vector", "fdot", "f32", 32, 2, "f16", 128, 4, 128, 8},
  {{ &setup, &fdot_za_f32_f16_vgx2_ilp9, &teardown }, "Dot Product (floating-point)", "FDOT (FP16 to FP32, 2-way, two vectors)", "FEAT_SME2", "za-vector", "fdot", "f32", 32, 2, "f16", 128, 4, 128, 9},
  {{ &setup, &fdot_za_f32_f16_vgx2_ilp10, &teardown }, "Dot Product (floating-point)", "FDOT (FP16 to FP32, 2-way, two vectors)", "FEAT_SME2", "za-vector", "fdot", "f32", 32, 2, "f16", 128, 4, 128, 10},
  {{ &setup, &fdot_za_f32_f16_vgx2_ilp11, &teardown }, "Dot Product (floating-point)", "FDOT (FP16 to FP32, 2-way, two vectors)", "FEAT_SME2", "za-vector", "fdot", "f32", 32, 2, "f16", 128, 4, 128, 11},
  {{ &setup, &fdot_za_f32_f16_vgx2_ilp12, &teardown }, "Dot Product (floating-point)", "FDOT (FP16 to FP32, 2-way, two vectors)", "FEAT_SME2", "za-vector", "fdot", "f32", 32, 2, "f16", 128, 4, 128, 12},
  {{ &setup, &fdot_za_f32_f16_vgx2_ilp13, &teardown }, "Dot Product (floating-point)", "FDOT (FP16 to FP32, 2-way, two vectors)", "FEAT_SME2", "za-vector", "fdot", "f32", 32, 2, "f16", 128, 4, 128, 13},
  {{ &setup, &fdot_za_f32_f16_vgx2_ilp14, &teardown }, "Dot Product (floating-point)", "FDOT (FP16 to FP32, 2-way, two vectors)", "FEAT_SME2", "za-vector", "fdot", "f32", 32, 2, "f16", 128, 4, 128, 14},
  {{ &setup, &fdot_za_f32_f16_vgx2_ilp15, &teardown }, "Dot Product (floating-point)", "FDOT (FP16 to FP32, 2-way, two vectors)", "FEAT_SME2", "za-vector", "fdot", "f32", 32, 2, "f16", 128, 4, 128, 15},
  {{ &setup, &fdot_za_f32_f16_vgx2_ilp16, &teardown }, "Dot Product (floating-point)", "FDOT (FP16 to FP32, 2-way, two vectors)", "FEAT_SME2", "za-vector", "fdot", "f32", 32, 2, "f16", 128, 4, 128, 16},
  {{ &setup, &fdot_za_f32_f16_vgx4_ilp1, &teardown }, "Dot Product (floating-point)", "FDOT (FP16 to FP32, 2-way, four vectors)", "FEAT_SME2", "za-vector", "fdot", "f32", 64, 4, "f16", 256, 8, 256, 1},
  {{ &setup, &fdot_za_f32_f16_vgx4_ilp2, &teardown }, "Dot Product (floating-point)", "FDOT (FP16 to FP32, 2-way, four vectors)", "FEAT_SME2", "za-vector", "fdot", "f32", 64, 4, "f16", 256, 8, 256, 2},
  {{ &setup, &fdot_za_f32_f16_vgx4_ilp3, &teardown }, "Dot Product (floating-point)", "FDOT (FP16 to FP32, 2-way, four vectors)", "FEAT_SME2", "za-vector", "fdot", "f32", 64, 4, "f16", 256, 8, 256, 3},
  {{ &setup, &fdot_za_f32_f16_vgx4_ilp4, &teardown }, "Dot Product (floating-point)", "FDOT (FP16 to FP32, 2-way, four vectors)", "FEAT_SME2", "za-vector", "fdot", "f32", 64, 4, "f16", 256, 8, 256, 4},
  {{ &setup, &fdot_za_f32_f16_vgx4_ilp5, &teardown }, "Dot Product (floating-point)", "FDOT (FP16 to FP32, 2-way, four vectors)", "FEAT_SME2", "za-vector", "fdot", "f32", 64, 4, "f16", 256, 8, 256, 5},
  {{ &setup, &fdot_za_f32_f16_vgx4_ilp6, &teardown }, "Dot Product (floating-point)", "FDOT (FP16 to FP32, 2-way, four vectors)", "FEAT_SME2", "za-vector", "fdot", "f32", 64, 4, "f16", 256, 8, 256, 6},
  {{ &setup, &fdot_za_f32_f16_vgx4_ilp7, &teardown }, "Dot Product (floating-point)", "FDOT (FP16 to FP32, 2-way, four vectors)", "FEAT_SME2", "za-vector", "fdot", "f32", 64, 4, "f16", 256, 8, 256, 7},
  {{ &setup, &fdot_za_f32_f16_vgx4_ilp8, &teardown }, "Dot Product (floating-point)", "FDOT (FP16 to FP32, 2-way, four vectors)", "FEAT_SME2", "za-vector", "fdot", "f32", 64, 4, "f16", 256, 8, 256, 8},
  {{ &setup, &fdot_za_f32_f16_vgx4_ilp9, &teardown }, "Dot Product (floating-point)", "FDOT (FP16 to FP32, 2-way, four vectors)", "FEAT_SME2", "za-vector", "fdot", "f32", 64, 4, "f16", 256, 8, 256, 9},
  {{ &setup, &fdot_za_f32_f16_vgx4_ilp10, &teardown }, "Dot Product (floating-point)", "FDOT (FP16 to FP32, 2-way, four vectors)", "FEAT_SME2", "za-vector", "fdot", "f32", 64, 4, "f16", 256, 8, 256, 10},
  {{ &setup, &fdot_za_f32_f16_vgx4_ilp11, &teardown }, "Dot Product (floating-point)", "FDOT (FP16 to FP32, 2-way, four vectors)", "FEAT_SME2", "za-vector", "fdot", "f32", 64, 4, "f16", 256, 8, 256, 11},
  {{ &setup, &fdot_za_f32_f16_vgx4_ilp12, &teardown }, "Dot Product (floating-point)", "FDOT (FP16 to FP32, 2-way, four vectors)", "FEAT_SME2", "za-vector", "fdot", "f32", 64, 4, "f16", 256, 8, 256, 12},
  {{ &setup, &fdot_za_f32_f16_vgx4_ilp13, &teardown }, "Dot Product (floating-point)", "FDOT (FP16 to FP32, 2-way, four vectors)", "FEAT_SME2", "za-vector", "fdot", "f32", 64, 4, "f16", 256, 8, 256, 13},
  {{ &setup, &fdot_za_f32_f16_vgx4_ilp14, &teardown }, "Dot Product (floating-point)", "FDOT (FP16 to FP32, 2-way, four vectors)", "FEAT_SME2", "za-vector", "fdot", "f32", 64, 4, "f16", 256, 8, 256, 14},
  {{ &setup, &fdot_za_f32_f16_vgx4_ilp15, &teardown }, "Dot Product (floating-point)", "FDOT (FP16 to FP32, 2-way, four vectors)", "FEAT_SME2", "za-vector", "fdot", "f32", 64, 4, "f16", 256, 8, 256, 15},
  {{ &setup, &fdot_za_f32_f16_vgx4_ilp16, &teardown }, "Dot Product (floating-point)", "FDOT (FP16 to FP32, 2-way, four vectors)", "FEAT_SME2", "za-vector", "fdot", "f32", 64, 4, "f16", 256, 8, 256, 16},
  {{ &setup, &bfdot_za_f32_b16_vgx2_ilp1, &teardown }, "Dot Product (floating-point)", "BFDOT (BF16 to FP32, 2-way, two vectors)", "FEAT_SME2", "za-vector", "bfdot", "f32", 32, 2, "b16", 128, 4, 128, 1},
  {{ &setup, &bfdot_za_f32_b16_vgx2_ilp2, &teardown }, "Dot Product (floating-point)", "BFDOT (BF16 to FP32, 2-way, two vectors)", "FEAT_SME2", "za-vector", "bfdot", "f32", 32, 2, "b16", 128, 4, 128, 2},
  {{ &setup, &bfdot_za_f32_b16_vgx2_ilp3, &teardown }, "Dot Product (floating-point)", "BFDOT (BF16 to FP32, 2-way, two vectors)", "FEAT_SME2", "za-vector", "bfdot", "f32", 32, 2, "b16", 128, 4, 128, 3},
  {{ &setup, &bfdot_za_f32_b16_vgx2_ilp4, &teardown }, "Dot Product (floating-point)", "BFDOT (BF16 to FP32, 2-way, two vectors)", "FEAT_SME2", "za-vector", "bfdot", "f32", 32, 2, "b16", 128, 4, 128, 4},
  {{ &setup, &bfdot_za_f32_b16_vgx2_ilp5, &teardown }, "Dot Product (floating-point)", "BFDOT (BF16 to FP32, 2-way, two vectors)", "FEAT_SME2", "za-vector", "bfdot", "f32", 32, 2, "b16", 128, 4, 128, 5},
  {{ &setup, &bfdot_za_f32_b16_vgx2_ilp6, &teardown }, "Dot Product (floating-point)", "BFDOT (BF16 to FP32, 2-way, two vectors)", "FEAT_SME2", "za-vector", "bfdot", "f32", 32, 2, "b16", 128, 4, 128, 6},
  {{ &setup, &bfdot_za_f32_b16_vgx2_ilp7, &teardown }, "Dot Product (floating-point)", "BFDOT (BF16 to FP32, 2-way, two vectors)", "FEAT_SME2", "za-vector", "bfdot", "f32", 32, 2, "b16", 128, 4, 128, 7},
  {{ &setup, &bfdot_za_f32_b16_vgx2_ilp8, &teardown }, "Dot Product (floating-point)", "BFDOT (BF16 to FP32, 2-way, two vectors)", "FEAT_SME2", "za-vector", "bfdot", "f32", 32, 2, "b16", 128, 4, 128, 8},
  {{ &setup, &bfdot_za_f32_b16_vgx2_ilp9, &teardown }, "Dot Product (floating-point)", "BFDOT (BF16 to FP32, 2-way, two vectors)", "FEAT_SME2", "za-vector", "bfdot", "f32", 32, 2, "b16", 128, 4, 128, 9},
  {{ &setup, &bfdot_za_f32_b16_vgx2_ilp10, &teardown }, "Dot Product (floating-point)", "BFDOT (BF16 to FP32, 2-way, two vectors)", "FEAT_SME2", "za-vector", "bfdot", "f32", 32, 2, "b16", 128, 4, 128, 10},
  {{ &setup, &bfdot_za_f32_b16_vgx2_ilp11, &teardown }, "Dot Product (floating-point)", "BFDOT (BF16 to FP32, 2-way, two vectors)", "FEAT_SME2", "za-vector", "bfdot", "f32", 32, 2, "b16", 128, 4, 128, 11},
  {{ &setup, &bfdot_za_f32_b16_vgx2_ilp12, &teardown }, "Dot Product (floating-point)", "BFDOT (BF16 to FP32, 2-way, two vectors)", "FEAT_SME2", "za-vector", "bfdot", "f32", 32, 2, "b16", 128, 4, 128, 12},
  {{ &setup, &bfdot_za_f32_b16_vgx2_ilp13, &teardown }, "Dot Product (floating-point)", "BFDOT (BF16 to FP32, 2-way, two vectors)", "FEAT_SME2", "za-vector", "bfdot", "f32", 32, 2, "b16", 128, 4, 128, 13},
  {{ &setup, &bfdot_za_f32_b16_vgx2_ilp14, &teardown }, "Dot Product (floating-point)", "BFDOT (BF16 to FP32, 2-way, two vectors)", "FEAT_SME2", "za-vector", "bfdot", "f32", 32, 2, "b16", 128, 4, 128, 14},
  {{ &setup, &bfdot_za_f32_b16_vgx2_ilp15, &teardown }, "Dot Product (floating-point)", "BFDOT (BF16 to FP32, 2-way, two vectors)", "FEAT_SME2", "za-vector", "bfdot", "f32", 32, 2, "b16", 128, 4, 128, 15},
  {{ &setup, &bfdot_za_f32_b16_vgx2_ilp16, &teardown }, "Dot Product (floating-point)", "BFDOT (BF16 to FP32, 2-way, two vectors)", "FEAT_SME2", "za-vector", "bfdot", "f32", 32, 2, "b16", 128, 4, 128, 16},
  {{ &setup, &bfdot_za_f32_b16_vgx4_ilp1, &teardown }, "Dot Product (floating-point)", "BFDOT (BF16 to FP32, 2-way, two vectors)", "FEAT_SME2", "za-vector", "bfdot", "f32", 64, 4, "b16", 256, 8, 256, 1},
  {{ &setup, &bfdot_za_f32_b16_vgx4_ilp2, &teardown }, "Dot Product (floating-point)", "BFDOT (BF16 to FP32, 2-way, two vectors)", "FEAT_SME2", "za-vector", "bfdot", "f32", 64, 4, "b16", 256, 8, 256, 2},
  {{ &setup, &bfdot_za_f32_b16_vgx4_ilp3, &teardown }, "Dot Product (floating-point)", "BFDOT (BF16 to FP32, 2-way, two vectors)", "FEAT_SME2", "za-vector", "bfdot", "f32", 64, 4, "b16", 256, 8, 256, 3},
  {{ &setup, &bfdot_za_f32_b16_vgx4_ilp4, &teardown }, "Dot Product (floating-point)", "BFDOT (BF16 to FP32, 2-way, two vectors)", "FEAT_SME2", "za-vector", "bfdot", "f32", 64, 4, "b16", 256, 8, 256, 4},
  {{ &setup, &bfdot_za_f32_b16_vgx4_ilp5, &teardown }, "Dot Product (floating-point)", "BFDOT (BF16 to FP32, 2-way, two vectors)", "FEAT_SME2", "za-vector", "bfdot", "f32", 64, 4, "b16", 256, 8, 256, 5},
  {{ &setup, &bfdot_za_f32_b16_vgx4_ilp6, &teardown }, "Dot Product (floating-point)", "BFDOT (BF16 to FP32, 2-way, two vectors)", "FEAT_SME2", "za-vector", "bfdot", "f32", 64, 4, "b16", 256, 8, 256, 6},
  {{ &setup, &bfdot_za_f32_b16_vgx4_ilp7, &teardown }, "Dot Product (floating-point)", "BFDOT (BF16 to FP32, 2-way, two vectors)", "FEAT_SME2", "za-vector", "bfdot", "f32", 64, 4, "b16", 256, 8, 256, 7},
  {{ &setup, &bfdot_za_f32_b16_vgx4_ilp8, &teardown }, "Dot Product (floating-point)", "BFDOT (BF16 to FP32, 2-way, two vectors)", "FEAT_SME2", "za-vector", "bfdot", "f32", 64, 4, "b16", 256, 8, 256, 8},
  {{ &setup, &bfdot_za_f32_b16_vgx4_ilp9, &teardown }, "Dot Product (floating-point)", "BFDOT (BF16 to FP32, 2-way, two vectors)", "FEAT_SME2", "za-vector", "bfdot", "f32", 64, 4, "b16", 256, 8, 256, 9},
  {{ &setup, &bfdot_za_f32_b16_vgx4_ilp10, &teardown }, "Dot Product (floating-point)", "BFDOT (BF16 to FP32, 2-way, two vectors)", "FEAT_SME2", "za-vector", "bfdot", "f32", 64, 4, "b16", 256, 8, 256, 10},
  {{ &setup, &bfdot_za_f32_b16_vgx4_ilp11, &teardown }, "Dot Product (floating-point)", "BFDOT (BF16 to FP32, 2-way, two vectors)", "FEAT_SME2", "za-vector", "bfdot", "f32", 64, 4, "b16", 256, 8, 256, 11},
  {{ &setup, &bfdot_za_f32_b16_vgx4_ilp12, &teardown }, "Dot Product (floating-point)", "BFDOT (BF16 to FP32, 2-way, two vectors)", "FEAT_SME2", "za-vector", "bfdot", "f32", 64, 4, "b16", 256, 8, 256, 12},
  {{ &setup, &bfdot_za_f32_b16_vgx4_ilp13, &teardown }, "Dot Product (floating-point)", "BFDOT (BF16 to FP32, 2-way, two vectors)", "FEAT_SME2", "za-vector", "bfdot", "f32", 64, 4, "b16", 256, 8, 256, 13},
  {{ &setup, &bfdot_za_f32_b16_vgx4_ilp14, &teardown }, "Dot Product (floating-point)", "BFDOT (BF16 to FP32, 2-way, two vectors)", "FEAT_SME2", "za-vector", "bfdot", "f32", 64, 4, "b16", 256, 8, 256, 14},
  {{ &setup, &bfdot_za_f32_b16_vgx4_ilp15, &teardown }, "Dot Product (floating-point)", "BFDOT (BF16 to FP32, 2-way, two vectors)", "FEAT_SME2", "za-vector", "bfdot", "f32", 64, 4, "b16", 256, 8, 256, 15},
  {{ &setup, &bfdot_za_f32_b16_vgx4_ilp16, &teardown }, "Dot Product (floating-point)", "BFDOT (BF16 to FP32, 2-way, two vectors)", "FEAT_SME2", "za-vector", "bfdot", "f32", 64, 4, "b16", 256, 8, 256, 16},
  {{ &setup, &sdot_i32_i16_ilp1, &teardown }, "Dot Product (integer)", "SDOT (I16 to I32, 2-way, one vector)", "FEAT_SME2", "z-register", "sdot", "i32", 16, 1, "i16", 64, 2, 64, 1},
  {{ &setup, &sdot_i32_i16_ilp2, &teardown }, "Dot Product (integer)", "SDOT (I16 to I32, 2-way, one vector)", "FEAT_SME2", "z-register", "sdot", "i32", 16, 1, "i16", 64, 2, 64, 2},
  {{ &setup, &sdot_i32_i16_ilp3, &teardown }, "Dot Product (integer)", "SDOT (I16 to I32, 2-way, one vector)", "FEAT_SME2", "z-register", "sdot", "i32", 16, 1, "i16", 64, 2, 64, 3},
  {{ &setup, &sdot_i32_i16_ilp4, &teardown }, "Dot Product (integer)", "SDOT (I16 to I32, 2-way, one vector)", "FEAT_SME2", "z-register", "sdot", "i32", 16, 1, "i16", 64, 2, 64, 4},
  {{ &setup, &sdot_i32_i16_ilp5, &teardown }, "Dot Product (integer)", "SDOT (I16 to I32, 2-way, one vector)", "FEAT_SME2", "z-register", "sdot", "i32", 16, 1, "i16", 64, 2, 64, 5},
  {{ &setup, &sdot_i32_i16_ilp6, &teardown }, "Dot Product (integer)", "SDOT (I16 to I32, 2-way, one vector)", "FEAT_SME2", "z-register", "sdot", "i32", 16, 1, "i16", 64, 2, 64, 6},
  {{ &setup, &sdot_i32_i16_ilp7, &teardown }, "Dot Product (integer)", "SDOT (I16 to I32, 2-way, one vector)", "FEAT_SME2", "z-register", "sdot", "i32", 16, 1, "i16", 64, 2, 64, 7},
  {{ &setup, &sdot_i32_i16_ilp8, &teardown }, "Dot Product (integer)", "SDOT (I16 to I32, 2-way, one vector)", "FEAT_SME2", "z-register", "sdot", "i32", 16, 1, "i16", 64, 2, 64, 8},
  {{ &setup, &sdot_i32_i16_ilp9, &teardown }, "Dot Product (integer)", "SDOT (I16 to I32, 2-way, one vector)", "FEAT_SME2", "z-register", "sdot", "i32", 16, 1, "i16", 64, 2, 64, 9},
  {{ &setup, &sdot_i32_i16_ilp10, &teardown }, "Dot Product (integer)", "SDOT (I16 to I32, 2-way, one vector)", "FEAT_SME2", "z-register", "sdot", "i32", 16, 1, "i16", 64, 2, 64, 10},
  {{ &setup, &sdot_i32_i16_ilp11, &teardown }, "Dot Product (integer)", "SDOT (I16 to I32, 2-way, one vector)", "FEAT_SME2", "z-register", "sdot", "i32", 16, 1, "i16", 64, 2, 64, 11},
  {{ &setup, &sdot_i32_i16_ilp12, &teardown }, "Dot Product (integer)", "SDOT (I16 to I32, 2-way, one vector)", "FEAT_SME2", "z-register", "sdot", "i32", 16, 1, "i16", 64, 2, 64, 12},
  {{ &setup, &sdot_i32_i16_ilp13, &teardown }, "Dot Product (integer)", "SDOT (I16 to I32, 2-way, one vector)", "FEAT_SME2", "z-register", "sdot", "i32", 16, 1, "i16", 64, 2, 64, 13},
  {{ &setup, &sdot_i32_i16_ilp14, &teardown }, "Dot Product (integer)", "SDOT (I16 to I32, 2-way, one vector)", "FEAT_SME2", "z-register", "sdot", "i32", 16, 1, "i16", 64, 2, 64, 14},
  {{ &setup, &sdot_i32_i16_ilp15, &teardown }, "Dot Product (integer)", "SDOT (I16 to I32, 2-way, one vector)", "FEAT_SME2", "z-register", "sdot", "i32", 16, 1, "i16", 64, 2, 64, 15},
  {{ &setup, &sdot_i32_i16_ilp16, &teardown }, "Dot Product (integer)", "SDOT (I16 to I32, 2-way, one vector)", "FEAT_SME2", "z-register", "sdot", "i32", 16, 1, "i16", 64, 2, 64, 16},
  {{ &setup, &sdot_i32_i8_ilp1, &teardown }, "Dot Product (integer)", "SDOT (I8 to I32, 4-way, one vector)", "FEAT_SME2", "z-register", "sdot", "i32", 16, 1, "i8", 128, 2, 128, 1},
  {{ &setup, &sdot_i32_i8_ilp2, &teardown }, "Dot Product (integer)", "SDOT (I8 to I32, 4-way, one vector)", "FEAT_SME2", "z-register", "sdot", "i32", 16, 1, "i8", 128, 2, 128, 2},
  {{ &setup, &sdot_i32_i8_ilp3, &teardown }, "Dot Product (integer)", "SDOT (I8 to I32, 4-way, one vector)", "FEAT_SME2", "z-register", "sdot", "i32", 16, 1, "i8", 128, 2, 128, 3},
  {{ &setup, &sdot_i32_i8_ilp4, &teardown }, "Dot Product (integer)", "SDOT (I8 to I32, 4-way, one vector)", "FEAT_SME2", "z-register", "sdot", "i32", 16, 1, "i8", 128, 2, 128, 4},
  {{ &setup, &sdot_i32_i8_ilp5, &teardown }, "Dot Product (integer)", "SDOT (I8 to I32, 4-way, one vector)", "FEAT_SME2", "z-register", "sdot", "i32", 16, 1, "i8", 128, 2, 128, 5},
  {{ &setup, &sdot_i32_i8_ilp6, &teardown }, "Dot Product (integer)", "SDOT (I8 to I32, 4-way, one vector)", "FEAT_SME2", "z-register", "sdot", "i32", 16, 1, "i8", 128, 2, 128, 6},
  {{ &setup, &sdot_i32_i8_ilp7, &teardown }, "Dot Product (integer)", "SDOT (I8 to I32, 4-way, one vector)", "FEAT_SME2", "z-register", "sdot", "i32", 16, 1, "i8", 128, 2, 128, 7},
  {{ &setup, &sdot_i32_i8_ilp8, &teardown }, "Dot Product (integer)", "SDOT (I8 to I32, 4-way, one vector)", "FEAT_SME2", "z-register", "sdot", "i32", 16, 1, "i8", 128, 2, 128, 8},
  {{ &setup, &sdot_i32_i8_ilp9, &teardown }, "Dot Product (integer)", "SDOT (I8 to I32, 4-way, one vector)", "FEAT_SME2", "z-register", "sdot", "i32", 16, 1, "i8", 128, 2, 128, 9},
  {{ &setup, &sdot_i32_i8_ilp10, &teardown }, "Dot Product (integer)", "SDOT (I8 to I32, 4-way, one vector)", "FEAT_SME2", "z-register", "sdot", "i32", 16, 1, "i8", 128, 2, 128, 10},
  {{ &setup, &sdot_i32_i8_ilp11, &teardown }, "Dot Product (integer)", "SDOT (I8 to I32, 4-way, one vector)", "FEAT_SME2", "z-register", "sdot", "i32", 16, 1, "i8", 128, 2, 128, 11},
  {{ &setup, &sdot_i32_i8_ilp12, &teardown }, "Dot Product (integer)", "SDOT (I8 to I32, 4-way, one vector)", "FEAT_SME2", "z-register", "sdot", "i32", 16, 1, "i8", 128, 2, 128, 12},
  {{ &setup, &sdot_i32_i8_ilp13, &teardown }, "Dot Product (integer)", "SDOT (I8 to I32, 4-way, one vector)", "FEAT_SME2", "z-register", "sdot", "i32", 16, 1, "i8", 128, 2, 128, 13},
  {{ &setup, &sdot_i32_i8_ilp14, &teardown }, "Dot Product (integer)", "SDOT (I8 to I32, 4-way, one vector)", "FEAT_SME2", "z-register", "sdot", "i32", 16, 1, "i8", 128, 2, 128, 14},
  {{ &setup, &sdot_i32_i8_ilp15, &teardown }, "Dot Product (integer)", "SDOT (I8 to I32, 4-way, one vector)", "FEAT_SME2", "z-register", "sdot", "i32", 16, 1, "i8", 128, 2, 128, 15},
  {{ &setup, &sdot_i32_i8_ilp16, &teardown }, "Dot Product (integer)", "SDOT (I8 to I32, 4-way, one vector)", "FEAT_SME2", "z-register", "sdot", "i32", 16, 1, "i8", 128, 2, 128, 16},
  {{ &setup, &sdot_i64_i16_ilp1, &teardown }, "Dot Product (integer)", "SDOT (I16 to I64, 4-way, one vector)", "FEAT_SME2", "z-register", "sdot", "i64", 8, 1, "i16", 64, 2, 64, 1},
  {{ &setup, &sdot_i64_i16_ilp2, &teardown }, "Dot Product (integer)", "SDOT (I16 to I64, 4-way, one vector)", "FEAT_SME2", "z-register", "sdot", "i64", 8, 1, "i16", 64, 2, 64, 2},
  {{ &setup, &sdot_i64_i16_ilp3, &teardown }, "Dot Product (integer)", "SDOT (I16 to I64, 4-way, one vector)", "FEAT_SME2", "z-register", "sdot", "i64", 8, 1, "i16", 64, 2, 64, 3},
  {{ &setup, &sdot_i64_i16_ilp4, &teardown }, "Dot Product (integer)", "SDOT (I16 to I64, 4-way, one vector)", "FEAT_SME2", "z-register", "sdot", "i64", 8, 1, "i16", 64, 2, 64, 4},
  {{ &setup, &sdot_i64_i16_ilp5, &teardown }, "Dot Product (integer)", "SDOT (I16 to I64, 4-way, one vector)", "FEAT_SME2", "z-register", "sdot", "i64", 8, 1, "i16", 64, 2, 64, 5},
  {{ &setup, &sdot_i64_i16_ilp6, &teardown }, "Dot Product (integer)", "SDOT (I16 to I64, 4-way, one vector)", "FEAT_SME2", "z-register", "sdot", "i64", 8, 1, "i16", 64, 2, 64, 6},
  {{ &setup, &sdot_i64_i16_ilp7, &teardown }, "Dot Product (integer)", "SDOT (I16 to I64, 4-way, one vector)", "FEAT_SME2", "z-register", "sdot", "i64", 8, 1, "i16", 64, 2, 64, 7},
  {{ &setup, &sdot_i64_i16_ilp8, &teardown }, "Dot Product (integer)", "SDOT (I16 to I64, 4-way, one vector)", "FEAT_SME2", "z-register", "sdot", "i64", 8, 1, "i16", 64, 2, 64, 8},
  {{ &setup, &sdot_i64_i16_ilp9, &teardown }, "Dot Product (integer)", "SDOT (I16 to I64, 4-way, one vector)", "FEAT_SME2", "z-register", "sdot", "i64", 8, 1, "i16", 64, 2, 64, 9},
  {{ &setup, &sdot_i64_i16_ilp10, &teardown }, "Dot Product (integer)", "SDOT (I16 to I64, 4-way, one vector)", "FEAT_SME2", "z-register", "sdot", "i64", 8, 1, "i16", 64, 2, 64, 10},
  {{ &setup, &sdot_i64_i16_ilp11, &teardown }, "Dot Product (integer)", "SDOT (I16 to I64, 4-way, one vector)", "FEAT_SME2", "z-register", "sdot", "i64", 8, 1, "i16", 64, 2, 64, 11},
  {{ &setup, &sdot_i64_i16_ilp12, &teardown }, "Dot Product (integer)", "SDOT (I16 to I64, 4-way, one vector)", "FEAT_SME2", "z-register", "sdot", "i64", 8, 1, "i16", 64, 2, 64, 12},
  {{ &setup, &sdot_i64_i16_ilp13, &teardown }, "Dot Product (integer)", "SDOT (I16 to I64, 4-way, one vector)", "FEAT_SME2", "z-register", "sdot", "i64", 8, 1, "i16", 64, 2, 64, 13},
  {{ &setup, &sdot_i64_i16_ilp14, &teardown }, "Dot Product (integer)", "SDOT (I16 to I64, 4-way, one vector)", "FEAT_SME2", "z-register", "sdot", "i64", 8, 1, "i16", 64, 2, 64, 14},
  {{ &setup, &sdot_i64_i16_ilp15, &teardown }, "Dot Product (integer)", "SDOT (I16 to I64, 4-way, one vector)", "FEAT_SME2", "z-register", "sdot", "i64", 8, 1, "i16", 64, 2, 64, 15},
  {{ &setup, &sdot_i64_i16_ilp16, &teardown }, "Dot Product (integer)", "SDOT (I16 to I64, 4-way, one vector)", "FEAT_SME2", "z-register", "sdot", "i64", 8, 1, "i16", 64, 2, 64, 16},
  {{ &setup, &sdot_za_i32_i16_vgx2_ilp1, &teardown }, "Dot Product (integer)", "SDOT (I16 to I32, 2-way, two vectors)", "FEAT_SME2", "za-vector", "sdot", "i32", 32, 2, "i16", 128, 4, 128, 1},
  {{ &setup, &sdot_za_i32_i16_vgx2_ilp2, &teardown }, "Dot Product (integer)", "SDOT (I16 to I32, 2-way, two vectors)", "FEAT_SME2", "za-vector", "sdot", "i32", 32, 2, "i16", 128, 4, 128, 2},
  {{ &setup, &sdot_za_i32_i16_vgx2_ilp3, &teardown }, "Dot Product (integer)", "SDOT (I16 to I32, 2-way, two vectors)", "FEAT_SME2", "za-vector", "sdot", "i32", 32, 2, "i16", 128, 4, 128, 3},
  {{ &setup, &sdot_za_i32_i16_vgx2_ilp4, &teardown }, "Dot Product (integer)", "SDOT (I16 to I32, 2-way, two vectors)", "FEAT_SME2", "za-vector", "sdot", "i32", 32, 2, "i16", 128, 4, 128, 4},
  {{ &setup, &sdot_za_i32_i16_vgx2_ilp5, &teardown }, "Dot Product (integer)", "SDOT (I16 to I32, 2-way, two vectors)", "FEAT_SME2", "za-vector", "sdot", "i32", 32, 2, "i16", 128, 4, 128, 5},
  {{ &setup, &sdot_za_i32_i16_vgx2_ilp6, &teardown }, "Dot Product (integer)", "SDOT (I16 to I32, 2-way, two vectors)", "FEAT_SME2", "za-vector", "sdot", "i32", 32, 2, "i16", 128, 4, 128, 6},
  {{ &setup, &sdot_za_i32_i16_vgx2_ilp7, &teardown }, "Dot Product (integer)", "SDOT (I16 to I32, 2-way, two vectors)", "FEAT_SME2", "za-vector", "sdot", "i32", 32, 2, "i16", 128, 4, 128, 7},
  {{ &setup, &sdot_za_i32_i16_vgx2_ilp8, &teardown }, "Dot Product (integer)", "SDOT (I16 to I32, 2-way, two vectors)", "FEAT_SME2", "za-vector", "sdot", "i32", 32, 2, "i16", 128, 4, 128, 8},
  {{ &setup, &sdot_za_i32_i16_vgx2_ilp9, &teardown }, "Dot Product (integer)", "SDOT (I16 to I32, 2-way, two vectors)", "FEAT_SME2", "za-vector", "sdot", "i32", 32, 2, "i16", 128, 4, 128, 9},
  {{ &setup, &sdot_za_i32_i16_vgx2_ilp10, &teardown }, "Dot Product (integer)", "SDOT (I16 to I32, 2-way, two vectors)", "FEAT_SME2", "za-vector", "sdot", "i32", 32, 2, "i16", 128, 4, 128, 10},
  {{ &setup, &sdot_za_i32_i16_vgx2_ilp11, &teardown }, "Dot Product (integer)", "SDOT (I16 to I32, 2-way, two vectors)", "FEAT_SME2", "za-vector", "sdot", "i32", 32, 2, "i16", 128, 4, 128, 11},
  {{ &setup, &sdot_za_i32_i16_vgx2_ilp12, &teardown }, "Dot Product (integer)", "SDOT (I16 to I32, 2-way, two vectors)", "FEAT_SME2", "za-vector", "sdot", "i32", 32, 2, "i16", 128, 4, 128, 12},
  {{ &setup, &sdot_za_i32_i16_vgx2_ilp13, &teardown }, "Dot Product (integer)", "SDOT (I16 to I32, 2-way, two vectors)", "FEAT_SME2", "za-vector", "sdot", "i32", 32, 2, "i16", 128, 4, 128, 13},
  {{ &setup, &sdot_za_i32_i16_vgx2_ilp14, &teardown }, "Dot Product (integer)", "SDOT (I16 to I32, 2-way, two vectors)", "FEAT_SME2", "za-vector", "sdot", "i32", 32, 2, "i16", 128, 4, 128, 14},
  {{ &setup, &sdot_za_i32_i16_vgx2_ilp15, &teardown }, "Dot Product (integer)", "SDOT (I16 to I32, 2-way, two vectors)", "FEAT_SME2", "za-vector", "sdot", "i32", 32, 2, "i16", 128, 4, 128, 15},
  {{ &setup, &sdot_za_i32_i16_vgx2_ilp16, &teardown }, "Dot Product (integer)", "SDOT (I16 to I32, 2-way, two vectors)", "FEAT_SME2", "za-vector", "sdot", "i32", 32, 2, "i16", 128, 4, 128, 16},
  {{ &setup, &sdot_za_i32_i16_vgx4_ilp1, &teardown }, "Dot Product (integer)", "SDOT (I16 to I32, 2-way, four vectors)", "FEAT_SME2", "za-vector", "sdot", "i32", 64, 4, "i16", 256, 8, 256, 1},
  {{ &setup, &sdot_za_i32_i16_vgx4_ilp2, &teardown }, "Dot Product (integer)", "SDOT (I16 to I32, 2-way, four vectors)", "FEAT_SME2", "za-vector", "sdot", "i32", 64, 4, "i16", 256, 8, 256, 2},
  {{ &setup, &sdot_za_i32_i16_vgx4_ilp3, &teardown }, "Dot Product (integer)", "SDOT (I16 to I32, 2-way, four vectors)", "FEAT_SME2", "za-vector", "sdot", "i32", 64, 4, "i16", 256, 8, 256, 3},
  {{ &setup, &sdot_za_i32_i16_vgx4_ilp4, &teardown }, "Dot Product (integer)", "SDOT (I16 to I32, 2-way, four vectors)", "FEAT_SME2", "za-vector", "sdot", "i32", 64, 4, "i16", 256, 8, 256, 4},
  {{ &setup, &sdot_za_i32_i16_vgx4_ilp5, &teardown }, "Dot Product (integer)", "SDOT (I16 to I32, 2-way, four vectors)", "FEAT_SME2", "za-vector", "sdot", "i32", 64, 4, "i16", 256, 8, 256, 5},
  {{ &setup, &sdot_za_i32_i16_vgx4_ilp6, &teardown }, "Dot Product (integer)", "SDOT (I16 to I32, 2-way, four vectors)", "FEAT_SME2", "za-vector", "sdot", "i32", 64, 4, "i16", 256, 8, 256, 6},
  {{ &setup, &sdot_za_i32_i16_vgx4_ilp7, &teardown }, "Dot Product (integer)", "SDOT (I16 to I32, 2-way, four vectors)", "FEAT_SME2", "za-vector", "sdot", "i32", 64, 4, "i16", 256, 8, 256, 7},
  {{ &setup, &sdot_za_i32_i16_vgx4_ilp8, &teardown }, "Dot Product (integer)", "SDOT (I16 to I32, 2-way, four vectors)", "FEAT_SME2", "za-vector", "sdot", "i32", 64, 4, "i16", 256, 8, 256, 8},
  {{ &setup, &sdot_za_i32_i16_vgx4_ilp9, &teardown }, "Dot Product (integer)", "SDOT (I16 to I32, 2-way, four vectors)", "FEAT_SME2", "za-vector", "sdot", "i32", 64, 4, "i16", 256, 8, 256, 9},
  {{ &setup, &sdot_za_i32_i16_vgx4_ilp10, &teardown }, "Dot Product (integer)", "SDOT (I16 to I32, 2-way, four vectors)", "FEAT_SME2", "za-vector", "sdot", "i32", 64, 4, "i16", 256, 8, 256, 10},
  {{ &setup, &sdot_za_i32_i16_vgx4_ilp11, &teardown }, "Dot Product (integer)", "SDOT (I16 to I32, 2-way, four vectors)", "FEAT_SME2", "za-vector", "sdot", "i32", 64, 4, "i16", 256, 8, 256, 11},
  {{ &setup, &sdot_za_i32_i16_vgx4_ilp12, &teardown }, "Dot Product (integer)", "SDOT (I16 to I32, 2-way, four vectors)", "FEAT_SME2", "za-vector", "sdot", "i32", 64, 4, "i16", 256, 8, 256, 12},
  {{ &setup, &sdot_za_i32_i16_vgx4_ilp13, &teardown }, "Dot Product (integer)", "SDOT (I16 to I32, 2-way, four vectors)", "FEAT_SME2", "za-vector", "sdot", "i32", 64, 4, "i16", 256, 8, 256, 13},
  {{ &setup, &sdot_za_i32_i16_vgx4_ilp14, &teardown }, "Dot Product (integer)", "SDOT (I16 to I32, 2-way, four vectors)", "FEAT_SME2", "za-vector", "sdot", "i32", 64, 4, "i16", 256, 8, 256, 14},
  {{ &setup, &sdot_za_i32_i16_vgx4_ilp15, &teardown }, "Dot Product (integer)", "SDOT (I16 to I32, 2-way, four vectors)", "FEAT_SME2", "za-vector", "sdot", "i32", 64, 4, "i16", 256, 8, 256, 15},
  {{ &setup, &sdot_za_i32_i16_vgx4_ilp16, &teardown }, "Dot Product (integer)", "SDOT (I16 to I32, 2-way, four vectors)", "FEAT_SME2", "za-vector", "sdot", "i32", 64, 4, "i16", 256, 8, 256, 16},
  {{ &setup, &sdot_za_i32_i8_vgx2_ilp1, &teardown }, "Dot Product (integer)", "SDOT (I8 to I32, 4-way, two vectors)", "FEAT_SME2", "za-vector", "sdot", "i32", 32, 2, "i8", 256, 4, 256, 1},
  {{ &setup, &sdot_za_i32_i8_vgx2_ilp2, &teardown }, "Dot Product (integer)", "SDOT (I8 to I32, 4-way, two vectors)", "FEAT_SME2", "za-vector", "sdot", "i32", 32, 2, "i8", 256, 4, 256, 2},
  {{ &setup, &sdot_za_i32_i8_vgx2_ilp3, &teardown }, "Dot Product (integer)", "SDOT (I8 to I32, 4-way, two vectors)", "FEAT_SME2", "za-vector", "sdot", "i32", 32, 2, "i8", 256, 4, 256, 3},
  {{ &setup, &sdot_za_i32_i8_vgx2_ilp4, &teardown }, "Dot Product (integer)", "SDOT (I8 to I32, 4-way, two vectors)", "FEAT_SME2", "za-vector", "sdot", "i32", 32, 2, "i8", 256, 4, 256, 4},
  {{ &setup, &sdot_za_i32_i8_vgx2_ilp5, &teardown }, "Dot Product (integer)", "SDOT (I8 to I32, 4-way, two vectors)", "FEAT_SME2", "za-vector", "sdot", "i32", 32, 2, "i8", 256, 4, 256, 5},
  {{ &setup, &sdot_za_i32_i8_vgx2_ilp6, &teardown }, "Dot Product (integer)", "SDOT (I8 to I32, 4-way, two vectors)", "FEAT_SME2", "za-vector", "sdot", "i32", 32, 2, "i8", 256, 4, 256, 6},
  {{ &setup, &sdot_za_i32_i8_vgx2_ilp7, &teardown }, "Dot Product (integer)", "SDOT (I8 to I32, 4-way, two vectors)", "FEAT_SME2", "za-vector", "sdot", "i32", 32, 2, "i8", 256, 4, 256, 7},
  {{ &setup, &sdot_za_i32_i8_vgx2_ilp8, &teardown }, "Dot Product (integer)", "SDOT (I8 to I32, 4-way, two vectors)", "FEAT_SME2", "za-vector", "sdot", "i32", 32, 2, "i8", 256, 4, 256, 8},
  {{ &setup, &sdot_za_i32_i8_vgx2_ilp9, &teardown }, "Dot Product (integer)", "SDOT (I8 to I32, 4-way, two vectors)", "FEAT_SME2", "za-vector", "sdot", "i32", 32, 2, "i8", 256, 4, 256, 9},
  {{ &setup, &sdot_za_i32_i8_vgx2_ilp10, &teardown }, "Dot Product (integer)", "SDOT (I8 to I32, 4-way, two vectors)", "FEAT_SME2", "za-vector", "sdot", "i32", 32, 2, "i8", 256, 4, 256, 10},
  {{ &setup, &sdot_za_i32_i8_vgx2_ilp11, &teardown }, "Dot Product (integer)", "SDOT (I8 to I32, 4-way, two vectors)", "FEAT_SME2", "za-vector", "sdot", "i32", 32, 2, "i8", 256, 4, 256, 11},
  {{ &setup, &sdot_za_i32_i8_vgx2_ilp12, &teardown }, "Dot Product (integer)", "SDOT (I8 to I32, 4-way, two vectors)", "FEAT_SME2", "za-vector", "sdot", "i32", 32, 2, "i8", 256, 4, 256, 12},
  {{ &setup, &sdot_za_i32_i8_vgx2_ilp13, &teardown }, "Dot Product (integer)", "SDOT (I8 to I32, 4-way, two vectors)", "FEAT_SME2", "za-vector", "sdot", "i32", 32, 2, "i8", 256, 4, 256, 13},
  {{ &setup, &sdot_za_i32_i8_vgx2_ilp14, &teardown }, "Dot Product (integer)", "SDOT (I8 to I32, 4-way, two vectors)", "FEAT_SME2", "za-vector", "sdot", "i32", 32, 2, "i8", 256, 4, 256, 14},
  {{ &setup, &sdot_za_i32_i8_vgx2_ilp15, &teardown }, "Dot Product (integer)", "SDOT (I8 to I32, 4-way, two vectors)", "FEAT_SME2", "za-vector", "sdot", "i32", 32, 2, "i8", 256, 4, 256, 15},
  {{ &setup, &sdot_za_i32_i8_vgx2_ilp16, &teardown }, "Dot Product (integer)", "SDOT (I8 to I32, 4-way, two vectors)", "FEAT_SME2", "za-vector", "sdot", "i32", 32, 2, "i8", 256, 4, 256, 16},
  {{ &setup, &sdot_za_i32_i8_vgx4_ilp1, &teardown }, "Dot Product (integer)", "SDOT (I8 to I32, 4-way, four vectors)", "FEAT_SME2", "za-vector", "sdot", "i32", 64, 4, "i8", 512, 8, 512, 1},
  {{ &setup, &sdot_za_i32_i8_vgx4_ilp2, &teardown }, "Dot Product (integer)", "SDOT (I8 to I32, 4-way, four vectors)", "FEAT_SME2", "za-vector", "sdot", "i32", 64, 4, "i8", 512, 8, 512, 2},
  {{ &setup, &sdot_za_i32_i8_vgx4_ilp3, &teardown }, "Dot Product (integer)", "SDOT (I8 to I32, 4-way, four vectors)", "FEAT_SME2", "za-vector", "sdot", "i32", 64, 4, "i8", 512, 8, 512, 3},
  {{ &setup, &sdot_za_i32_i8_vgx4_ilp4, &teardown }, "Dot Product (integer)", "SDOT (I8 to I32, 4-way, four vectors)", "FEAT_SME2", "za-vector", "sdot", "i32", 64, 4, "i8", 512, 8, 512, 4},
  {{ &setup, &sdot_za_i32_i8_vgx4_ilp5, &teardown }, "Dot Product (integer)", "SDOT (I8 to I32, 4-way, four vectors)", "FEAT_SME2", "za-vector", "sdot", "i32", 64, 4, "i8", 512, 8, 512, 5},
  {{ &setup, &sdot_za_i32_i8_vgx4_ilp6, &teardown }, "Dot Product (integer)", "SDOT (I8 to I32, 4-way, four vectors)", "FEAT_SME2", "za-vector", "sdot", "i32", 64, 4, "i8", 512, 8, 512, 6},
  {{ &setup, &sdot_za_i32_i8_vgx4_ilp7, &teardown }, "Dot Product (integer)", "SDOT (I8 to I32, 4-way, four vectors)", "FEAT_SME2", "za-vector", "sdot", "i32", 64, 4, "i8", 512, 8, 512, 7},
  {{ &setup, &sdot_za_i32_i8_vgx4_ilp8, &teardown }, "Dot Product (integer)", "SDOT (I8 to I32, 4-way, four vectors)", "FEAT_SME2", "za-vector", "sdot", "i32", 64, 4, "i8", 512, 8, 512, 8},
  {{ &setup, &sdot_za_i32_i8_vgx4_ilp9, &teardown }, "Dot Product (integer)", "SDOT (I8 to I32, 4-way, four vectors)", "FEAT_SME2", "za-vector", "sdot", "i32", 64, 4, "i8", 512, 8, 512, 9},
  {{ &setup, &sdot_za_i32_i8_vgx4_ilp10, &teardown }, "Dot Product (integer)", "SDOT (I8 to I32, 4-way, four vectors)", "FEAT_SME2", "za-vector", "sdot", "i32", 64, 4, "i8", 512, 8, 512, 10},
  {{ &setup, &sdot_za_i32_i8_vgx4_ilp11, &teardown }, "Dot Product (integer)", "SDOT (I8 to I32, 4-way, four vectors)", "FEAT_SME2", "za-vector", "sdot", "i32", 64, 4, "i8", 512, 8, 512, 11},
  {{ &setup, &sdot_za_i32_i8_vgx4_ilp12, &teardown }, "Dot Product (integer)", "SDOT (I8 to I32, 4-way, four vectors)", "FEAT_SME2", "za-vector", "sdot", "i32", 64, 4, "i8", 512, 8, 512, 12},
  {{ &setup, &sdot_za_i32_i8_vgx4_ilp13, &teardown }, "Dot Product (integer)", "SDOT (I8 to I32, 4-way, four vectors)", "FEAT_SME2", "za-vector", "sdot", "i32", 64, 4, "i8", 512, 8, 512, 13},
  {{ &setup, &sdot_za_i32_i8_vgx4_ilp14, &teardown }, "Dot Product (integer)", "SDOT (I8 to I32, 4-way, four vectors)", "FEAT_SME2", "za-vector", "sdot", "i32", 64, 4, "i8", 512, 8, 512, 14},
  {{ &setup, &sdot_za_i32_i8_vgx4_ilp15, &teardown }, "Dot Product (integer)", "SDOT (I8 to I32, 4-way, four vectors)", "FEAT_SME2", "za-vector", "sdot", "i32", 64, 4, "i8", 512, 8, 512, 15},
  {{ &setup, &sdot_za_i32_i8_vgx4_ilp16, &teardown }, "Dot Product (integer)", "SDOT (I8 to I32, 4-way, four vectors)", "FEAT_SME2", "za-vector", "sdot", "i32", 64, 4, "i8", 512, 8, 512, 16},
  {{ &setup, &sdot_za_i64_i16_vgx2_ilp1, &teardown }, "Dot Product (integer)", "SDOT (I16 to I64, 4-way, two vectors)", "FEAT_SME2", "za-vector", "sdot", "i64", 16, 2, "i16", 128, 4, 128, 1},
  {{ &setup, &sdot_za_i64_i16_vgx2_ilp2, &teardown }, "Dot Product (integer)", "SDOT (I16 to I64, 4-way, two vectors)", "FEAT_SME2", "za-vector", "sdot", "i64", 16, 2, "i16", 128, 4, 128, 2},
  {{ &setup, &sdot_za_i64_i16_vgx2_ilp3, &teardown }, "Dot Product (integer)", "SDOT (I16 to I64, 4-way, two vectors)", "FEAT_SME2", "za-vector", "sdot", "i64", 16, 2, "i16", 128, 4, 128, 3},
  {{ &setup, &sdot_za_i64_i16_vgx2_ilp4, &teardown }, "Dot Product (integer)", "SDOT (I16 to I64, 4-way, two vectors)", "FEAT_SME2", "za-vector", "sdot", "i64", 16, 2, "i16", 128, 4, 128, 4},
  {{ &setup, &sdot_za_i64_i16_vgx2_ilp5, &teardown }, "Dot Product (integer)", "SDOT (I16 to I64, 4-way, two vectors)", "FEAT_SME2", "za-vector", "sdot", "i64", 16, 2, "i16", 128, 4, 128, 5},
  {{ &setup, &sdot_za_i64_i16_vgx2_ilp6, &teardown }, "Dot Product (integer)", "SDOT (I16 to I64, 4-way, two vectors)", "FEAT_SME2", "za-vector", "sdot", "i64", 16, 2, "i16", 128, 4, 128, 6},
  {{ &setup, &sdot_za_i64_i16_vgx2_ilp7, &teardown }, "Dot Product (integer)", "SDOT (I16 to I64, 4-way, two vectors)", "FEAT_SME2", "za-vector", "sdot", "i64", 16, 2, "i16", 128, 4, 128, 7},
  {{ &setup, &sdot_za_i64_i16_vgx2_ilp8, &teardown }, "Dot Product (integer)", "SDOT (I16 to I64, 4-way, two vectors)", "FEAT_SME2", "za-vector", "sdot", "i64", 16, 2, "i16", 128, 4, 128, 8},
  {{ &setup, &sdot_za_i64_i16_vgx2_ilp9, &teardown }, "Dot Product (integer)", "SDOT (I16 to I64, 4-way, two vectors)", "FEAT_SME2", "za-vector", "sdot", "i64", 16, 2, "i16", 128, 4, 128, 9},
  {{ &setup, &sdot_za_i64_i16_vgx2_ilp10, &teardown }, "Dot Product (integer)", "SDOT (I16 to I64, 4-way, two vectors)", "FEAT_SME2", "za-vector", "sdot", "i64", 16, 2, "i16", 128, 4, 128, 10},
  {{ &setup, &sdot_za_i64_i16_vgx2_ilp11, &teardown }, "Dot Product (integer)", "SDOT (I16 to I64, 4-way, two vectors)", "FEAT_SME2", "za-vector", "sdot", "i64", 16, 2, "i16", 128, 4, 128, 11},
  {{ &setup, &sdot_za_i64_i16_vgx2_ilp12, &teardown }, "Dot Product (integer)", "SDOT (I16 to I64, 4-way, two vectors)", "FEAT_SME2", "za-vector", "sdot", "i64", 16, 2, "i16", 128, 4, 128, 12},
  {{ &setup, &sdot_za_i64_i16_vgx2_ilp13, &teardown }, "Dot Product (integer)", "SDOT (I16 to I64, 4-way, two vectors)", "FEAT_SME2", "za-vector", "sdot", "i64", 16, 2, "i16", 128, 4, 128, 13},
  {{ &setup, &sdot_za_i64_i16_vgx2_ilp14, &teardown }, "Dot Product (integer)", "SDOT (I16 to I64, 4-way, two vectors)", "FEAT_SME2", "za-vector", "sdot", "i64", 16, 2, "i16", 128, 4, 128, 14},
  {{ &setup, &sdot_za_i64_i16_vgx2_ilp15, &teardown }, "Dot Product (integer)", "SDOT (I16 to I64, 4-way, two vectors)", "FEAT_SME2", "za-vector", "sdot", "i64", 16, 2, "i16", 128, 4, 128, 15},
  {{ &setup, &sdot_za_i64_i16_vgx2_ilp16, &teardown }, "Dot Product (integer)", "SDOT (I16 to I64, 4-way, two vectors)", "FEAT_SME2", "za-vector", "sdot", "i64", 16, 2, "i16", 128, 4, 128, 16},
  {{ &setup, &sdot_za_i64_i16_vgx4_ilp1, &teardown }, "Dot Product (integer)", "SDOT (I16 to I64, 4-way, four vectors)", "FEAT_SME2", "za-vector", "sdot", "i64", 32, 4, "i16", 256, 8, 256, 1},
  {{ &setup, &sdot_za_i64_i16_vgx4_ilp2, &teardown }, "Dot Product (integer)", "SDOT (I16 to I64, 4-way, four vectors)", "FEAT_SME2", "za-vector", "sdot", "i64", 32, 4, "i16", 256, 8, 256, 2},
  {{ &setup, &sdot_za_i64_i16_vgx4_ilp3, &teardown }, "Dot Product (integer)", "SDOT (I16 to I64, 4-way, four vectors)", "FEAT_SME2", "za-vector", "sdot", "i64", 32, 4, "i16", 256, 8, 256, 3},
  {{ &setup, &sdot_za_i64_i16_vgx4_ilp4, &teardown }, "Dot Product (integer)", "SDOT (I16 to I64, 4-way, four vectors)", "FEAT_SME2", "za-vector", "sdot", "i64", 32, 4, "i16", 256, 8, 256, 4},
  {{ &setup, &sdot_za_i64_i16_vgx4_ilp5, &teardown }, "Dot Product (integer)", "SDOT (I16 to I64, 4-way, four vectors)", "FEAT_SME2", "za-vector", "sdot", "i64", 32, 4, "i16", 256, 8, 256, 5},
  {{ &setup, &sdot_za_i64_i16_vgx4_ilp6, &teardown }, "Dot Product (integer)", "SDOT (I16 to I64, 4-way, four vectors)", "FEAT_SME2", "za-vector", "sdot", "i64", 32, 4, "i16", 256, 8, 256, 6},
  {{ &setup, &sdot_za_i64_i16_vgx4_ilp7, &teardown }, "Dot Product (integer)", "SDOT (I16 to I64, 4-way, four vectors)", "FEAT_SME2", "za-vector", "sdot", "i64", 32, 4, "i16", 256, 8, 256, 7},
  {{ &setup, &sdot_za_i64_i16_vgx4_ilp8, &teardown }, "Dot Product (integer)", "SDOT (I16 to I64, 4-way, four vectors)", "FEAT_SME2", "za-vector", "sdot", "i64", 32, 4, "i16", 256, 8, 256, 8},
  {{ &setup, &sdot_za_i64_i16_vgx4_ilp9, &teardown }, "Dot Product (integer)", "SDOT (I16 to I64, 4-way, four vectors)", "FEAT_SME2", "za-vector", "sdot", "i64", 32, 4, "i16", 256, 8, 256, 9},
  {{ &setup, &sdot_za_i64_i16_vgx4_ilp10, &teardown }, "Dot Product (integer)", "SDOT (I16 to I64, 4-way, four vectors)", "FEAT_SME2", "za-vector", "sdot", "i64", 32, 4, "i16", 256, 8, 256, 10},
  {{ &setup, &sdot_za_i64_i16_vgx4_ilp11, &teardown }, "Dot Product (integer)", "SDOT (I16 to I64, 4-way, four vectors)", "FEAT_SME2", "za-vector", "sdot", "i64", 32, 4, "i16", 256, 8, 256, 11},
  {{ &setup, &sdot_za_i64_i16_vgx4_ilp12, &teardown }, "Dot Product (integer)", "SDOT (I16 to I64, 4-way, four vectors)", "FEAT_SME2", "za-vector", "sdot", "i64", 32, 4, "i16", 256, 8, 256, 12},
  {{ &setup, &sdot_za_i64_i16_vgx4_ilp13, &teardown }, "Dot Product (integer)", "SDOT (I16 to I64, 4-way, four vectors)", "FEAT_SME2", "za-vector", "sdot", "i64", 32, 4, "i16", 256, 8, 256, 13},
  {{ &setup, &sdot_za_i64_i16_vgx4_ilp14, &teardown }, "Dot Product (integer)", "SDOT (I16 to I64, 4-way, four vectors)", "FEAT_SME2", "za-vector", "sdot", "i64", 32, 4, "i16", 256, 8, 256, 14},
  {{ &setup, &sdot_za_i64_i16_vgx4_ilp15, &teardown }, "Dot Product (integer)", "SDOT (I16 to I64, 4-way, four vectors)", "FEAT_SME2", "za-vector", "sdot", "i64", 32, 4, "i16", 256, 8, 256, 15},
  {{ &setup, &sdot_za_i64_i16_vgx4_ilp16, &teardown }, "Dot Product (integer)", "SDOT (I16 to I64, 4-way, four vectors)", "FEAT_SME2", "za-vector", "sdot", "i64", 32, 4, "i16", 256, 8, 256, 16},
  {{ &setup, &fmla_f16_f16_ilp1, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP16, one vector)", "FEAT_SME", "z-register", "fmla", "f16", 32, 1, "f16", 64, 2, 64, 1},
  {{ &setup, &fmla_f16_f16_ilp2, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP16, one vector)", "FEAT_SME", "z-register", "fmla", "f16", 32, 1, "f16", 64, 2, 64, 2},
  {{ &setup, &fmla_f16_f16_ilp3, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP16, one vector)", "FEAT_SME", "z-register", "fmla", "f16", 32, 1, "f16", 64, 2, 64, 3},
  {{ &setup, &fmla_f16_f16_ilp4, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP16, one vector)", "FEAT_SME", "z-register", "fmla", "f16", 32, 1, "f16", 64, 2, 64, 4},
  {{ &setup, &fmla_f16_f16_ilp5, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP16, one vector)", "FEAT_SME", "z-register", "fmla", "f16", 32, 1, "f16", 64, 2, 64, 5},
  {{ &setup, &fmla_f16_f16_ilp6, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP16, one vector)", "FEAT_SME", "z-register", "fmla", "f16", 32, 1, "f16", 64, 2, 64, 6},
  {{ &setup, &fmla_f16_f16_ilp7, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP16, one vector)", "FEAT_SME", "z-register", "fmla", "f16", 32, 1, "f16", 64, 2, 64, 7},
  {{ &setup, &fmla_f16_f16_ilp8, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP16, one vector)", "FEAT_SME", "z-register", "fmla", "f16", 32, 1, "f16", 64, 2, 64, 8},
  {{ &setup, &fmla_f16_f16_ilp9, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP16, one vector)", "FEAT_SME", "z-register", "fmla", "f16", 32, 1, "f16", 64, 2, 64, 9},
  {{ &setup, &fmla_f16_f16_ilp10, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP16, one vector)", "FEAT_SME", "z-register", "fmla", "f16", 32, 1, "f16", 64, 2, 64, 10},
  {{ &setup, &fmla_f16_f16_ilp11, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP16, one vector)", "FEAT_SME", "z-register", "fmla", "f16", 32, 1, "f16", 64, 2, 64, 11},
  {{ &setup, &fmla_f16_f16_ilp12, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP16, one vector)", "FEAT_SME", "z-register", "fmla", "f16", 32, 1, "f16", 64, 2, 64, 12},
  {{ &setup, &fmla_f16_f16_ilp13, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP16, one vector)", "FEAT_SME", "z-register", "fmla", "f16", 32, 1, "f16", 64, 2, 64, 13},
  {{ &setup, &fmla_f16_f16_ilp14, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP16, one vector)", "FEAT_SME", "z-register", "fmla", "f16", 32, 1, "f16", 64, 2, 64, 14},
  {{ &setup, &fmla_f16_f16_ilp15, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP16, one vector)", "FEAT_SME", "z-register", "fmla", "f16", 32, 1, "f16", 64, 2, 64, 15},
  {{ &setup, &fmla_f16_f16_ilp16, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP16, one vector)", "FEAT_SME", "z-register", "fmla", "f16", 32, 1, "f16", 64, 2, 64, 16},
  {{ &setup, &fmla_f32_f32_ilp1, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP32, one vector)", "FEAT_SME", "z-register", "fmla", "f32", 16, 1, "f32", 32, 2, 32, 1},
  {{ &setup, &fmla_f32_f32_ilp2, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP32, one vector)", "FEAT_SME", "z-register", "fmla", "f32", 16, 1, "f32", 32, 2, 32, 2},
  {{ &setup, &fmla_f32_f32_ilp3, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP32, one vector)", "FEAT_SME", "z-register", "fmla", "f32", 16, 1, "f32", 32, 2, 32, 3},
  {{ &setup, &fmla_f32_f32_ilp4, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP32, one vector)", "FEAT_SME", "z-register", "fmla", "f32", 16, 1, "f32", 32, 2, 32, 4},
  {{ &setup, &fmla_f32_f32_ilp5, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP32, one vector)", "FEAT_SME", "z-register", "fmla", "f32", 16, 1, "f32", 32, 2, 32, 5},
  {{ &setup, &fmla_f32_f32_ilp6, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP32, one vector)", "FEAT_SME", "z-register", "fmla", "f32", 16, 1, "f32", 32, 2, 32, 6},
  {{ &setup, &fmla_f32_f32_ilp7, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP32, one vector)", "FEAT_SME", "z-register", "fmla", "f32", 16, 1, "f32", 32, 2, 32, 7},
  {{ &setup, &fmla_f32_f32_ilp8, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP32, one vector)", "FEAT_SME", "z-register", "fmla", "f32", 16, 1, "f32", 32, 2, 32, 8},
  {{ &setup, &fmla_f32_f32_ilp9, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP32, one vector)", "FEAT_SME", "z-register", "fmla", "f32", 16, 1, "f32", 32, 2, 32, 9},
  {{ &setup, &fmla_f32_f32_ilp10, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP32, one vector)", "FEAT_SME", "z-register", "fmla", "f32", 16, 1, "f32", 32, 2, 32, 10},
  {{ &setup, &fmla_f32_f32_ilp11, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP32, one vector)", "FEAT_SME", "z-register", "fmla", "f32", 16, 1, "f32", 32, 2, 32, 11},
  {{ &setup, &fmla_f32_f32_ilp12, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP32, one vector)", "FEAT_SME", "z-register", "fmla", "f32", 16, 1, "f32", 32, 2, 32, 12},
  {{ &setup, &fmla_f32_f32_ilp13, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP32, one vector)", "FEAT_SME", "z-register", "fmla", "f32", 16, 1, "f32", 32, 2, 32, 13},
  {{ &setup, &fmla_f32_f32_ilp14, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP32, one vector)", "FEAT_SME", "z-register", "fmla", "f32", 16, 1, "f32", 32, 2, 32, 14},
  {{ &setup, &fmla_f32_f32_ilp15, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP32, one vector)", "FEAT_SME", "z-register", "fmla", "f32", 16, 1, "f32", 32, 2, 32, 15},
  {{ &setup, &fmla_f32_f32_ilp16, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP32, one vector)", "FEAT_SME", "z-register", "fmla", "f32", 16, 1, "f32", 32, 2, 32, 16},
  {{ &setup, &fmla_f64_f64_ilp1, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP64, one vector)", "FEAT_SME", "z-register", "fmla", "f64", 8, 1, "f64", 16, 2, 16, 1},
  {{ &setup, &fmla_f64_f64_ilp2, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP64, one vector)", "FEAT_SME", "z-register", "fmla", "f64", 8, 1, "f64", 16, 2, 16, 2},
  {{ &setup, &fmla_f64_f64_ilp3, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP64, one vector)", "FEAT_SME", "z-register", "fmla", "f64", 8, 1, "f64", 16, 2, 16, 3},
  {{ &setup, &fmla_f64_f64_ilp4, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP64, one vector)", "FEAT_SME", "z-register", "fmla", "f64", 8, 1, "f64", 16, 2, 16, 4},
  {{ &setup, &fmla_f64_f64_ilp5, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP64, one vector)", "FEAT_SME", "z-register", "fmla", "f64", 8, 1, "f64", 16, 2, 16, 5},
  {{ &setup, &fmla_f64_f64_ilp6, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP64, one vector)", "FEAT_SME", "z-register", "fmla", "f64", 8, 1, "f64", 16, 2, 16, 6},
  {{ &setup, &fmla_f64_f64_ilp7, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP64, one vector)", "FEAT_SME", "z-register", "fmla", "f64", 8, 1, "f64", 16, 2, 16, 7},
  {{ &setup, &fmla_f64_f64_ilp8, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP64, one vector)", "FEAT_SME", "z-register", "fmla", "f64", 8, 1, "f64", 16, 2, 16, 8},
  {{ &setup, &fmla_f64_f64_ilp9, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP64, one vector)", "FEAT_SME", "z-register", "fmla", "f64", 8, 1, "f64", 16, 2, 16, 9},
  {{ &setup, &fmla_f64_f64_ilp10, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP64, one vector)", "FEAT_SME", "z-register", "fmla", "f64", 8, 1, "f64", 16, 2, 16, 10},
  {{ &setup, &fmla_f64_f64_ilp11, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP64, one vector)", "FEAT_SME", "z-register", "fmla", "f64", 8, 1, "f64", 16, 2, 16, 11},
  {{ &setup, &fmla_f64_f64_ilp12, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP64, one vector)", "FEAT_SME", "z-register", "fmla", "f64", 8, 1, "f64", 16, 2, 16, 12},
  {{ &setup, &fmla_f64_f64_ilp13, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP64, one vector)", "FEAT_SME", "z-register", "fmla", "f64", 8, 1, "f64", 16, 2, 16, 13},
  {{ &setup, &fmla_f64_f64_ilp14, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP64, one vector)", "FEAT_SME", "z-register", "fmla", "f64", 8, 1, "f64", 16, 2, 16, 14},
  {{ &setup, &fmla_f64_f64_ilp15, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP64, one vector)", "FEAT_SME", "z-register", "fmla", "f64", 8, 1, "f64", 16, 2, 16, 15},
  {{ &setup, &fmla_f64_f64_ilp16, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP64, one vector)", "FEAT_SME", "z-register", "fmla", "f64", 8, 1, "f64", 16, 2, 16, 16},
  {{ &setup, &fmla_za_f32_f32_vgx2_ilp1, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP32, two vectors)", "FEAT_SME2", "za-vector", "fmla", "f32", 32, 2, "f32", 64, 4, 64, 1},
  {{ &setup, &fmla_za_f32_f32_vgx2_ilp2, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP32, two vectors)", "FEAT_SME2", "za-vector", "fmla", "f32", 32, 2, "f32", 64, 4, 64, 2},
  {{ &setup, &fmla_za_f32_f32_vgx2_ilp3, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP32, two vectors)", "FEAT_SME2", "za-vector", "fmla", "f32", 32, 2, "f32", 64, 4, 64, 3},
  {{ &setup, &fmla_za_f32_f32_vgx2_ilp4, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP32, two vectors)", "FEAT_SME2", "za-vector", "fmla", "f32", 32, 2, "f32", 64, 4, 64, 4},
  {{ &setup, &fmla_za_f32_f32_vgx2_ilp5, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP32, two vectors)", "FEAT_SME2", "za-vector", "fmla", "f32", 32, 2, "f32", 64, 4, 64, 5},
  {{ &setup, &fmla_za_f32_f32_vgx2_ilp6, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP32, two vectors)", "FEAT_SME2", "za-vector", "fmla", "f32", 32, 2, "f32", 64, 4, 64, 6},
  {{ &setup, &fmla_za_f32_f32_vgx2_ilp7, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP32, two vectors)", "FEAT_SME2", "za-vector", "fmla", "f32", 32, 2, "f32", 64, 4, 64, 7},
  {{ &setup, &fmla_za_f32_f32_vgx2_ilp8, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP32, two vectors)", "FEAT_SME2", "za-vector", "fmla", "f32", 32, 2, "f32", 64, 4, 64, 8},
  {{ &setup, &fmla_za_f32_f32_vgx2_ilp9, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP32, two vectors)", "FEAT_SME2", "za-vector", "fmla", "f32", 32, 2, "f32", 64, 4, 64, 9},
  {{ &setup, &fmla_za_f32_f32_vgx2_ilp10, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP32, two vectors)", "FEAT_SME2", "za-vector", "fmla", "f32", 32, 2, "f32", 64, 4, 64, 10},
  {{ &setup, &fmla_za_f32_f32_vgx2_ilp11, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP32, two vectors)", "FEAT_SME2", "za-vector", "fmla", "f32", 32, 2, "f32", 64, 4, 64, 11},
  {{ &setup, &fmla_za_f32_f32_vgx2_ilp12, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP32, two vectors)", "FEAT_SME2", "za-vector", "fmla", "f32", 32, 2, "f32", 64, 4, 64, 12},
  {{ &setup, &fmla_za_f32_f32_vgx2_ilp13, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP32, two vectors)", "FEAT_SME2", "za-vector", "fmla", "f32", 32, 2, "f32", 64, 4, 64, 13},
  {{ &setup, &fmla_za_f32_f32_vgx2_ilp14, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP32, two vectors)", "FEAT_SME2", "za-vector", "fmla", "f32", 32, 2, "f32", 64, 4, 64, 14},
  {{ &setup, &fmla_za_f32_f32_vgx2_ilp15, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP32, two vectors)", "FEAT_SME2", "za-vector", "fmla", "f32", 32, 2, "f32", 64, 4, 64, 15},
  {{ &setup, &fmla_za_f32_f32_vgx2_ilp16, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP32, two vectors)", "FEAT_SME2", "za-vector", "fmla", "f32", 32, 2, "f32", 64, 4, 64, 16},
  {{ &setup, &fmla_za_f32_f32_vgx4_ilp1, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP32, four vectors)", "FEAT_SME2", "za-vector", "fmla", "f32", 64, 4, "f32", 128, 8, 128, 1},
  {{ &setup, &fmla_za_f32_f32_vgx4_ilp2, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP32, four vectors)", "FEAT_SME2", "za-vector", "fmla", "f32", 64, 4, "f32", 128, 8, 128, 2},
  {{ &setup, &fmla_za_f32_f32_vgx4_ilp3, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP32, four vectors)", "FEAT_SME2", "za-vector", "fmla", "f32", 64, 4, "f32", 128, 8, 128, 3},
  {{ &setup, &fmla_za_f32_f32_vgx4_ilp4, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP32, four vectors)", "FEAT_SME2", "za-vector", "fmla", "f32", 64, 4, "f32", 128, 8, 128, 4},
  {{ &setup, &fmla_za_f32_f32_vgx4_ilp5, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP32, four vectors)", "FEAT_SME2", "za-vector", "fmla", "f32", 64, 4, "f32", 128, 8, 128, 5},
  {{ &setup, &fmla_za_f32_f32_vgx4_ilp6, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP32, four vectors)", "FEAT_SME2", "za-vector", "fmla", "f32", 64, 4, "f32", 128, 8, 128, 6},
  {{ &setup, &fmla_za_f32_f32_vgx4_ilp7, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP32, four vectors)", "FEAT_SME2", "za-vector", "fmla", "f32", 64, 4, "f32", 128, 8, 128, 7},
  {{ &setup, &fmla_za_f32_f32_vgx4_ilp8, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP32, four vectors)", "FEAT_SME2", "za-vector", "fmla", "f32", 64, 4, "f32", 128, 8, 128, 8},
  {{ &setup, &fmla_za_f32_f32_vgx4_ilp9, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP32, four vectors)", "FEAT_SME2", "za-vector", "fmla", "f32", 64, 4, "f32", 128, 8, 128, 9},
  {{ &setup, &fmla_za_f32_f32_vgx4_ilp10, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP32, four vectors)", "FEAT_SME2", "za-vector", "fmla", "f32", 64, 4, "f32", 128, 8, 128, 10},
  {{ &setup, &fmla_za_f32_f32_vgx4_ilp11, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP32, four vectors)", "FEAT_SME2", "za-vector", "fmla", "f32", 64, 4, "f32", 128, 8, 128, 11},
  {{ &setup, &fmla_za_f32_f32_vgx4_ilp12, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP32, four vectors)", "FEAT_SME2", "za-vector", "fmla", "f32", 64, 4, "f32", 128, 8, 128, 12},
  {{ &setup, &fmla_za_f32_f32_vgx4_ilp13, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP32, four vectors)", "FEAT_SME2", "za-vector", "fmla", "f32", 64, 4, "f32", 128, 8, 128, 13},
  {{ &setup, &fmla_za_f32_f32_vgx4_ilp14, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP32, four vectors)", "FEAT_SME2", "za-vector", "fmla", "f32", 64, 4, "f32", 128, 8, 128, 14},
  {{ &setup, &fmla_za_f32_f32_vgx4_ilp15, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP32, four vectors)", "FEAT_SME2", "za-vector", "fmla", "f32", 64, 4, "f32", 128, 8, 128, 15},
  {{ &setup, &fmla_za_f32_f32_vgx4_ilp16, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP32, four vectors)", "FEAT_SME2", "za-vector", "fmla", "f32", 64, 4, "f32", 128, 8, 128, 16},
  {{ &setup, &fmla_za_f64_f64_vgx2_ilp1, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP64, two vectors)", "FEAT_SME2", "za-vector", "fmla", "f64", 16, 2, "f64", 32, 4, 32, 1},
  {{ &setup, &fmla_za_f64_f64_vgx2_ilp2, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP64, two vectors)", "FEAT_SME2", "za-vector", "fmla", "f64", 16, 2, "f64", 32, 4, 32, 2},
  {{ &setup, &fmla_za_f64_f64_vgx2_ilp3, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP64, two vectors)", "FEAT_SME2", "za-vector", "fmla", "f64", 16, 2, "f64", 32, 4, 32, 3},
  {{ &setup, &fmla_za_f64_f64_vgx2_ilp4, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP64, two vectors)", "FEAT_SME2", "za-vector", "fmla", "f64", 16, 2, "f64", 32, 4, 32, 4},
  {{ &setup, &fmla_za_f64_f64_vgx2_ilp5, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP64, two vectors)", "FEAT_SME2", "za-vector", "fmla", "f64", 16, 2, "f64", 32, 4, 32, 5},
  {{ &setup, &fmla_za_f64_f64_vgx2_ilp6, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP64, two vectors)", "FEAT_SME2", "za-vector", "fmla", "f64", 16, 2, "f64", 32, 4, 32, 6},
  {{ &setup, &fmla_za_f64_f64_vgx2_ilp7, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP64, two vectors)", "FEAT_SME2", "za-vector", "fmla", "f64", 16, 2, "f64", 32, 4, 32, 7},
  {{ &setup, &fmla_za_f64_f64_vgx2_ilp8, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP64, two vectors)", "FEAT_SME2", "za-vector", "fmla", "f64", 16, 2, "f64", 32, 4, 32, 8},
  {{ &setup, &fmla_za_f64_f64_vgx2_ilp9, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP64, two vectors)", "FEAT_SME2", "za-vector", "fmla", "f64", 16, 2, "f64", 32, 4, 32, 9},
  {{ &setup, &fmla_za_f64_f64_vgx2_ilp10, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP64, two vectors)", "FEAT_SME2", "za-vector", "fmla", "f64", 16, 2, "f64", 32, 4, 32, 10},
  {{ &setup, &fmla_za_f64_f64_vgx2_ilp11, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP64, two vectors)", "FEAT_SME2", "za-vector", "fmla", "f64", 16, 2, "f64", 32, 4, 32, 11},
  {{ &setup, &fmla_za_f64_f64_vgx2_ilp12, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP64, two vectors)", "FEAT_SME2", "za-vector", "fmla", "f64", 16, 2, "f64", 32, 4, 32, 12},
  {{ &setup, &fmla_za_f64_f64_vgx2_ilp13, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP64, two vectors)", "FEAT_SME2", "za-vector", "fmla", "f64", 16, 2, "f64", 32, 4, 32, 13},
  {{ &setup, &fmla_za_f64_f64_vgx2_ilp14, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP64, two vectors)", "FEAT_SME2", "za-vector", "fmla", "f64", 16, 2, "f64", 32, 4, 32, 14},
  {{ &setup, &fmla_za_f64_f64_vgx2_ilp15, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP64, two vectors)", "FEAT_SME2", "za-vector", "fmla", "f64", 16, 2, "f64", 32, 4, 32, 15},
  {{ &setup, &fmla_za_f64_f64_vgx2_ilp16, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP64, two vectors)", "FEAT_SME2", "za-vector", "fmla", "f64", 16, 2, "f64", 32, 4, 32, 16},
  {{ &setup, &fmla_za_f64_f64_vgx4_ilp1, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP64, four vectors)", "FEAT_SME2", "za-vector", "fmla", "f64", 32, 4, "f64", 64, 8, 64, 1},
  {{ &setup, &fmla_za_f64_f64_vgx4_ilp2, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP64, four vectors)", "FEAT_SME2", "za-vector", "fmla", "f64", 32, 4, "f64", 64, 8, 64, 2},
  {{ &setup, &fmla_za_f64_f64_vgx4_ilp3, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP64, four vectors)", "FEAT_SME2", "za-vector", "fmla", "f64", 32, 4, "f64", 64, 8, 64, 3},
  {{ &setup, &fmla_za_f64_f64_vgx4_ilp4, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP64, four vectors)", "FEAT_SME2", "za-vector", "fmla", "f64", 32, 4, "f64", 64, 8, 64, 4},
  {{ &setup, &fmla_za_f64_f64_vgx4_ilp5, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP64, four vectors)", "FEAT_SME2", "za-vector", "fmla", "f64", 32, 4, "f64", 64, 8, 64, 5},
  {{ &setup, &fmla_za_f64_f64_vgx4_ilp6, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP64, four vectors)", "FEAT_SME2", "za-vector", "fmla", "f64", 32, 4, "f64", 64, 8, 64, 6},
  {{ &setup, &fmla_za_f64_f64_vgx4_ilp7, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP64, four vectors)", "FEAT_SME2", "za-vector", "fmla", "f64", 32, 4, "f64", 64, 8, 64, 7},
  {{ &setup, &fmla_za_f64_f64_vgx4_ilp8, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP64, four vectors)", "FEAT_SME2", "za-vector", "fmla", "f64", 32, 4, "f64", 64, 8, 64, 8},
  {{ &setup, &fmla_za_f64_f64_vgx4_ilp9, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP64, four vectors)", "FEAT_SME2", "za-vector", "fmla", "f64", 32, 4, "f64", 64, 8, 64, 9},
  {{ &setup, &fmla_za_f64_f64_vgx4_ilp10, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP64, four vectors)", "FEAT_SME2", "za-vector", "fmla", "f64", 32, 4, "f64", 64, 8, 64, 10},
  {{ &setup, &fmla_za_f64_f64_vgx4_ilp11, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP64, four vectors)", "FEAT_SME2", "za-vector", "fmla", "f64", 32, 4, "f64", 64, 8, 64, 11},
  {{ &setup, &fmla_za_f64_f64_vgx4_ilp12, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP64, four vectors)", "FEAT_SME2", "za-vector", "fmla", "f64", 32, 4, "f64", 64, 8, 64, 12},
  {{ &setup, &fmla_za_f64_f64_vgx4_ilp13, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP64, four vectors)", "FEAT_SME2", "za-vector", "fmla", "f64", 32, 4, "f64", 64, 8, 64, 13},
  {{ &setup, &fmla_za_f64_f64_vgx4_ilp14, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP64, four vectors)", "FEAT_SME2", "za-vector", "fmla", "f64", 32, 4, "f64", 64, 8, 64, 14},
  {{ &setup, &fmla_za_f64_f64_vgx4_ilp15, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP64, four vectors)", "FEAT_SME2", "za-vector", "fmla", "f64", 32, 4, "f64", 64, 8, 64, 15},
  {{ &setup, &fmla_za_f64_f64_vgx4_ilp16, &teardown }, "Multiply-Accumulate (floating-point)", "FMLA (FP64, four vectors)", "FEAT_SME2", "za-vector", "fmla", "f64", 32, 4, "f64", 64, 8, 64, 16},
  {{ &setup, &fmlal_za_f32_f16_vgx2_ilp1, &teardown }, "Multiply-Accumulate (floating-point)", "FMLAL (FP16 to FP32, two vectors)", "FEAT_SME2", "za-double-vector", "fmlal", "f32", 64, 4, "f16", 128, 4, 128, 1},
  {{ &setup, &fmlal_za_f32_f16_vgx2_ilp2, &teardown }, "Multiply-Accumulate (floating-point)", "FMLAL (FP16 to FP32, two vectors)", "FEAT_SME2", "za-double-vector", "fmlal", "f32", 64, 4, "f16", 128, 4, 128, 2},
  {{ &setup, &fmlal_za_f32_f16_vgx2_ilp3, &teardown }, "Multiply-Accumulate (floating-point)", "FMLAL (FP16 to FP32, two vectors)", "FEAT_SME2", "za-double-vector", "fmlal", "f32", 64, 4, "f16", 128, 4, 128, 3},
  {{ &setup, &fmlal_za_f32_f16_vgx2_ilp4, &teardown }, "Multiply-Accumulate (floating-point)", "FMLAL (FP16 to FP32, two vectors)", "FEAT_SME2", "za-double-vector", "fmlal", "f32", 64, 4, "f16", 128, 4, 128, 4},
  {{ &setup, &fmlal_za_f32_f16_vgx2_ilp5, &teardown }, "Multiply-Accumulate (floating-point)", "FMLAL (FP16 to FP32, two vectors)", "FEAT_SME2", "za-double-vector", "fmlal", "f32", 64, 4, "f16", 128, 4, 128, 5},
  {{ &setup, &fmlal_za_f32_f16_vgx2_ilp6, &teardown }, "Multiply-Accumulate (floating-point)", "FMLAL (FP16 to FP32, two vectors)", "FEAT_SME2", "za-double-vector", "fmlal", "f32", 64, 4, "f16", 128, 4, 128, 6},
  {{ &setup, &fmlal_za_f32_f16_vgx2_ilp7, &teardown }, "Multiply-Accumulate (floating-point)", "FMLAL (FP16 to FP32, two vectors)", "FEAT_SME2", "za-double-vector", "fmlal", "f32", 64, 4, "f16", 128, 4, 128, 7},
  {{ &setup, &fmlal_za_f32_f16_vgx2_ilp8, &teardown }, "Multiply-Accumulate (floating-point)", "FMLAL (FP16 to FP32, two vectors)", "FEAT_SME2", "za-double-vector", "fmlal", "f32", 64, 4, "f16", 128, 4, 128, 8},
  {{ &setup, &fmlal_za_f32_f16_vgx2_ilp9, &teardown }, "Multiply-Accumulate (floating-point)", "FMLAL (FP16 to FP32, two vectors)", "FEAT_SME2", "za-double-vector", "fmlal", "f32", 64, 4, "f16", 128, 4, 128, 9},
  {{ &setup, &fmlal_za_f32_f16_vgx2_ilp10, &teardown }, "Multiply-Accumulate (floating-point)", "FMLAL (FP16 to FP32, two vectors)", "FEAT_SME2", "za-double-vector", "fmlal", "f32", 64, 4, "f16", 128, 4, 128, 10},
  {{ &setup, &fmlal_za_f32_f16_vgx2_ilp11, &teardown }, "Multiply-Accumulate (floating-point)", "FMLAL (FP16 to FP32, two vectors)", "FEAT_SME2", "za-double-vector", "fmlal", "f32", 64, 4, "f16", 128, 4, 128, 11},
  {{ &setup, &fmlal_za_f32_f16_vgx2_ilp12, &teardown }, "Multiply-Accumulate (floating-point)", "FMLAL (FP16 to FP32, two vectors)", "FEAT_SME2", "za-double-vector", "fmlal", "f32", 64, 4, "f16", 128, 4, 128, 12},
  {{ &setup, &fmlal_za_f32_f16_vgx2_ilp13, &teardown }, "Multiply-Accumulate (floating-point)", "FMLAL (FP16 to FP32, two vectors)", "FEAT_SME2", "za-double-vector", "fmlal", "f32", 64, 4, "f16", 128, 4, 128, 13},
  {{ &setup, &fmlal_za_f32_f16_vgx2_ilp14, &teardown }, "Multiply-Accumulate (floating-point)", "FMLAL (FP16 to FP32, two vectors)", "FEAT_SME2", "za-double-vector", "fmlal", "f32", 64, 4, "f16", 128, 4, 128, 14},
  {{ &setup, &fmlal_za_f32_f16_vgx2_ilp15, &teardown }, "Multiply-Accumulate (floating-point)", "FMLAL (FP16 to FP32, two vectors)", "FEAT_SME2", "za-double-vector", "fmlal", "f32", 64, 4, "f16", 128, 4, 128, 15},
  {{ &setup, &fmlal_za_f32_f16_vgx2_ilp16, &teardown }, "Multiply-Accumulate (floating-point)", "FMLAL (FP16 to FP32, two vectors)", "FEAT_SME2", "za-double-vector", "fmlal", "f32", 64, 4, "f16", 128, 4, 128, 16},
  {{ &setup, &fmlal_za_f32_f16_vgx4_ilp1, &teardown }, "Multiply-Accumulate (floating-point)", "FMLAL (FP16 to FP32, four vectors)", "FEAT_SME2", "za-double-vector", "fmlal", "f32", 128, 8, "f16", 256, 8, 256, 1},
  {{ &setup, &fmlal_za_f32_f16_vgx4_ilp2, &teardown }, "Multiply-Accumulate (floating-point)", "FMLAL (FP16 to FP32, four vectors)", "FEAT_SME2", "za-double-vector", "fmlal", "f32", 128, 8, "f16", 256, 8, 256, 2},
  {{ &setup, &fmlal_za_f32_f16_vgx4_ilp3, &teardown }, "Multiply-Accumulate (floating-point)", "FMLAL (FP16 to FP32, four vectors)", "FEAT_SME2", "za-double-vector", "fmlal", "f32", 128, 8, "f16", 256, 8, 256, 3},
  {{ &setup, &fmlal_za_f32_f16_vgx4_ilp4, &teardown }, "Multiply-Accumulate (floating-point)", "FMLAL (FP16 to FP32, four vectors)", "FEAT_SME2", "za-double-vector", "fmlal", "f32", 128, 8, "f16", 256, 8, 256, 4},
  {{ &setup, &fmlal_za_f32_f16_vgx4_ilp5, &teardown }, "Multiply-Accumulate (floating-point)", "FMLAL (FP16 to FP32, four vectors)", "FEAT_SME2", "za-double-vector", "fmlal", "f32", 128, 8, "f16", 256, 8, 256, 5},
  {{ &setup, &fmlal_za_f32_f16_vgx4_ilp6, &teardown }, "Multiply-Accumulate (floating-point)", "FMLAL (FP16 to FP32, four vectors)", "FEAT_SME2", "za-double-vector", "fmlal", "f32", 128, 8, "f16", 256, 8, 256, 6},
  {{ &setup, &fmlal_za_f32_f16_vgx4_ilp7, &teardown }, "Multiply-Accumulate (floating-point)", "FMLAL (FP16 to FP32, four vectors)", "FEAT_SME2", "za-double-vector", "fmlal", "f32", 128, 8, "f16", 256, 8, 256, 7},
  {{ &setup, &fmlal_za_f32_f16_vgx4_ilp8, &teardown }, "Multiply-Accumulate (floating-point)", "FMLAL (FP16 to FP32, four vectors)", "FEAT_SME2", "za-double-vector", "fmlal", "f32", 128, 8, "f16", 256, 8, 256, 8},
  {{ &setup, &bfmlal_za_f32_b16_vgx2_ilp1, &teardown }, "Multiply-Accumulate (floating-point)", "BFMLAL (BF16 to FP32, two vectors)", "FEAT_SME2", "za-double-vector", "bfmlal", "f32", 64, 4, "b16", 128, 4, 128, 1},
  {{ &setup, &bfmlal_za_f32_b16_vgx2_ilp2, &teardown }, "Multiply-Accumulate (floating-point)", "BFMLAL (BF16 to FP32, two vectors)", "FEAT_SME2", "za-double-vector", "bfmlal", "f32", 64, 4, "b16", 128, 4, 128, 2},
  {{ &setup, &bfmlal_za_f32_b16_vgx2_ilp3, &teardown }, "Multiply-Accumulate (floating-point)", "BFMLAL (BF16 to FP32, two vectors)", "FEAT_SME2", "za-double-vector", "bfmlal", "f32", 64, 4, "b16", 128, 4, 128, 3},
  {{ &setup, &bfmlal_za_f32_b16_vgx2_ilp4, &teardown }, "Multiply-Accumulate (floating-point)", "BFMLAL (BF16 to FP32, two vectors)", "FEAT_SME2", "za-double-vector", "bfmlal", "f32", 64, 4, "b16", 128, 4, 128, 4},
  {{ &setup, &bfmlal_za_f32_b16_vgx2_ilp5, &teardown }, "Multiply-Accumulate (floating-point)", "BFMLAL (BF16 to FP32, two vectors)", "FEAT_SME2", "za-double-vector", "bfmlal", "f32", 64, 4, "b16", 128, 4, 128, 5},
  {{ &setup, &bfmlal_za_f32_b16_vgx2_ilp6, &teardown }, "Multiply-Accumulate (floating-point)", "BFMLAL (BF16 to FP32, two vectors)", "FEAT_SME2", "za-double-vector", "bfmlal", "f32", 64, 4, "b16", 128, 4, 128, 6},
  {{ &setup, &bfmlal_za_f32_b16_vgx2_ilp7, &teardown }, "Multiply-Accumulate (floating-point)", "BFMLAL (BF16 to FP32, two vectors)", "FEAT_SME2", "za-double-vector", "bfmlal", "f32", 64, 4, "b16", 128, 4, 128, 7},
  {{ &setup, &bfmlal_za_f32_b16_vgx2_ilp8, &teardown }, "Multiply-Accumulate (floating-point)", "BFMLAL (BF16 to FP32, two vectors)", "FEAT_SME2", "za-double-vector", "bfmlal", "f32", 64, 4, "b16", 128, 4, 128, 8},
  {{ &setup, &bfmlal_za_f32_b16_vgx2_ilp9, &teardown }, "Multiply-Accumulate (floating-point)", "BFMLAL (BF16 to FP32, two vectors)", "FEAT_SME2", "za-double-vector", "bfmlal", "f32", 64, 4, "b16", 128, 4, 128, 9},
  {{ &setup, &bfmlal_za_f32_b16_vgx2_ilp10, &teardown }, "Multiply-Accumulate (floating-point)", "BFMLAL (BF16 to FP32, two vectors)", "FEAT_SME2", "za-double-vector", "bfmlal", "f32", 64, 4, "b16", 128, 4, 128, 10},
  {{ &setup, &bfmlal_za_f32_b16_vgx2_ilp11, &teardown }, "Multiply-Accumulate (floating-point)", "BFMLAL (BF16 to FP32, two vectors)", "FEAT_SME2", "za-double-vector", "bfmlal", "f32", 64, 4, "b16", 128, 4, 128, 11},
  {{ &setup, &bfmlal_za_f32_b16_vgx2_ilp12, &teardown }, "Multiply-Accumulate (floating-point)", "BFMLAL (BF16 to FP32, two vectors)", "FEAT_SME2", "za-double-vector", "bfmlal", "f32", 64, 4, "b16", 128, 4, 128, 12},
  {{ &setup, &bfmlal_za_f32_b16_vgx2_ilp13, &teardown }, "Multiply-Accumulate (floating-point)", "BFMLAL (BF16 to FP32, two vectors)", "FEAT_SME2", "za-double-vector", "bfmlal", "f32", 64, 4, "b16", 128, 4, 128, 13},
  {{ &setup, &bfmlal_za_f32_b16_vgx2_ilp14, &teardown }, "Multiply-Accumulate (floating-point)", "BFMLAL (BF16 to FP32, two vectors)", "FEAT_SME2", "za-double-vector", "bfmlal", "f32", 64, 4, "b16", 128, 4, 128, 14},
  {{ &setup, &bfmlal_za_f32_b16_vgx2_ilp15, &teardown }, "Multiply-Accumulate (floating-point)", "BFMLAL (BF16 to FP32, two vectors)", "FEAT_SME2", "za-double-vector", "bfmlal", "f32", 64, 4, "b16", 128, 4, 128, 15},
  {{ &setup, &bfmlal_za_f32_b16_vgx2_ilp16, &teardown }, "Multiply-Accumulate (floating-point)", "BFMLAL (BF16 to FP32, two vectors)", "FEAT_SME2", "za-double-vector", "bfmlal", "f32", 64, 4, "b16", 128, 4, 128, 16},
  {{ &setup, &bfmlal_za_f32_b16_vgx4_ilp1, &teardown }, "Multiply-Accumulate (floating-point)", "BFMLAL (BF16 to FP32, four vectors)", "FEAT_SME2", "za-double-vector", "bfmlal", "f32", 128, 8, "b16", 256, 8, 256, 1},
  {{ &setup, &bfmlal_za_f32_b16_vgx4_ilp2, &teardown }, "Multiply-Accumulate (floating-point)", "BFMLAL (BF16 to FP32, four vectors)", "FEAT_SME2", "za-double-vector", "bfmlal", "f32", 128, 8, "b16", 256, 8, 256, 2},
  {{ &setup, &bfmlal_za_f32_b16_vgx4_ilp3, &teardown }, "Multiply-Accumulate (floating-point)", "BFMLAL (BF16 to FP32, four vectors)", "FEAT_SME2", "za-double-vector", "bfmlal", "f32", 128, 8, "b16", 256, 8, 256, 3},
  {{ &setup, &bfmlal_za_f32_b16_vgx4_ilp4, &teardown }, "Multiply-Accumulate (floating-point)", "BFMLAL (BF16 to FP32, four vectors)", "FEAT_SME2", "za-double-vector", "bfmlal", "f32", 128, 8, "b16", 256, 8, 256, 4},
  {{ &setup, &bfmlal_za_f32_b16_vgx4_ilp5, &teardown }, "Multiply-Accumulate (floating-point)", "BFMLAL (BF16 to FP32, four vectors)", "FEAT_SME2", "za-double-vector", "bfmlal", "f32", 128, 8, "b16", 256, 8, 256, 5},
  {{ &setup, &bfmlal_za_f32_b16_vgx4_ilp6, &teardown }, "Multiply-Accumulate (floating-point)", "BFMLAL (BF16 to FP32, four vectors)", "FEAT_SME2", "za-double-vector", "bfmlal", "f32", 128, 8, "b16", 256, 8, 256, 6},
  {{ &setup, &bfmlal_za_f32_b16_vgx4_ilp7, &teardown }, "Multiply-Accumulate (floating-point)", "BFMLAL (BF16 to FP32, four vectors)", "FEAT_SME2", "za-double-vector", "bfmlal", "f32", 128, 8, "b16", 256, 8, 256, 7},
  {{ &setup, &bfmlal_za_f32_b16_vgx4_ilp8, &teardown }, "Multiply-Accumulate (floating-point)", "BFMLAL (BF16 to FP32, four vectors)", "FEAT_SME2", "za-double-vector", "bfmlal", "f32", 128, 8, "b16", 256, 8, 256, 8},
  {{ &setup, &mla_i8_i8_ilp1, &teardown }, "Multiply-Accumulate (integer)", "MLA (I8, one vector)", "FEAT_SME", "z-register", "mla", "i8", 64, 1, "i8", 128, 2, 128, 1},
  {{ &setup, &mla_i8_i8_ilp2, &teardown }, "Multiply-Accumulate (integer)", "MLA (I8, one vector)", "FEAT_SME", "z-register", "mla", "i8", 64, 1, "i8", 128, 2, 128, 2},
  {{ &setup, &mla_i8_i8_ilp3, &teardown }, "Multiply-Accumulate (integer)", "MLA (I8, one vector)", "FEAT_SME", "z-register", "mla", "i8", 64, 1, "i8", 128, 2, 128, 3},
  {{ &setup, &mla_i8_i8_ilp4, &teardown }, "Multiply-Accumulate (integer)", "MLA (I8, one vector)", "FEAT_SME", "z-register", "mla", "i8", 64, 1, "i8", 128, 2, 128, 4},
  {{ &setup, &mla_i8_i8_ilp5, &teardown }, "Multiply-Accumulate (integer)", "MLA (I8, one vector)", "FEAT_SME", "z-register", "mla", "i8", 64, 1, "i8", 128, 2, 128, 5},
  {{ &setup, &mla_i8_i8_ilp6, &teardown }, "Multiply-Accumulate (integer)", "MLA (I8, one vector)", "FEAT_SME", "z-register", "mla", "i8", 64, 1, "i8", 128, 2, 128, 6},
  {{ &setup, &mla_i8_i8_ilp7, &teardown }, "Multiply-Accumulate (integer)", "MLA (I8, one vector)", "FEAT_SME", "z-register", "mla", "i8", 64, 1, "i8", 128, 2, 128, 7},
  {{ &setup, &mla_i8_i8_ilp8, &teardown }, "Multiply-Accumulate (integer)", "MLA (I8, one vector)", "FEAT_SME", "z-register", "mla", "i8", 64, 1, "i8", 128, 2, 128, 8},
  {{ &setup, &mla_i8_i8_ilp9, &teardown }, "Multiply-Accumulate (integer)", "MLA (I8, one vector)", "FEAT_SME", "z-register", "mla", "i8", 64, 1, "i8", 128, 2, 128, 9},
  {{ &setup, &mla_i8_i8_ilp10, &teardown }, "Multiply-Accumulate (integer)", "MLA (I8, one vector)", "FEAT_SME", "z-register", "mla", "i8", 64, 1, "i8", 128, 2, 128, 10},
  {{ &setup, &mla_i8_i8_ilp11, &teardown }, "Multiply-Accumulate (integer)", "MLA (I8, one vector)", "FEAT_SME", "z-register", "mla", "i8", 64, 1, "i8", 128, 2, 128, 11},
  {{ &setup, &mla_i8_i8_ilp12, &teardown }, "Multiply-Accumulate (integer)", "MLA (I8, one vector)", "FEAT_SME", "z-register", "mla", "i8", 64, 1, "i8", 128, 2, 128, 12},
  {{ &setup, &mla_i8_i8_ilp13, &teardown }, "Multiply-Accumulate (integer)", "MLA (I8, one vector)", "FEAT_SME", "z-register", "mla", "i8", 64, 1, "i8", 128, 2, 128, 13},
  {{ &setup, &mla_i8_i8_ilp14, &teardown }, "Multiply-Accumulate (integer)", "MLA (I8, one vector)", "FEAT_SME", "z-register", "mla", "i8", 64, 1, "i8", 128, 2, 128, 14},
  {{ &setup, &mla_i8_i8_ilp15, &teardown }, "Multiply-Accumulate (integer)", "MLA (I8, one vector)", "FEAT_SME", "z-register", "mla", "i8", 64, 1, "i8", 128, 2, 128, 15},
  {{ &setup, &mla_i8_i8_ilp16, &teardown }, "Multiply-Accumulate (integer)", "MLA (I8, one vector)", "FEAT_SME", "z-register", "mla", "i8", 64, 1, "i8", 128, 2, 128, 16},
  {{ &setup, &mla_i16_i16_ilp1, &teardown }, "Multiply-Accumulate (integer)", "MLA (I16, one vector)", "FEAT_SME", "z-register", "mla", "i16", 32, 1, "i16", 64, 2, 64, 1},
  {{ &setup, &mla_i16_i16_ilp2, &teardown }, "Multiply-Accumulate (integer)", "MLA (I16, one vector)", "FEAT_SME", "z-register", "mla", "i16", 32, 1, "i16", 64, 2, 64, 2},
  {{ &setup, &mla_i16_i16_ilp3, &teardown }, "Multiply-Accumulate (integer)", "MLA (I16, one vector)", "FEAT_SME", "z-register", "mla", "i16", 32, 1, "i16", 64, 2, 64, 3},
  {{ &setup, &mla_i16_i16_ilp4, &teardown }, "Multiply-Accumulate (integer)", "MLA (I16, one vector)", "FEAT_SME", "z-register", "mla", "i16", 32, 1, "i16", 64, 2, 64, 4},
  {{ &setup, &mla_i16_i16_ilp5, &teardown }, "Multiply-Accumulate (integer)", "MLA (I16, one vector)", "FEAT_SME", "z-register", "mla", "i16", 32, 1, "i16", 64, 2, 64, 5},
  {{ &setup, &mla_i16_i16_ilp6, &teardown }, "Multiply-Accumulate (integer)", "MLA (I16, one vector)", "FEAT_SME", "z-register", "mla", "i16", 32, 1, "i16", 64, 2, 64, 6},
  {{ &setup, &mla_i16_i16_ilp7, &teardown }, "Multiply-Accumulate (integer)", "MLA (I16, one vector)", "FEAT_SME", "z-register", "mla", "i16", 32, 1, "i16", 64, 2, 64, 7},
  {{ &setup, &mla_i16_i16_ilp8, &teardown }, "Multiply-Accumulate (integer)", "MLA (I16, one vector)", "FEAT_SME", "z-register", "mla", "i16", 32, 1, "i16", 64, 2, 64, 8},
  {{ &setup, &mla_i16_i16_ilp9, &teardown }, "Multiply-Accumulate (integer)", "MLA (I16, one vector)", "FEAT_SME", "z-register", "mla", "i16", 32, 1, "i16", 64, 2, 64, 9},
  {{ &setup, &mla_i16_i16_ilp10, &teardown }, "Multiply-Accumulate (integer)", "MLA (I16, one vector)", "FEAT_SME", "z-register", "mla", "i16", 32, 1, "i16", 64, 2, 64, 10},
  {{ &setup, &mla_i16_i16_ilp11, &teardown }, "Multiply-Accumulate (integer)", "MLA (I16, one vector)", "FEAT_SME", "z-register", "mla", "i16", 32, 1, "i16", 64, 2, 64, 11},
  {{ &setup, &mla_i16_i16_ilp12, &teardown }, "Multiply-Accumulate (integer)", "MLA (I16, one vector)", "FEAT_SME", "z-register", "mla", "i16", 32, 1, "i16", 64, 2, 64, 12},
  {{ &setup, &mla_i16_i16_ilp13, &teardown }, "Multiply-Accumulate (integer)", "MLA (I16, one vector)", "FEAT_SME", "z-register", "mla", "i16", 32, 1, "i16", 64, 2, 64, 13},
  {{ &setup, &mla_i16_i16_ilp14, &teardown }, "Multiply-Accumulate (integer)", "MLA (I16, one vector)", "FEAT_SME", "z-register", "mla", "i16", 32, 1, "i16", 64, 2, 64, 14},
  {{ &setup, &mla_i16_i16_ilp15, &teardown }, "Multiply-Accumulate (integer)", "MLA (I16, one vector)", "FEAT_SME", "z-register", "mla", "i16", 32, 1, "i16", 64, 2, 64, 15},
  {{ &setup, &mla_i16_i16_ilp16, &teardown }, "Multiply-Accumulate (integer)", "MLA (I16, one vector)", "FEAT_SME", "z-register", "mla", "i16", 32, 1, "i16", 64, 2, 64, 16},
  {{ &setup, &mla_i32_i32_ilp1, &teardown }, "Multiply-Accumulate (integer)", "MLA (I32, one vector)", "FEAT_SME", "z-register", "mla", "i32", 16, 1, "i32", 32, 2, 32, 1},
  {{ &setup, &mla_i32_i32_ilp2, &teardown }, "Multiply-Accumulate (integer)", "MLA (I32, one vector)", "FEAT_SME", "z-register", "mla", "i32", 16, 1, "i32", 32, 2, 32, 2},
  {{ &setup, &mla_i32_i32_ilp3, &teardown }, "Multiply-Accumulate (integer)", "MLA (I32, one vector)", "FEAT_SME", "z-register", "mla", "i32", 16, 1, "i32", 32, 2, 32, 3},
  {{ &setup, &mla_i32_i32_ilp4, &teardown }, "Multiply-Accumulate (integer)", "MLA (I32, one vector)", "FEAT_SME", "z-register", "mla", "i32", 16, 1, "i32", 32, 2, 32, 4},
  {{ &setup, &mla_i32_i32_ilp5, &teardown }, "Multiply-Accumulate (integer)", "MLA (I32, one vector)", "FEAT_SME", "z-register", "mla", "i32", 16, 1, "i32", 32, 2, 32, 5},
  {{ &setup, &mla_i32_i32_ilp6, &teardown }, "Multiply-Accumulate (integer)", "MLA (I32, one vector)", "FEAT_SME", "z-register", "mla", "i32", 16, 1, "i32", 32, 2, 32, 6},
  {{ &setup, &mla_i32_i32_ilp7, &teardown }, "Multiply-Accumulate (integer)", "MLA (I32, one vector)", "FEAT_SME", "z-register", "mla", "i32", 16, 1, "i32", 32, 2, 32, 7},
  {{ &setup, &mla_i32_i32_ilp8, &teardown }, "Multiply-Accumulate (integer)", "MLA (I32, one vector)", "FEAT_SME", "z-register", "mla", "i32", 16, 1, "i32", 32, 2, 32, 8},
  {{ &setup, &mla_i32_i32_ilp9, &teardown }, "Multiply-Accumulate (integer)", "MLA (I32, one vector)", "FEAT_SME", "z-register", "mla", "i32", 16, 1, "i32", 32, 2, 32, 9},
  {{ &setup, &mla_i32_i32_ilp10, &teardown }, "Multiply-Accumulate (integer)", "MLA (I32, one vector)", "FEAT_SME", "z-register", "mla", "i32", 16, 1, "i32", 32, 2, 32, 10},
  {{ &setup, &mla_i32_i32_ilp11, &teardown }, "Multiply-Accumulate (integer)", "MLA (I32, one vector)", "FEAT_SME", "z-register", "mla", "i32", 16, 1, "i32", 32, 2, 32, 11},
  {{ &setup, &mla_i32_i32_ilp12, &teardown }, "Multiply-Accumulate (integer)", "MLA (I32, one vector)", "FEAT_SME", "z-register", "mla", "i32", 16, 1, "i32", 32, 2, 32, 12},
  {{ &setup, &mla_i32_i32_ilp13, &teardown }, "Multiply-Accumulate (integer)", "MLA (I32, one vector)", "FEAT_SME", "z-register", "mla", "i32", 16, 1, "i32", 32, 2, 32, 13},
  {{ &setup, &mla_i32_i32_ilp14, &teardown }, "Multiply-Accumulate (integer)", "MLA (I32, one vector)", "FEAT_SME", "z-register", "mla", "i32", 16, 1, "i32", 32, 2, 32, 14},
  {{ &setup, &mla_i32_i32_ilp15, &teardown }, "Multiply-Accumulate (integer)", "MLA (I32, one vector)", "FEAT_SME", "z-register", "mla", "i32", 16, 1, "i32", 32, 2, 32, 15},
  {{ &setup, &mla_i32_i32_ilp16, &teardown }, "Multiply-Accumulate (integer)", "MLA (I32, one vector)", "FEAT_SME", "z-register", "mla", "i32", 16, 1, "i32", 32, 2, 32, 16},
  {{ &setup, &mla_i64_i64_ilp1, &teardown }, "Multiply-Accumulate (integer)", "MLA (I64, one vector)", "FEAT_SME", "z-register", "mla", "i64", 8, 1, "i64", 16, 2, 16, 1},
  {{ &setup, &mla_i64_i64_ilp2, &teardown }, "Multiply-Accumulate (integer)", "MLA (I64, one vector)", "FEAT_SME", "z-register", "mla", "i64", 8, 1, "i64", 16, 2, 16, 2},
  {{ &setup, &mla_i64_i64_ilp3, &teardown }, "Multiply-Accumulate (integer)", "MLA (I64, one vector)", "FEAT_SME", "z-register", "mla", "i64", 8, 1, "i64", 16, 2, 16, 3},
  {{ &setup, &mla_i64_i64_ilp4, &teardown }, "Multiply-Accumulate (integer)", "MLA (I64, one vector)", "FEAT_SME", "z-register", "mla", "i64", 8, 1, "i64", 16, 2, 16, 4},
  {{ &setup, &mla_i64_i64_ilp5, &teardown }, "Multiply-Accumulate (integer)", "MLA (I64, one vector)", "FEAT_SME", "z-register", "mla", "i64", 8, 1, "i64", 16, 2, 16, 5},
  {{ &setup, &mla_i64_i64_ilp6, &teardown }, "Multiply-Accumulate (integer)", "MLA (I64, one vector)", "FEAT_SME", "z-register", "mla", "i64", 8, 1, "i64", 16, 2, 16, 6},
  {{ &setup, &mla_i64_i64_ilp7, &teardown }, "Multiply-Accumulate (integer)", "MLA (I64, one vector)", "FEAT_SME", "z-register", "mla", "i64", 8, 1, "i64", 16, 2, 16, 7},
  {{ &setup, &mla_i64_i64_ilp8, &teardown }, "Multiply-Accumulate (integer)", "MLA (I64, one vector)", "FEAT_SME", "z-register", "mla", "i64", 8, 1, "i64", 16, 2, 16, 8},
  {{ &setup, &mla_i64_i64_ilp9, &teardown }, "Multiply-Accumulate (integer)", "MLA (I64, one vector)", "FEAT_SME", "z-register", "mla", "i64", 8, 1, "i64", 16, 2, 16, 9},
  {{ &setup, &mla_i64_i64_ilp10, &teardown }, "Multiply-Accumulate (integer)", "MLA (I64, one vector)", "FEAT_SME", "z-register", "mla", "i64", 8, 1, "i64", 16, 2, 16, 10},
  {{ &setup, &mla_i64_i64_ilp11, &teardown }, "Multiply-Accumulate (integer)", "MLA (I64, one vector)", "FEAT_SME", "z-register", "mla", "i64", 8, 1, "i64", 16, 2, 16, 11},
  {{ &setup, &mla_i64_i64_ilp12, &teardown }, "Multiply-Accumulate (integer)", "MLA (I64, one vector)", "FEAT_SME", "z-register", "mla", "i64", 8, 1, "i64", 16, 2, 16, 12},
  {{ &setup, &mla_i64_i64_ilp13, &teardown }, "Multiply-Accumulate (integer)", "MLA (I64, one vector)", "FEAT_SME", "z-register", "mla", "i64", 8, 1, "i64", 16, 2, 16, 13},
  {{ &setup, &mla_i64_i64_ilp14, &teardown }, "Multiply-Accumulate (integer)", "MLA (I64, one vector)", "FEAT_SME", "z-register", "mla", "i64", 8, 1, "i64", 16, 2, 16, 14},
  {{ &setup, &mla_i64_i64_ilp15, &teardown }, "Multiply-Accumulate (integer)", "MLA (I64, one vector)", "FEAT_SME", "z-register", "mla", "i64", 8, 1, "i64", 16, 2, 16, 15},
  {{ &setup, &mla_i64_i64_ilp16, &teardown }, "Multiply-Accumulate (integer)", "MLA (I64, one vector)", "FEAT_SME", "z-register", "mla", "i64", 8, 1, "i64", 16, 2, 16, 16},
  {{ &setup, &smlal_za_i32_i16_vgx2_ilp1, &teardown }, "Multiply-Accumulate (integer)", "SMLAL (I16 to I32, two vectors)", "FEAT_SME2", "za-double-vector", "smlal", "i32", 64, 4, "i16", 128, 4, 128, 1},
  {{ &setup, &smlal_za_i32_i16_vgx2_ilp2, &teardown }, "Multiply-Accumulate (integer)", "SMLAL (I16 to I32, two vectors)", "FEAT_SME2", "za-double-vector", "smlal", "i32", 64, 4, "i16", 128, 4, 128, 2},
  {{ &setup, &smlal_za_i32_i16_vgx2_ilp3, &teardown }, "Multiply-Accumulate (integer)", "SMLAL (I16 to I32, two vectors)", "FEAT_SME2", "za-double-vector", "smlal", "i32", 64, 4, "i16", 128, 4, 128, 3},
  {{ &setup, &smlal_za_i32_i16_vgx2_ilp4, &teardown }, "Multiply-Accumulate (integer)", "SMLAL (I16 to I32, two vectors)", "FEAT_SME2", "za-double-vector", "smlal", "i32", 64, 4, "i16", 128, 4, 128, 4},
  {{ &setup, &smlal_za_i32_i16_vgx2_ilp5, &teardown }, "Multiply-Accumulate (integer)", "SMLAL (I16 to I32, two vectors)", "FEAT_SME2", "za-double-vector", "smlal", "i32", 64, 4, "i16", 128, 4, 128, 5},
  {{ &setup, &smlal_za_i32_i16_vgx2_ilp6, &teardown }, "Multiply-Accumulate (integer)", "SMLAL (I16 to I32, two vectors)", "FEAT_SME2", "za-double-vector", "smlal", "i32", 64, 4, "i16", 128, 4, 128, 6},
  {{ &setup, &smlal_za_i32_i16_vgx2_ilp7, &teardown }, "Multiply-Accumulate (integer)", "SMLAL (I16 to I32, two vectors)", "FEAT_SME2", "za-double-vector", "smlal", "i32", 64, 4, "i16", 128, 4, 128, 7},
  {{ &setup, &smlal_za_i32_i16_vgx2_ilp8, &teardown }, "Multiply-Accumulate (integer)", "SMLAL (I16 to I32, two vectors)", "FEAT_SME2", "za-double-vector", "smlal", "i32", 64, 4, "i16", 128, 4, 128, 8},
  {{ &setup, &smlal_za_i32_i16_vgx2_ilp9, &teardown }, "Multiply-Accumulate (integer)", "SMLAL (I16 to I32, two vectors)", "FEAT_SME2", "za-double-vector", "smlal", "i32", 64, 4, "i16", 128, 4, 128, 9},
  {{ &setup, &smlal_za_i32_i16_vgx2_ilp10, &teardown }, "Multiply-Accumulate (integer)", "SMLAL (I16 to I32, two vectors)", "FEAT_SME2", "za-double-vector", "smlal", "i32", 64, 4, "i16", 128, 4, 128, 10},
  {{ &setup, &smlal_za_i32_i16_vgx2_ilp11, &teardown }, "Multiply-Accumulate (integer)", "SMLAL (I16 to I32, two vectors)", "FEAT_SME2", "za-double-vector", "smlal", "i32", 64, 4, "i16", 128, 4, 128, 11},
  {{ &setup, &smlal_za_i32_i16_vgx2_ilp12, &teardown }, "Multiply-Accumulate (integer)", "SMLAL (I16 to I32, two vectors)", "FEAT_SME2", "za-double-vector", "smlal", "i32", 64, 4, "i16", 128, 4, 128, 12},
  {{ &setup, &smlal_za_i32_i16_vgx2_ilp13, &teardown }, "Multiply-Accumulate (integer)", "SMLAL (I16 to I32, two vectors)", "FEAT_SME2", "za-double-vector", "smlal", "i32", 64, 4, "i16", 128, 4, 128, 13},
  {{ &setup, &smlal_za_i32_i16_vgx2_ilp14, &teardown }, "Multiply-Accumulate (integer)", "SMLAL (I16 to I32, two vectors)", "FEAT_SME2", "za-double-vector", "smlal", "i32", 64, 4, "i16", 128, 4, 128, 14},
  {{ &setup, &smlal_za_i32_i16_vgx2_ilp15, &teardown }, "Multiply-Accumulate (integer)", "SMLAL (I16 to I32, two vectors)", "FEAT_SME2", "za-double-vector", "smlal", "i32", 64, 4, "i16", 128, 4, 128, 15},
  {{ &setup, &smlal_za_i32_i16_vgx2_ilp16, &teardown }, "Multiply-Accumulate (integer)", "SMLAL (I16 to I32, two vectors)", "FEAT_SME2", "za-double-vector", "smlal", "i32", 64, 4, "i16", 128, 4, 128, 16},
  {{ &setup, &smlal_za_i32_i16_vgx4_ilp1, &teardown }, "Multiply-Accumulate (integer)", "SMLAL (I16 to I32, four vectors)", "FEAT_SME2", "za-double-vector", "smlal", "i32", 128, 8, "i16", 256, 8, 256, 1},
  {{ &setup, &smlal_za_i32_i16_vgx4_ilp2, &teardown }, "Multiply-Accumulate (integer)", "SMLAL (I16 to I32, four vectors)", "FEAT_SME2", "za-double-vector", "smlal", "i32", 128, 8, "i16", 256, 8, 256, 2},
  {{ &setup, &smlal_za_i32_i16_vgx4_ilp3, &teardown }, "Multiply-Accumulate (integer)", "SMLAL (I16 to I32, four vectors)", "FEAT_SME2", "za-double-vector", "smlal", "i32", 128, 8, "i16", 256, 8, 256, 3},
  {{ &setup, &smlal_za_i32_i16_vgx4_ilp4, &teardown }, "Multiply-Accumulate (integer)", "SMLAL (I16 to I32, four vectors)", "FEAT_SME2", "za-double-vector", "smlal", "i32", 128, 8, "i16", 256, 8, 256, 4},
  {{ &setup, &smlal_za_i32_i16_vgx4_ilp5, &teardown }, "Multiply-Accumulate (integer)", "SMLAL (I16 to I32, four vectors)", "FEAT_SME2", "za-double-vector", "smlal", "i32", 128, 8, "i16", 256, 8, 256, 5},
  {{ &setup, &smlal_za_i32_i16_vgx4_ilp6, &teardown }, "Multiply-Accumulate (integer)", "SMLAL (I16 to I32, four vectors)", "FEAT_SME2", "za-double-vector", "smlal", "i32", 128, 8, "i16", 256, 8, 256, 6},
  {{ &setup, &smlal_za_i32_i16_vgx4_ilp7, &teardown }, "Multiply-Accumulate (integer)", "SMLAL (I16 to I32, four vectors)", "FEAT_SME2", "za-double-vector", "smlal", "i32", 128, 8, "i16", 256, 8, 256, 7},
  {{ &setup, &smlal_za_i32_i16_vgx4_ilp8, &teardown }, "Multiply-Accumulate (integer)", "SMLAL (I16 to I32, four vectors)", "FEAT_SME2", "za-double-vector", "smlal", "i32", 128, 8, "i16", 256, 8, 256, 8},
  {{ &setup, &smlall_za_i32_i8_vgx2_ilp1, &teardown }, "Multiply-Accumulate (integer)", "SMLALL (I8 to I32, two vectors)", "FEAT_SME2", "za-quad-vector", "smlall", "i32", 128, 8, "i8", 256, 4, 256, 1},
  {{ &setup, &smlall_za_i32_i8_vgx2_ilp2, &teardown }, "Multiply-Accumulate (integer)", "SMLALL (I8 to I32, two vectors)", "FEAT_SME2", "za-quad-vector", "smlall", "i32", 128, 8, "i8", 256, 4, 256, 2},
  {{ &setup, &smlall_za_i32_i8_vgx2_ilp3, &teardown }, "Multiply-Accumulate (integer)", "SMLALL (I8 to I32, two vectors)", "FEAT_SME2", "za-quad-vector", "smlall", "i32", 128, 8, "i8", 256, 4, 256, 3},
  {{ &setup, &smlall_za_i32_i8_vgx2_ilp4, &teardown }, "Multiply-Accumulate (integer)", "SMLALL (I8 to I32, two vectors)", "FEAT_SME2", "za-quad-vector", "smlall", "i32", 128, 8, "i8", 256, 4, 256, 4},
  {{ &setup, &smlall_za_i32_i8_vgx2_ilp5, &teardown }, "Multiply-Accumulate (integer)", "SMLALL (I8 to I32, two vectors)", "FEAT_SME2", "za-quad-vector", "smlall", "i32", 128, 8, "i8", 256, 4, 256, 5},
  {{ &setup, &smlall_za_i32_i8_vgx2_ilp6, &teardown }, "Multiply-Accumulate (integer)", "SMLALL (I8 to I32, two vectors)", "FEAT_SME2", "za-quad-vector", "smlall", "i32", 128, 8, "i8", 256, 4, 256, 6},
  {{ &setup, &smlall_za_i32_i8_vgx2_ilp7, &teardown }, "Multiply-Accumulate (integer)", "SMLALL (I8 to I32, two vectors)", "FEAT_SME2", "za-quad-vector", "smlall", "i32", 128, 8, "i8", 256, 4, 256, 7},
  {{ &setup, &smlall_za_i32_i8_vgx2_ilp8, &teardown }, "Multiply-Accumulate (integer)", "SMLALL (I8 to I32, two vectors)", "FEAT_SME2", "za-quad-vector", "smlall", "i32", 128, 8, "i8", 256, 4, 256, 8},
  {{ &setup, &smlall_za_i32_i8_vgx4_ilp1, &teardown }, "Multiply-Accumulate (integer)", "SMLALL (I8 to I32, four vectors)", "FEAT_SME2", "za-quad-vector", "smlall", "i32", 256, 16, "i8", 512, 8, 512, 1},
  {{ &setup, &smlall_za_i32_i8_vgx4_ilp2, &teardown }, "Multiply-Accumulate (integer)", "SMLALL (I8 to I32, four vectors)", "FEAT_SME2", "za-quad-vector", "smlall", "i32", 256, 16, "i8", 512, 8, 512, 2},
  {{ &setup, &smlall_za_i32_i8_vgx4_ilp3, &teardown }, "Multiply-Accumulate (integer)", "SMLALL (I8 to I32, four vectors)", "FEAT_SME2", "za-quad-vector", "smlall", "i32", 256, 16, "i8", 512, 8, 512, 3},
  {{ &setup, &smlall_za_i32_i8_vgx4_ilp4, &teardown }, "Multiply-Accumulate (integer)", "SMLALL (I8 to I32, four vectors)", "FEAT_SME2", "za-quad-vector", "smlall", "i32", 256, 16, "i8", 512, 8, 512, 4},
  {{ &setup, &smlall_za_i64_i16_vgx2_ilp1, &teardown }, "Multiply-Accumulate (integer)", "SMLALL (I16 to I64, two vectors)", "FEAT_SME2", "za-quad-vector", "smlall", "i64", 64, 8, "i16", 128, 4, 128, 1},
  {{ &setup, &smlall_za_i64_i16_vgx2_ilp2, &teardown }, "Multiply-Accumulate (integer)", "SMLALL (I16 to I64, two vectors)", "FEAT_SME2", "za-quad-vector", "smlall", "i64", 64, 8, "i16", 128, 4, 128, 2},
  {{ &setup, &smlall_za_i64_i16_vgx2_ilp3, &teardown }, "Multiply-Accumulate (integer)", "SMLALL (I16 to I64, two vectors)", "FEAT_SME2", "za-quad-vector", "smlall", "i64", 64, 8, "i16", 128, 4, 128, 3},
  {{ &setup, &smlall_za_i64_i16_vgx2_ilp4, &teardown }, "Multiply-Accumulate (integer)", "SMLALL (I16 to I64, two vectors)", "FEAT_SME2", "za-quad-vector", "smlall", "i64", 64, 8, "i16", 128, 4, 128, 4},
  {{ &setup, &smlall_za_i64_i16_vgx2_ilp5, &teardown }, "Multiply-Accumulate (integer)", "SMLALL (I16 to I64, two vectors)", "FEAT_SME2", "za-quad-vector", "smlall", "i64", 64, 8, "i16", 128, 4, 128, 5},
  {{ &setup, &smlall_za_i64_i16_vgx2_ilp6, &teardown }, "Multiply-Accumulate (integer)", "SMLALL (I16 to I64, two vectors)", "FEAT_SME2", "za-quad-vector", "smlall", "i64", 64, 8, "i16", 128, 4, 128, 6},
  {{ &setup, &smlall_za_i64_i16_vgx2_ilp7, &teardown }, "Multiply-Accumulate (integer)", "SMLALL (I16 to I64, two vectors)", "FEAT_SME2", "za-quad-vector", "smlall", "i64", 64, 8, "i16", 128, 4, 128, 7},
  {{ &setup, &smlall_za_i64_i16_vgx2_ilp8, &teardown }, "Multiply-Accumulate (integer)", "SMLALL (I16 to I64, two vectors)", "FEAT_SME2", "za-quad-vector", "smlall", "i64", 64, 8, "i16", 128, 4, 128, 8},
  {{ &setup, &smlall_za_i64_i16_vgx4_ilp1, &teardown }, "Multiply-Accumulate (integer)", "SMLALL (I16 to I64, four vectors)", "FEAT_SME2", "za-quad-vector", "smlall", "i64", 128, 16, "i16", 256, 8, 256, 1},
  {{ &setup, &smlall_za_i64_i16_vgx4_ilp2, &teardown }, "Multiply-Accumulate (integer)", "SMLALL (I16 to I64, four vectors)", "FEAT_SME2", "za-quad-vector", "smlall", "i64", 128, 16, "i16", 256, 8, 256, 2},
  {{ &setup, &smlall_za_i64_i16_vgx4_ilp3, &teardown }, "Multiply-Accumulate (integer)", "SMLALL (I16 to I64, four vectors)", "FEAT_SME2", "za-quad-vector", "smlall", "i64", 128, 16, "i16", 256, 8, 256, 3},
  {{ &setup, &smlall_za_i64_i16_vgx4_ilp4, &teardown }, "Multiply-Accumulate (integer)", "SMLALL (I16 to I64, four vectors)", "FEAT_SME2", "za-quad-vector", "smlall", "i64", 128, 16, "i16", 256, 8, 256, 4},
  {{ &setup, &fmopa_za_f16_f16_ilp1, &teardown }, "Outer Product (floating-point)", "FMOPA (FP16)", "FEAT_SME_F16F16", "za-tile", "fmopa", "f16", 1024, 32, "f16", 64, 2, 2048, 1},
  {{ &setup, &fmopa_za_f16_f16_ilp2, &teardown }, "Outer Product (floating-point)", "FMOPA (FP16)", "FEAT_SME_F16F16", "za-tile", "fmopa", "f16", 1024, 32, "f16", 64, 2, 2048, 2},
  {{ &setup, &fmopa_za_f32_f32_ilp1, &teardown }, "Outer Product (floating-point)", "FMOPA (FP32)", "SME_F32F32", "za-tile", "fmopa", "f32", 256, 16, "f32", 32, 2, 512, 1},
  {{ &setup, &fmopa_za_f32_f32_ilp2, &teardown }, "Outer Product (floating-point)", "FMOPA (FP32)", "SME_F32F32", "za-tile", "fmopa", "f32", 256, 16, "f32", 32, 2, 512, 2},
  {{ &setup, &fmopa_za_f32_f32_ilp3, &teardown }, "Outer Product (floating-point)", "FMOPA (FP32)", "SME_F32F32", "za-tile", "fmopa", "f32", 256, 16, "f32", 32, 2, 512, 3},
  {{ &setup, &fmopa_za_f32_f32_ilp4, &teardown }, "Outer Product (floating-point)", "FMOPA (FP32)", "SME_F32F32", "za-tile", "fmopa", "f32", 256, 16, "f32", 32, 2, 512, 4},
  {{ &setup, &fmopa_za_f64_f64_ilp1, &teardown }, "Outer Product (floating-point)", "FMOPA (FP64)", "FEAT_SME_F64F64", "za-tile", "fmopa", "f64", 64, 8, "f64", 16, 2, 128, 1},
  {{ &setup, &fmopa_za_f64_f64_ilp2, &teardown }, "Outer Product (floating-point)", "FMOPA (FP64)", "FEAT_SME_F64F64", "za-tile", "fmopa", "f64", 64, 8, "f64", 16, 2, 128, 2},
  {{ &setup, &fmopa_za_f64_f64_ilp3, &teardown }, "Outer Product (floating-point)", "FMOPA (FP64)", "FEAT_SME_F64F64", "za-tile", "fmopa", "f64", 64, 8, "f64", 16, 2, 128, 3},
  {{ &setup, &fmopa_za_f64_f64_ilp4, &teardown }, "Outer Product (floating-point)", "FMOPA (FP64)", "FEAT_SME_F64F64", "za-tile", "fmopa", "f64", 64, 8, "f64", 16, 2, 128, 4},
  {{ &setup, &fmopa_za_f64_f64_ilp5, &teardown }, "Outer Product (floating-point)", "FMOPA (FP64)", "FEAT_SME_F64F64", "za-tile", "fmopa", "f64", 64, 8, "f64", 16, 2, 128, 5},
  {{ &setup, &fmopa_za_f64_f64_ilp6, &teardown }, "Outer Product (floating-point)", "FMOPA (FP64)", "FEAT_SME_F64F64", "za-tile", "fmopa", "f64", 64, 8, "f64", 16, 2, 128, 6},
  {{ &setup, &fmopa_za_f64_f64_ilp7, &teardown }, "Outer Product (floating-point)", "FMOPA (FP64)", "FEAT_SME_F64F64", "za-tile", "fmopa", "f64", 64, 8, "f64", 16, 2, 128, 7},
  {{ &setup, &fmopa_za_f64_f64_ilp8, &teardown }, "Outer Product (floating-point)", "FMOPA (FP64)", "FEAT_SME_F64F64", "za-tile", "fmopa", "f64", 64, 8, "f64", 16, 2, 128, 8},
  {{ &setup, &fmopa_za_f32_f16_ilp1, &teardown }, "Outer Product (floating-point)", "FMOPA (FP16 into FP32, 2-way)", "SME_F16F32", "za-tile", "fmopa", "f32", 256, 16, "f16", 64, 2, 1024, 1},
  {{ &setup, &fmopa_za_f32_f16_ilp2, &teardown }, "Outer Product (floating-point)", "FMOPA (FP16 into FP32, 2-way)", "SME_F16F32", "za-tile", "fmopa", "f32", 256, 16, "f16", 64, 2, 1024, 2},
  {{ &setup, &fmopa_za_f32_f16_ilp3, &teardown }, "Outer Product (floating-point)", "FMOPA (FP16 into FP32, 2-way)", "SME_F16F32", "za-tile", "fmopa", "f32", 256, 16, "f16", 64, 2, 1024, 3},
  {{ &setup, &fmopa_za_f32_f16_ilp4, &teardown }, "Outer Product (floating-point)", "FMOPA (FP16 into FP32, 2-way)", "SME_F16F32", "za-tile", "fmopa", "f32", 256, 16, "f16", 64, 2, 1024, 4},
  {{ &setup, &bfmopa_za_f32_b16_ilp1, &teardown }, "Outer Product (floating-point)", "BFMOPA (BF16 into FP32, 2-way)", "SME_B16F32", "za-tile", "bfmopa", "f32", 256, 16, "b16", 64, 2, 1024, 1},
  {{ &setup, &bfmopa_za_f32_b16_ilp2, &teardown }, "Outer Product (floating-point)", "BFMOPA (BF16 into FP32, 2-way)", "SME_B16F32", "za-tile", "bfmopa", "f32", 256, 16, "b16", 64, 2, 1024, 2},
  {{ &setup, &bfmopa_za_f32_b16_ilp3, &teardown }, "Outer Product (floating-point)", "BFMOPA (BF16 into FP32, 2-way)", "SME_B16F32", "za-tile", "bfmopa", "f32", 256, 16, "b16", 64, 2, 1024, 3},
  {{ &setup, &bfmopa_za_f32_b16_ilp4, &teardown }, "Outer Product (floating-point)", "BFMOPA (BF16 into FP32, 2-way)", "SME_B16F32", "za-tile", "bfmopa", "f32", 256, 16, "b16", 64, 2, 1024, 4},
  {{ &setup, &smopa_za_i32_i16_ilp1, &teardown }, "Outer Product (integer)", "SMOPA (I16 into I32, 2-way)", "SME_I16I32", "za-tile", "smopa", "i32", 256, 16, "i16", 64, 2, 1024, 1},
  {{ &setup, &smopa_za_i32_i16_ilp2, &teardown }, "Outer Product (integer)", "SMOPA (I16 into I32, 2-way)", "SME_I16I32", "za-tile", "smopa", "i32", 256, 16, "i16", 64, 2, 1024, 2},
  {{ &setup, &smopa_za_i32_i16_ilp3, &teardown }, "Outer Product (integer)", "SMOPA (I16 into I32, 2-way)", "SME_I16I32", "za-tile", "smopa", "i32", 256, 16, "i16", 64, 2, 1024, 3},
  {{ &setup, &smopa_za_i32_i16_ilp4, &teardown }, "Outer Product (integer)", "SMOPA (I16 into I32, 2-way)", "SME_I16I32", "za-tile", "smopa", "i32", 256, 16, "i16", 64, 2, 1024, 4},
  {{ &setup, &smopa_za_i32_i8_ilp1, &teardown }, "Outer Product (integer)", "SMOPA (I8 into I32, 4-way)", "SME_I8I32", "za-tile", "smopa", "i32", 256, 16, "i8", 128, 2, 2048, 1},
  {{ &setup, &smopa_za_i32_i8_ilp2, &teardown }, "Outer Product (integer)", "SMOPA (I8 into I32, 4-way)", "SME_I8I32", "za-tile", "smopa", "i32", 256, 16, "i8", 128, 2, 2048, 2},
  {{ &setup, &smopa_za_i32_i8_ilp3, &teardown }, "Outer Product (integer)", "SMOPA (I8 into I32, 4-way)", "SME_I8I32", "za-tile", "smopa", "i32", 256, 16, "i8", 128, 2, 2048, 3},
  {{ &setup, &smopa_za_i32_i8_ilp4, &teardown }, "Outer Product (integer)", "SMOPA (I8 into I32, 4-way)", "SME_I8I32", "za-tile", "smopa", "i32", 256, 16, "i8", 128, 2, 2048, 4},
  {{ &setup, &smopa_za_i64_i16_ilp1, &teardown }, "Outer Product (integer)", "SMOPA (I16 into I64, 4-way)", "FEAT_SME_I16I64", "za-tile", "smopa", "i64", 64, 8, "i16", 64, 2, 512, 1},
  {{ &setup, &smopa_za_i64_i16_ilp2, &teardown }, "Outer Product (integer)", "SMOPA (I16 into I64, 4-way)", "FEAT_SME_I16I64", "za-tile", "smopa", "i64", 64, 8, "i16", 64, 2, 512, 2},
  {{ &setup, &smopa_za_i64_i16_ilp3, &teardown }, "Outer Product (integer)", "SMOPA (I16 into I64, 4-way)", "FEAT_SME_I16I64", "za-tile", "smopa", "i64", 64, 8, "i16", 64, 2, 512, 3},
  {{ &setup, &smopa_za_i64_i16_ilp4, &teardown }, "Outer Product (integer)", "SMOPA (I16 into I64, 4-way)", "FEAT_SME_I16I64", "za-tile", "smopa", "i64", 64, 8, "i16", 64, 2, 512, 4},
  {{ &setup, &smopa_za_i64_i16_ilp5, &teardown }, "Outer Product (integer)", "SMOPA (I16 into I64, 4-way)", "FEAT_SME_I16I64", "za-tile", "smopa", "i64", 64, 8, "i16", 64, 2, 512, 5},
  {{ &setup, &smopa_za_i64_i16_ilp6, &teardown }, "Outer Product (integer)", "SMOPA (I16 into I64, 4-way)", "FEAT_SME_I16I64", "za-tile", "smopa", "i64", 64, 8, "i16", 64, 2, 512, 6},
  {{ &setup, &smopa_za_i64_i16_ilp7, &teardown }, "Outer Product (integer)", "SMOPA (I16 into I64, 4-way)", "FEAT_SME_I16I64", "za-tile", "smopa", "i64", 64, 8, "i16", 64, 2, 512, 7},
  {{ &setup, &smopa_za_i64_i16_ilp8, &teardown }, "Outer Product (integer)", "SMOPA (I16 into I64, 4-way)", "FEAT_SME_I16I64", "za-tile", "smopa", "i64", 64, 8, "i16", 64, 2, 512, 8}
};

CONST_PTR(op_benchmark_t) op_benchmarks = benchmarks;
const size_t op_benchmarks_count = sizeof(benchmarks)/sizeof(benchmarks[0]);

