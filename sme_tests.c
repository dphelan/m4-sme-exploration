// generated by tools/gen_tests.py, do not edit!
#include <time.h>
#include "sme.h"

static const size_t N_ITERATIONS = 100000000;

// Estimate peak fused multiply and accumulate to ZA rates

double sme_fmla_f32_VGx4_64(void) {
  // each FMLA operates on 4 pairs of 16-wide fp32 registers, multiplies the pairwise 
  // elements and accumulates the results into 4 ZA tile slices, for the total of 64 FMAs or 128 FLOPS"
  //
  // we need 16 FMLA instructions to output 64 ZA tile slices"
  double flops_per_iteration = 16*128;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "mov x9, #8                                                  \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmla za.s[w8, 0, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 1, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 2, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 3, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 4, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 5, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 6, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 7, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w9, 0, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w9, 1, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w9, 2, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w9, 3, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w9, 4, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w9, 5, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w9, 6, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w9, 7, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8", "x9"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmla_f32_VGx4_60(void) {
  // each FMLA operates on 4 pairs of 16-wide fp32 registers, multiplies the pairwise 
  // elements and accumulates the results into 4 ZA tile slices, for the total of 64 FMAs or 128 FLOPS"
  //
  // we need 15 FMLA instructions to output 60 ZA tile slices"
  double flops_per_iteration = 15*128;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "mov x9, #8                                                  \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmla za.s[w8, 0, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 1, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 2, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 3, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 4, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 5, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 6, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 7, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w9, 0, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w9, 1, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w9, 2, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w9, 3, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w9, 4, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w9, 5, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w9, 6, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8", "x9"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmla_f32_VGx4_56(void) {
  // each FMLA operates on 4 pairs of 16-wide fp32 registers, multiplies the pairwise 
  // elements and accumulates the results into 4 ZA tile slices, for the total of 64 FMAs or 128 FLOPS"
  //
  // we need 14 FMLA instructions to output 56 ZA tile slices"
  double flops_per_iteration = 14*128;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "mov x9, #8                                                  \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmla za.s[w8, 0, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 1, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 2, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 3, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 4, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 5, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 6, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 7, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w9, 0, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w9, 1, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w9, 2, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w9, 3, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w9, 4, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w9, 5, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8", "x9"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmla_f32_VGx4_52(void) {
  // each FMLA operates on 4 pairs of 16-wide fp32 registers, multiplies the pairwise 
  // elements and accumulates the results into 4 ZA tile slices, for the total of 64 FMAs or 128 FLOPS"
  //
  // we need 13 FMLA instructions to output 52 ZA tile slices"
  double flops_per_iteration = 13*128;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "mov x9, #8                                                  \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmla za.s[w8, 0, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 1, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 2, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 3, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 4, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 5, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 6, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 7, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w9, 0, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w9, 1, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w9, 2, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w9, 3, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w9, 4, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8", "x9"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmla_f32_VGx4_48(void) {
  // each FMLA operates on 4 pairs of 16-wide fp32 registers, multiplies the pairwise 
  // elements and accumulates the results into 4 ZA tile slices, for the total of 64 FMAs or 128 FLOPS"
  //
  // we need 12 FMLA instructions to output 48 ZA tile slices"
  double flops_per_iteration = 12*128;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "mov x9, #8                                                  \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmla za.s[w8, 0, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 1, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 2, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 3, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 4, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 5, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 6, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 7, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w9, 0, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w9, 1, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w9, 2, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w9, 3, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8", "x9"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmla_f32_VGx4_44(void) {
  // each FMLA operates on 4 pairs of 16-wide fp32 registers, multiplies the pairwise 
  // elements and accumulates the results into 4 ZA tile slices, for the total of 64 FMAs or 128 FLOPS"
  //
  // we need 11 FMLA instructions to output 44 ZA tile slices"
  double flops_per_iteration = 11*128;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "mov x9, #8                                                  \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmla za.s[w8, 0, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 1, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 2, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 3, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 4, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 5, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 6, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 7, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w9, 0, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w9, 1, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w9, 2, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8", "x9"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmla_f32_VGx4_40(void) {
  // each FMLA operates on 4 pairs of 16-wide fp32 registers, multiplies the pairwise 
  // elements and accumulates the results into 4 ZA tile slices, for the total of 64 FMAs or 128 FLOPS"
  //
  // we need 10 FMLA instructions to output 40 ZA tile slices"
  double flops_per_iteration = 10*128;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "mov x9, #8                                                  \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmla za.s[w8, 0, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 1, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 2, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 3, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 4, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 5, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 6, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 7, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w9, 0, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w9, 1, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8", "x9"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmla_f32_VGx4_36(void) {
  // each FMLA operates on 4 pairs of 16-wide fp32 registers, multiplies the pairwise 
  // elements and accumulates the results into 4 ZA tile slices, for the total of 64 FMAs or 128 FLOPS"
  //
  // we need 9 FMLA instructions to output 36 ZA tile slices"
  double flops_per_iteration = 9*128;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "mov x9, #8                                                  \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmla za.s[w8, 0, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 1, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 2, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 3, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 4, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 5, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 6, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 7, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w9, 0, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8", "x9"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmla_f32_VGx4_32(void) {
  // each FMLA operates on 4 pairs of 16-wide fp32 registers, multiplies the pairwise 
  // elements and accumulates the results into 4 ZA tile slices, for the total of 64 FMAs or 128 FLOPS"
  //
  // we need 8 FMLA instructions to output 32 ZA tile slices"
  double flops_per_iteration = 8*128;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmla za.s[w8, 0, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 1, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 2, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 3, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 4, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 5, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 6, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 7, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmla_f32_VGx4_28(void) {
  // each FMLA operates on 4 pairs of 16-wide fp32 registers, multiplies the pairwise 
  // elements and accumulates the results into 4 ZA tile slices, for the total of 64 FMAs or 128 FLOPS"
  //
  // we need 7 FMLA instructions to output 28 ZA tile slices"
  double flops_per_iteration = 7*128;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmla za.s[w8, 0, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 1, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 2, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 3, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 4, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 5, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 6, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmla_f32_VGx4_24(void) {
  // each FMLA operates on 4 pairs of 16-wide fp32 registers, multiplies the pairwise 
  // elements and accumulates the results into 4 ZA tile slices, for the total of 64 FMAs or 128 FLOPS"
  //
  // we need 6 FMLA instructions to output 24 ZA tile slices"
  double flops_per_iteration = 6*128;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmla za.s[w8, 0, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 1, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 2, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 3, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 4, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 5, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmla_f32_VGx4_20(void) {
  // each FMLA operates on 4 pairs of 16-wide fp32 registers, multiplies the pairwise 
  // elements and accumulates the results into 4 ZA tile slices, for the total of 64 FMAs or 128 FLOPS"
  //
  // we need 5 FMLA instructions to output 20 ZA tile slices"
  double flops_per_iteration = 5*128;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmla za.s[w8, 0, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 1, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 2, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 3, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 4, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmla_f32_VGx4_16(void) {
  // each FMLA operates on 4 pairs of 16-wide fp32 registers, multiplies the pairwise 
  // elements and accumulates the results into 4 ZA tile slices, for the total of 64 FMAs or 128 FLOPS"
  //
  // we need 4 FMLA instructions to output 16 ZA tile slices"
  double flops_per_iteration = 4*128;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmla za.s[w8, 0, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 1, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 2, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 3, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmla_f32_VGx4_12(void) {
  // each FMLA operates on 4 pairs of 16-wide fp32 registers, multiplies the pairwise 
  // elements and accumulates the results into 4 ZA tile slices, for the total of 64 FMAs or 128 FLOPS"
  //
  // we need 3 FMLA instructions to output 12 ZA tile slices"
  double flops_per_iteration = 3*128;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmla za.s[w8, 0, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 1, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 2, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmla_f32_VGx4_8(void) {
  // each FMLA operates on 4 pairs of 16-wide fp32 registers, multiplies the pairwise 
  // elements and accumulates the results into 4 ZA tile slices, for the total of 64 FMAs or 128 FLOPS"
  //
  // we need 2 FMLA instructions to output 8 ZA tile slices"
  double flops_per_iteration = 2*128;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmla za.s[w8, 0, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "  fmla za.s[w8, 1, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmla_f32_VGx4_4(void) {
  // each FMLA operates on 4 pairs of 16-wide fp32 registers, multiplies the pairwise 
  // elements and accumulates the results into 4 ZA tile slices, for the total of 64 FMAs or 128 FLOPS"
  //
  // we need 1 FMLA instructions to output 4 ZA tile slices"
  double flops_per_iteration = 1*128;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmla za.s[w8, 0, VGx4], {z0.s-z3.s}, {z4.s-z7.s}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}


double sme_fmla_f32_VGx2_64(void) {
  // each FMLA operates on 2 pairs of 16-wide fp32 registers, multiplies the pairwise 
  // elements and accumulates the results into 2 ZA tile slices, for the total of 32 FMAs or 64 FLOPS"
  //
  // we need 32 FMLA instructions to output 64 ZA tile slices"
  double flops_per_iteration = 32*64;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "mov x9, #8                                                  \n"
    "mov x10, #16                                                \n"
    "mov x11, #24                                                \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmla za.s[w8, 0, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 1, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 2, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 3, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 4, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 5, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 6, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 7, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 0, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 1, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 2, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 3, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 4, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 5, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 6, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 7, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w10, 0, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w10, 1, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w10, 2, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w10, 3, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w10, 4, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w10, 5, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w10, 6, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w10, 7, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w11, 0, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w11, 1, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w11, 2, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w11, 3, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w11, 4, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w11, 5, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w11, 6, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w11, 7, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8", "x9", "x10", "x11"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmla_f32_VGx2_62(void) {
  // each FMLA operates on 2 pairs of 16-wide fp32 registers, multiplies the pairwise 
  // elements and accumulates the results into 2 ZA tile slices, for the total of 32 FMAs or 64 FLOPS"
  //
  // we need 31 FMLA instructions to output 62 ZA tile slices"
  double flops_per_iteration = 31*64;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "mov x9, #8                                                  \n"
    "mov x10, #16                                                \n"
    "mov x11, #24                                                \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmla za.s[w8, 0, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 1, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 2, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 3, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 4, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 5, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 6, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 7, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 0, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 1, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 2, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 3, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 4, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 5, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 6, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 7, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w10, 0, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w10, 1, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w10, 2, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w10, 3, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w10, 4, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w10, 5, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w10, 6, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w10, 7, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w11, 0, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w11, 1, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w11, 2, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w11, 3, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w11, 4, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w11, 5, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w11, 6, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8", "x9", "x10", "x11"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmla_f32_VGx2_60(void) {
  // each FMLA operates on 2 pairs of 16-wide fp32 registers, multiplies the pairwise 
  // elements and accumulates the results into 2 ZA tile slices, for the total of 32 FMAs or 64 FLOPS"
  //
  // we need 30 FMLA instructions to output 60 ZA tile slices"
  double flops_per_iteration = 30*64;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "mov x9, #8                                                  \n"
    "mov x10, #16                                                \n"
    "mov x11, #24                                                \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmla za.s[w8, 0, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 1, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 2, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 3, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 4, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 5, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 6, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 7, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 0, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 1, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 2, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 3, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 4, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 5, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 6, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 7, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w10, 0, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w10, 1, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w10, 2, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w10, 3, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w10, 4, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w10, 5, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w10, 6, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w10, 7, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w11, 0, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w11, 1, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w11, 2, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w11, 3, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w11, 4, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w11, 5, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8", "x9", "x10", "x11"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmla_f32_VGx2_58(void) {
  // each FMLA operates on 2 pairs of 16-wide fp32 registers, multiplies the pairwise 
  // elements and accumulates the results into 2 ZA tile slices, for the total of 32 FMAs or 64 FLOPS"
  //
  // we need 29 FMLA instructions to output 58 ZA tile slices"
  double flops_per_iteration = 29*64;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "mov x9, #8                                                  \n"
    "mov x10, #16                                                \n"
    "mov x11, #24                                                \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmla za.s[w8, 0, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 1, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 2, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 3, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 4, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 5, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 6, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 7, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 0, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 1, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 2, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 3, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 4, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 5, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 6, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 7, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w10, 0, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w10, 1, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w10, 2, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w10, 3, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w10, 4, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w10, 5, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w10, 6, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w10, 7, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w11, 0, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w11, 1, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w11, 2, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w11, 3, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w11, 4, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8", "x9", "x10", "x11"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmla_f32_VGx2_56(void) {
  // each FMLA operates on 2 pairs of 16-wide fp32 registers, multiplies the pairwise 
  // elements and accumulates the results into 2 ZA tile slices, for the total of 32 FMAs or 64 FLOPS"
  //
  // we need 28 FMLA instructions to output 56 ZA tile slices"
  double flops_per_iteration = 28*64;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "mov x9, #8                                                  \n"
    "mov x10, #16                                                \n"
    "mov x11, #24                                                \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmla za.s[w8, 0, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 1, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 2, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 3, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 4, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 5, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 6, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 7, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 0, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 1, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 2, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 3, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 4, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 5, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 6, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 7, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w10, 0, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w10, 1, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w10, 2, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w10, 3, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w10, 4, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w10, 5, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w10, 6, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w10, 7, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w11, 0, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w11, 1, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w11, 2, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w11, 3, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8", "x9", "x10", "x11"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmla_f32_VGx2_54(void) {
  // each FMLA operates on 2 pairs of 16-wide fp32 registers, multiplies the pairwise 
  // elements and accumulates the results into 2 ZA tile slices, for the total of 32 FMAs or 64 FLOPS"
  //
  // we need 27 FMLA instructions to output 54 ZA tile slices"
  double flops_per_iteration = 27*64;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "mov x9, #8                                                  \n"
    "mov x10, #16                                                \n"
    "mov x11, #24                                                \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmla za.s[w8, 0, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 1, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 2, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 3, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 4, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 5, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 6, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 7, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 0, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 1, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 2, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 3, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 4, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 5, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 6, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 7, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w10, 0, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w10, 1, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w10, 2, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w10, 3, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w10, 4, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w10, 5, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w10, 6, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w10, 7, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w11, 0, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w11, 1, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w11, 2, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8", "x9", "x10", "x11"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmla_f32_VGx2_52(void) {
  // each FMLA operates on 2 pairs of 16-wide fp32 registers, multiplies the pairwise 
  // elements and accumulates the results into 2 ZA tile slices, for the total of 32 FMAs or 64 FLOPS"
  //
  // we need 26 FMLA instructions to output 52 ZA tile slices"
  double flops_per_iteration = 26*64;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "mov x9, #8                                                  \n"
    "mov x10, #16                                                \n"
    "mov x11, #24                                                \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmla za.s[w8, 0, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 1, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 2, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 3, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 4, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 5, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 6, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 7, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 0, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 1, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 2, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 3, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 4, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 5, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 6, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 7, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w10, 0, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w10, 1, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w10, 2, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w10, 3, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w10, 4, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w10, 5, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w10, 6, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w10, 7, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w11, 0, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w11, 1, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8", "x9", "x10", "x11"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmla_f32_VGx2_50(void) {
  // each FMLA operates on 2 pairs of 16-wide fp32 registers, multiplies the pairwise 
  // elements and accumulates the results into 2 ZA tile slices, for the total of 32 FMAs or 64 FLOPS"
  //
  // we need 25 FMLA instructions to output 50 ZA tile slices"
  double flops_per_iteration = 25*64;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "mov x9, #8                                                  \n"
    "mov x10, #16                                                \n"
    "mov x11, #24                                                \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmla za.s[w8, 0, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 1, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 2, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 3, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 4, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 5, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 6, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 7, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 0, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 1, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 2, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 3, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 4, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 5, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 6, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 7, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w10, 0, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w10, 1, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w10, 2, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w10, 3, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w10, 4, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w10, 5, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w10, 6, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w10, 7, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w11, 0, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8", "x9", "x10", "x11"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmla_f32_VGx2_48(void) {
  // each FMLA operates on 2 pairs of 16-wide fp32 registers, multiplies the pairwise 
  // elements and accumulates the results into 2 ZA tile slices, for the total of 32 FMAs or 64 FLOPS"
  //
  // we need 24 FMLA instructions to output 48 ZA tile slices"
  double flops_per_iteration = 24*64;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "mov x9, #8                                                  \n"
    "mov x10, #16                                                \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmla za.s[w8, 0, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 1, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 2, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 3, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 4, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 5, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 6, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 7, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 0, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 1, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 2, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 3, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 4, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 5, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 6, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 7, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w10, 0, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w10, 1, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w10, 2, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w10, 3, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w10, 4, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w10, 5, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w10, 6, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w10, 7, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8", "x9", "x10"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmla_f32_VGx2_46(void) {
  // each FMLA operates on 2 pairs of 16-wide fp32 registers, multiplies the pairwise 
  // elements and accumulates the results into 2 ZA tile slices, for the total of 32 FMAs or 64 FLOPS"
  //
  // we need 23 FMLA instructions to output 46 ZA tile slices"
  double flops_per_iteration = 23*64;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "mov x9, #8                                                  \n"
    "mov x10, #16                                                \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmla za.s[w8, 0, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 1, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 2, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 3, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 4, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 5, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 6, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 7, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 0, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 1, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 2, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 3, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 4, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 5, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 6, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 7, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w10, 0, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w10, 1, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w10, 2, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w10, 3, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w10, 4, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w10, 5, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w10, 6, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8", "x9", "x10"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmla_f32_VGx2_44(void) {
  // each FMLA operates on 2 pairs of 16-wide fp32 registers, multiplies the pairwise 
  // elements and accumulates the results into 2 ZA tile slices, for the total of 32 FMAs or 64 FLOPS"
  //
  // we need 22 FMLA instructions to output 44 ZA tile slices"
  double flops_per_iteration = 22*64;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "mov x9, #8                                                  \n"
    "mov x10, #16                                                \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmla za.s[w8, 0, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 1, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 2, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 3, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 4, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 5, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 6, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 7, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 0, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 1, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 2, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 3, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 4, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 5, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 6, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 7, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w10, 0, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w10, 1, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w10, 2, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w10, 3, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w10, 4, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w10, 5, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8", "x9", "x10"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmla_f32_VGx2_42(void) {
  // each FMLA operates on 2 pairs of 16-wide fp32 registers, multiplies the pairwise 
  // elements and accumulates the results into 2 ZA tile slices, for the total of 32 FMAs or 64 FLOPS"
  //
  // we need 21 FMLA instructions to output 42 ZA tile slices"
  double flops_per_iteration = 21*64;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "mov x9, #8                                                  \n"
    "mov x10, #16                                                \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmla za.s[w8, 0, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 1, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 2, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 3, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 4, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 5, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 6, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 7, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 0, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 1, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 2, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 3, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 4, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 5, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 6, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 7, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w10, 0, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w10, 1, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w10, 2, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w10, 3, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w10, 4, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8", "x9", "x10"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmla_f32_VGx2_40(void) {
  // each FMLA operates on 2 pairs of 16-wide fp32 registers, multiplies the pairwise 
  // elements and accumulates the results into 2 ZA tile slices, for the total of 32 FMAs or 64 FLOPS"
  //
  // we need 20 FMLA instructions to output 40 ZA tile slices"
  double flops_per_iteration = 20*64;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "mov x9, #8                                                  \n"
    "mov x10, #16                                                \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmla za.s[w8, 0, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 1, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 2, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 3, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 4, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 5, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 6, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 7, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 0, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 1, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 2, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 3, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 4, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 5, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 6, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 7, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w10, 0, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w10, 1, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w10, 2, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w10, 3, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8", "x9", "x10"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmla_f32_VGx2_38(void) {
  // each FMLA operates on 2 pairs of 16-wide fp32 registers, multiplies the pairwise 
  // elements and accumulates the results into 2 ZA tile slices, for the total of 32 FMAs or 64 FLOPS"
  //
  // we need 19 FMLA instructions to output 38 ZA tile slices"
  double flops_per_iteration = 19*64;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "mov x9, #8                                                  \n"
    "mov x10, #16                                                \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmla za.s[w8, 0, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 1, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 2, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 3, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 4, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 5, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 6, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 7, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 0, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 1, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 2, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 3, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 4, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 5, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 6, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 7, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w10, 0, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w10, 1, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w10, 2, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8", "x9", "x10"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmla_f32_VGx2_36(void) {
  // each FMLA operates on 2 pairs of 16-wide fp32 registers, multiplies the pairwise 
  // elements and accumulates the results into 2 ZA tile slices, for the total of 32 FMAs or 64 FLOPS"
  //
  // we need 18 FMLA instructions to output 36 ZA tile slices"
  double flops_per_iteration = 18*64;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "mov x9, #8                                                  \n"
    "mov x10, #16                                                \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmla za.s[w8, 0, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 1, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 2, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 3, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 4, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 5, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 6, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 7, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 0, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 1, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 2, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 3, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 4, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 5, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 6, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 7, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w10, 0, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "  fmla za.s[w10, 1, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8", "x9", "x10"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmla_f32_VGx2_34(void) {
  // each FMLA operates on 2 pairs of 16-wide fp32 registers, multiplies the pairwise 
  // elements and accumulates the results into 2 ZA tile slices, for the total of 32 FMAs or 64 FLOPS"
  //
  // we need 17 FMLA instructions to output 34 ZA tile slices"
  double flops_per_iteration = 17*64;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "mov x9, #8                                                  \n"
    "mov x10, #16                                                \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmla za.s[w8, 0, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 1, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 2, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 3, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 4, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 5, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 6, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 7, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 0, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 1, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 2, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 3, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 4, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 5, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 6, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 7, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w10, 0, VGx2], {z0.s-z1.s}, {z4.s-z5.s}         \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8", "x9", "x10"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmla_f32_VGx2_32(void) {
  // each FMLA operates on 2 pairs of 16-wide fp32 registers, multiplies the pairwise 
  // elements and accumulates the results into 2 ZA tile slices, for the total of 32 FMAs or 64 FLOPS"
  //
  // we need 16 FMLA instructions to output 32 ZA tile slices"
  double flops_per_iteration = 16*64;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "mov x9, #8                                                  \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmla za.s[w8, 0, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 1, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 2, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 3, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 4, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 5, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 6, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 7, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 0, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 1, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 2, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 3, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 4, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 5, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 6, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 7, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8", "x9"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmla_f32_VGx2_30(void) {
  // each FMLA operates on 2 pairs of 16-wide fp32 registers, multiplies the pairwise 
  // elements and accumulates the results into 2 ZA tile slices, for the total of 32 FMAs or 64 FLOPS"
  //
  // we need 15 FMLA instructions to output 30 ZA tile slices"
  double flops_per_iteration = 15*64;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "mov x9, #8                                                  \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmla za.s[w8, 0, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 1, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 2, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 3, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 4, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 5, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 6, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 7, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 0, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 1, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 2, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 3, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 4, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 5, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 6, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8", "x9"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmla_f32_VGx2_28(void) {
  // each FMLA operates on 2 pairs of 16-wide fp32 registers, multiplies the pairwise 
  // elements and accumulates the results into 2 ZA tile slices, for the total of 32 FMAs or 64 FLOPS"
  //
  // we need 14 FMLA instructions to output 28 ZA tile slices"
  double flops_per_iteration = 14*64;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "mov x9, #8                                                  \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmla za.s[w8, 0, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 1, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 2, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 3, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 4, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 5, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 6, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 7, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 0, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 1, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 2, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 3, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 4, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 5, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8", "x9"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmla_f32_VGx2_26(void) {
  // each FMLA operates on 2 pairs of 16-wide fp32 registers, multiplies the pairwise 
  // elements and accumulates the results into 2 ZA tile slices, for the total of 32 FMAs or 64 FLOPS"
  //
  // we need 13 FMLA instructions to output 26 ZA tile slices"
  double flops_per_iteration = 13*64;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "mov x9, #8                                                  \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmla za.s[w8, 0, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 1, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 2, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 3, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 4, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 5, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 6, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 7, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 0, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 1, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 2, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 3, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 4, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8", "x9"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmla_f32_VGx2_24(void) {
  // each FMLA operates on 2 pairs of 16-wide fp32 registers, multiplies the pairwise 
  // elements and accumulates the results into 2 ZA tile slices, for the total of 32 FMAs or 64 FLOPS"
  //
  // we need 12 FMLA instructions to output 24 ZA tile slices"
  double flops_per_iteration = 12*64;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "mov x9, #8                                                  \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmla za.s[w8, 0, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 1, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 2, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 3, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 4, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 5, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 6, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 7, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 0, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 1, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 2, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 3, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8", "x9"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmla_f32_VGx2_22(void) {
  // each FMLA operates on 2 pairs of 16-wide fp32 registers, multiplies the pairwise 
  // elements and accumulates the results into 2 ZA tile slices, for the total of 32 FMAs or 64 FLOPS"
  //
  // we need 11 FMLA instructions to output 22 ZA tile slices"
  double flops_per_iteration = 11*64;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "mov x9, #8                                                  \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmla za.s[w8, 0, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 1, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 2, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 3, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 4, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 5, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 6, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 7, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 0, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 1, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 2, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8", "x9"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmla_f32_VGx2_20(void) {
  // each FMLA operates on 2 pairs of 16-wide fp32 registers, multiplies the pairwise 
  // elements and accumulates the results into 2 ZA tile slices, for the total of 32 FMAs or 64 FLOPS"
  //
  // we need 10 FMLA instructions to output 20 ZA tile slices"
  double flops_per_iteration = 10*64;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "mov x9, #8                                                  \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmla za.s[w8, 0, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 1, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 2, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 3, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 4, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 5, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 6, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 7, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 0, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 1, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8", "x9"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmla_f32_VGx2_18(void) {
  // each FMLA operates on 2 pairs of 16-wide fp32 registers, multiplies the pairwise 
  // elements and accumulates the results into 2 ZA tile slices, for the total of 32 FMAs or 64 FLOPS"
  //
  // we need 9 FMLA instructions to output 18 ZA tile slices"
  double flops_per_iteration = 9*64;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "mov x9, #8                                                  \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmla za.s[w8, 0, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 1, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 2, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 3, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 4, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 5, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 6, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 7, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w9, 0, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8", "x9"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmla_f32_VGx2_16(void) {
  // each FMLA operates on 2 pairs of 16-wide fp32 registers, multiplies the pairwise 
  // elements and accumulates the results into 2 ZA tile slices, for the total of 32 FMAs or 64 FLOPS"
  //
  // we need 8 FMLA instructions to output 16 ZA tile slices"
  double flops_per_iteration = 8*64;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmla za.s[w8, 0, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 1, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 2, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 3, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 4, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 5, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 6, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 7, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmla_f32_VGx2_14(void) {
  // each FMLA operates on 2 pairs of 16-wide fp32 registers, multiplies the pairwise 
  // elements and accumulates the results into 2 ZA tile slices, for the total of 32 FMAs or 64 FLOPS"
  //
  // we need 7 FMLA instructions to output 14 ZA tile slices"
  double flops_per_iteration = 7*64;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmla za.s[w8, 0, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 1, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 2, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 3, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 4, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 5, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 6, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmla_f32_VGx2_12(void) {
  // each FMLA operates on 2 pairs of 16-wide fp32 registers, multiplies the pairwise 
  // elements and accumulates the results into 2 ZA tile slices, for the total of 32 FMAs or 64 FLOPS"
  //
  // we need 6 FMLA instructions to output 12 ZA tile slices"
  double flops_per_iteration = 6*64;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmla za.s[w8, 0, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 1, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 2, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 3, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 4, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 5, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmla_f32_VGx2_10(void) {
  // each FMLA operates on 2 pairs of 16-wide fp32 registers, multiplies the pairwise 
  // elements and accumulates the results into 2 ZA tile slices, for the total of 32 FMAs or 64 FLOPS"
  //
  // we need 5 FMLA instructions to output 10 ZA tile slices"
  double flops_per_iteration = 5*64;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmla za.s[w8, 0, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 1, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 2, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 3, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 4, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmla_f32_VGx2_8(void) {
  // each FMLA operates on 2 pairs of 16-wide fp32 registers, multiplies the pairwise 
  // elements and accumulates the results into 2 ZA tile slices, for the total of 32 FMAs or 64 FLOPS"
  //
  // we need 4 FMLA instructions to output 8 ZA tile slices"
  double flops_per_iteration = 4*64;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmla za.s[w8, 0, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 1, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 2, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 3, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmla_f32_VGx2_6(void) {
  // each FMLA operates on 2 pairs of 16-wide fp32 registers, multiplies the pairwise 
  // elements and accumulates the results into 2 ZA tile slices, for the total of 32 FMAs or 64 FLOPS"
  //
  // we need 3 FMLA instructions to output 6 ZA tile slices"
  double flops_per_iteration = 3*64;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmla za.s[w8, 0, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 1, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 2, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmla_f32_VGx2_4(void) {
  // each FMLA operates on 2 pairs of 16-wide fp32 registers, multiplies the pairwise 
  // elements and accumulates the results into 2 ZA tile slices, for the total of 32 FMAs or 64 FLOPS"
  //
  // we need 2 FMLA instructions to output 4 ZA tile slices"
  double flops_per_iteration = 2*64;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmla za.s[w8, 0, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "  fmla za.s[w8, 1, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmla_f32_VGx2_2(void) {
  // each FMLA operates on 2 pairs of 16-wide fp32 registers, multiplies the pairwise 
  // elements and accumulates the results into 2 ZA tile slices, for the total of 32 FMAs or 64 FLOPS"
  //
  // we need 1 FMLA instructions to output 2 ZA tile slices"
  double flops_per_iteration = 1*64;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmla za.s[w8, 0, VGx2], {z0.s-z1.s}, {z4.s-z5.s}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}


double sme_fmla_f64_VGx4_64(void) {
  // each FMLA operates on 4 pairs of 8-wide fp64 registers, multiplies the pairwise 
  // elements and accumulates the results into 4 ZA tile slices, for the total of 32 FMAs or 64 FLOPS"
  //
  // we need 16 FMLA instructions to output 64 ZA tile slices"
  double flops_per_iteration = 16*64;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "mov x9, #8                                                  \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmla za.d[w8, 0, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 1, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 2, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 3, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 4, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 5, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 6, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 7, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w9, 0, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w9, 1, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w9, 2, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w9, 3, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w9, 4, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w9, 5, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w9, 6, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w9, 7, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8", "x9"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmla_f64_VGx4_60(void) {
  // each FMLA operates on 4 pairs of 8-wide fp64 registers, multiplies the pairwise 
  // elements and accumulates the results into 4 ZA tile slices, for the total of 32 FMAs or 64 FLOPS"
  //
  // we need 15 FMLA instructions to output 60 ZA tile slices"
  double flops_per_iteration = 15*64;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "mov x9, #8                                                  \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmla za.d[w8, 0, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 1, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 2, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 3, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 4, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 5, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 6, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 7, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w9, 0, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w9, 1, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w9, 2, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w9, 3, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w9, 4, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w9, 5, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w9, 6, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8", "x9"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmla_f64_VGx4_56(void) {
  // each FMLA operates on 4 pairs of 8-wide fp64 registers, multiplies the pairwise 
  // elements and accumulates the results into 4 ZA tile slices, for the total of 32 FMAs or 64 FLOPS"
  //
  // we need 14 FMLA instructions to output 56 ZA tile slices"
  double flops_per_iteration = 14*64;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "mov x9, #8                                                  \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmla za.d[w8, 0, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 1, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 2, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 3, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 4, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 5, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 6, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 7, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w9, 0, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w9, 1, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w9, 2, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w9, 3, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w9, 4, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w9, 5, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8", "x9"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmla_f64_VGx4_52(void) {
  // each FMLA operates on 4 pairs of 8-wide fp64 registers, multiplies the pairwise 
  // elements and accumulates the results into 4 ZA tile slices, for the total of 32 FMAs or 64 FLOPS"
  //
  // we need 13 FMLA instructions to output 52 ZA tile slices"
  double flops_per_iteration = 13*64;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "mov x9, #8                                                  \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmla za.d[w8, 0, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 1, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 2, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 3, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 4, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 5, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 6, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 7, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w9, 0, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w9, 1, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w9, 2, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w9, 3, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w9, 4, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8", "x9"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmla_f64_VGx4_48(void) {
  // each FMLA operates on 4 pairs of 8-wide fp64 registers, multiplies the pairwise 
  // elements and accumulates the results into 4 ZA tile slices, for the total of 32 FMAs or 64 FLOPS"
  //
  // we need 12 FMLA instructions to output 48 ZA tile slices"
  double flops_per_iteration = 12*64;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "mov x9, #8                                                  \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmla za.d[w8, 0, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 1, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 2, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 3, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 4, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 5, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 6, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 7, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w9, 0, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w9, 1, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w9, 2, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w9, 3, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8", "x9"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmla_f64_VGx4_44(void) {
  // each FMLA operates on 4 pairs of 8-wide fp64 registers, multiplies the pairwise 
  // elements and accumulates the results into 4 ZA tile slices, for the total of 32 FMAs or 64 FLOPS"
  //
  // we need 11 FMLA instructions to output 44 ZA tile slices"
  double flops_per_iteration = 11*64;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "mov x9, #8                                                  \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmla za.d[w8, 0, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 1, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 2, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 3, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 4, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 5, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 6, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 7, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w9, 0, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w9, 1, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w9, 2, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8", "x9"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmla_f64_VGx4_40(void) {
  // each FMLA operates on 4 pairs of 8-wide fp64 registers, multiplies the pairwise 
  // elements and accumulates the results into 4 ZA tile slices, for the total of 32 FMAs or 64 FLOPS"
  //
  // we need 10 FMLA instructions to output 40 ZA tile slices"
  double flops_per_iteration = 10*64;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "mov x9, #8                                                  \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmla za.d[w8, 0, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 1, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 2, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 3, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 4, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 5, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 6, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 7, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w9, 0, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w9, 1, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8", "x9"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmla_f64_VGx4_36(void) {
  // each FMLA operates on 4 pairs of 8-wide fp64 registers, multiplies the pairwise 
  // elements and accumulates the results into 4 ZA tile slices, for the total of 32 FMAs or 64 FLOPS"
  //
  // we need 9 FMLA instructions to output 36 ZA tile slices"
  double flops_per_iteration = 9*64;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "mov x9, #8                                                  \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmla za.d[w8, 0, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 1, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 2, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 3, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 4, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 5, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 6, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 7, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w9, 0, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8", "x9"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmla_f64_VGx4_32(void) {
  // each FMLA operates on 4 pairs of 8-wide fp64 registers, multiplies the pairwise 
  // elements and accumulates the results into 4 ZA tile slices, for the total of 32 FMAs or 64 FLOPS"
  //
  // we need 8 FMLA instructions to output 32 ZA tile slices"
  double flops_per_iteration = 8*64;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmla za.d[w8, 0, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 1, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 2, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 3, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 4, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 5, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 6, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 7, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmla_f64_VGx4_28(void) {
  // each FMLA operates on 4 pairs of 8-wide fp64 registers, multiplies the pairwise 
  // elements and accumulates the results into 4 ZA tile slices, for the total of 32 FMAs or 64 FLOPS"
  //
  // we need 7 FMLA instructions to output 28 ZA tile slices"
  double flops_per_iteration = 7*64;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmla za.d[w8, 0, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 1, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 2, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 3, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 4, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 5, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 6, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmla_f64_VGx4_24(void) {
  // each FMLA operates on 4 pairs of 8-wide fp64 registers, multiplies the pairwise 
  // elements and accumulates the results into 4 ZA tile slices, for the total of 32 FMAs or 64 FLOPS"
  //
  // we need 6 FMLA instructions to output 24 ZA tile slices"
  double flops_per_iteration = 6*64;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmla za.d[w8, 0, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 1, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 2, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 3, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 4, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 5, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmla_f64_VGx4_20(void) {
  // each FMLA operates on 4 pairs of 8-wide fp64 registers, multiplies the pairwise 
  // elements and accumulates the results into 4 ZA tile slices, for the total of 32 FMAs or 64 FLOPS"
  //
  // we need 5 FMLA instructions to output 20 ZA tile slices"
  double flops_per_iteration = 5*64;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmla za.d[w8, 0, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 1, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 2, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 3, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 4, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmla_f64_VGx4_16(void) {
  // each FMLA operates on 4 pairs of 8-wide fp64 registers, multiplies the pairwise 
  // elements and accumulates the results into 4 ZA tile slices, for the total of 32 FMAs or 64 FLOPS"
  //
  // we need 4 FMLA instructions to output 16 ZA tile slices"
  double flops_per_iteration = 4*64;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmla za.d[w8, 0, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 1, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 2, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 3, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmla_f64_VGx4_12(void) {
  // each FMLA operates on 4 pairs of 8-wide fp64 registers, multiplies the pairwise 
  // elements and accumulates the results into 4 ZA tile slices, for the total of 32 FMAs or 64 FLOPS"
  //
  // we need 3 FMLA instructions to output 12 ZA tile slices"
  double flops_per_iteration = 3*64;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmla za.d[w8, 0, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 1, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 2, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmla_f64_VGx4_8(void) {
  // each FMLA operates on 4 pairs of 8-wide fp64 registers, multiplies the pairwise 
  // elements and accumulates the results into 4 ZA tile slices, for the total of 32 FMAs or 64 FLOPS"
  //
  // we need 2 FMLA instructions to output 8 ZA tile slices"
  double flops_per_iteration = 2*64;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmla za.d[w8, 0, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "  fmla za.d[w8, 1, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmla_f64_VGx4_4(void) {
  // each FMLA operates on 4 pairs of 8-wide fp64 registers, multiplies the pairwise 
  // elements and accumulates the results into 4 ZA tile slices, for the total of 32 FMAs or 64 FLOPS"
  //
  // we need 1 FMLA instructions to output 4 ZA tile slices"
  double flops_per_iteration = 1*64;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmla za.d[w8, 0, VGx4], {z0.d-z3.d}, {z4.d-z7.d}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}


double sme_fmla_f64_VGx2_64(void) {
  // each FMLA operates on 2 pairs of 8-wide fp64 registers, multiplies the pairwise 
  // elements and accumulates the results into 2 ZA tile slices, for the total of 16 FMAs or 32 FLOPS"
  //
  // we need 32 FMLA instructions to output 64 ZA tile slices"
  double flops_per_iteration = 32*32;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "mov x9, #8                                                  \n"
    "mov x10, #16                                                \n"
    "mov x11, #24                                                \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmla za.d[w8, 0, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 1, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 2, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 3, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 4, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 5, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 6, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 7, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 0, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 1, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 2, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 3, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 4, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 5, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 6, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 7, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w10, 0, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w10, 1, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w10, 2, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w10, 3, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w10, 4, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w10, 5, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w10, 6, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w10, 7, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w11, 0, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w11, 1, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w11, 2, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w11, 3, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w11, 4, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w11, 5, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w11, 6, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w11, 7, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8", "x9", "x10", "x11"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmla_f64_VGx2_62(void) {
  // each FMLA operates on 2 pairs of 8-wide fp64 registers, multiplies the pairwise 
  // elements and accumulates the results into 2 ZA tile slices, for the total of 16 FMAs or 32 FLOPS"
  //
  // we need 31 FMLA instructions to output 62 ZA tile slices"
  double flops_per_iteration = 31*32;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "mov x9, #8                                                  \n"
    "mov x10, #16                                                \n"
    "mov x11, #24                                                \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmla za.d[w8, 0, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 1, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 2, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 3, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 4, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 5, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 6, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 7, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 0, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 1, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 2, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 3, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 4, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 5, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 6, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 7, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w10, 0, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w10, 1, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w10, 2, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w10, 3, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w10, 4, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w10, 5, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w10, 6, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w10, 7, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w11, 0, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w11, 1, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w11, 2, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w11, 3, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w11, 4, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w11, 5, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w11, 6, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8", "x9", "x10", "x11"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmla_f64_VGx2_60(void) {
  // each FMLA operates on 2 pairs of 8-wide fp64 registers, multiplies the pairwise 
  // elements and accumulates the results into 2 ZA tile slices, for the total of 16 FMAs or 32 FLOPS"
  //
  // we need 30 FMLA instructions to output 60 ZA tile slices"
  double flops_per_iteration = 30*32;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "mov x9, #8                                                  \n"
    "mov x10, #16                                                \n"
    "mov x11, #24                                                \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmla za.d[w8, 0, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 1, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 2, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 3, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 4, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 5, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 6, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 7, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 0, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 1, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 2, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 3, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 4, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 5, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 6, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 7, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w10, 0, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w10, 1, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w10, 2, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w10, 3, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w10, 4, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w10, 5, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w10, 6, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w10, 7, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w11, 0, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w11, 1, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w11, 2, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w11, 3, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w11, 4, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w11, 5, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8", "x9", "x10", "x11"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmla_f64_VGx2_58(void) {
  // each FMLA operates on 2 pairs of 8-wide fp64 registers, multiplies the pairwise 
  // elements and accumulates the results into 2 ZA tile slices, for the total of 16 FMAs or 32 FLOPS"
  //
  // we need 29 FMLA instructions to output 58 ZA tile slices"
  double flops_per_iteration = 29*32;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "mov x9, #8                                                  \n"
    "mov x10, #16                                                \n"
    "mov x11, #24                                                \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmla za.d[w8, 0, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 1, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 2, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 3, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 4, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 5, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 6, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 7, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 0, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 1, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 2, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 3, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 4, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 5, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 6, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 7, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w10, 0, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w10, 1, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w10, 2, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w10, 3, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w10, 4, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w10, 5, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w10, 6, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w10, 7, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w11, 0, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w11, 1, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w11, 2, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w11, 3, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w11, 4, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8", "x9", "x10", "x11"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmla_f64_VGx2_56(void) {
  // each FMLA operates on 2 pairs of 8-wide fp64 registers, multiplies the pairwise 
  // elements and accumulates the results into 2 ZA tile slices, for the total of 16 FMAs or 32 FLOPS"
  //
  // we need 28 FMLA instructions to output 56 ZA tile slices"
  double flops_per_iteration = 28*32;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "mov x9, #8                                                  \n"
    "mov x10, #16                                                \n"
    "mov x11, #24                                                \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmla za.d[w8, 0, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 1, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 2, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 3, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 4, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 5, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 6, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 7, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 0, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 1, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 2, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 3, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 4, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 5, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 6, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 7, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w10, 0, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w10, 1, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w10, 2, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w10, 3, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w10, 4, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w10, 5, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w10, 6, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w10, 7, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w11, 0, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w11, 1, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w11, 2, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w11, 3, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8", "x9", "x10", "x11"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmla_f64_VGx2_54(void) {
  // each FMLA operates on 2 pairs of 8-wide fp64 registers, multiplies the pairwise 
  // elements and accumulates the results into 2 ZA tile slices, for the total of 16 FMAs or 32 FLOPS"
  //
  // we need 27 FMLA instructions to output 54 ZA tile slices"
  double flops_per_iteration = 27*32;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "mov x9, #8                                                  \n"
    "mov x10, #16                                                \n"
    "mov x11, #24                                                \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmla za.d[w8, 0, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 1, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 2, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 3, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 4, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 5, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 6, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 7, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 0, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 1, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 2, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 3, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 4, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 5, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 6, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 7, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w10, 0, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w10, 1, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w10, 2, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w10, 3, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w10, 4, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w10, 5, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w10, 6, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w10, 7, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w11, 0, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w11, 1, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w11, 2, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8", "x9", "x10", "x11"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmla_f64_VGx2_52(void) {
  // each FMLA operates on 2 pairs of 8-wide fp64 registers, multiplies the pairwise 
  // elements and accumulates the results into 2 ZA tile slices, for the total of 16 FMAs or 32 FLOPS"
  //
  // we need 26 FMLA instructions to output 52 ZA tile slices"
  double flops_per_iteration = 26*32;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "mov x9, #8                                                  \n"
    "mov x10, #16                                                \n"
    "mov x11, #24                                                \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmla za.d[w8, 0, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 1, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 2, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 3, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 4, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 5, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 6, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 7, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 0, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 1, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 2, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 3, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 4, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 5, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 6, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 7, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w10, 0, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w10, 1, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w10, 2, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w10, 3, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w10, 4, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w10, 5, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w10, 6, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w10, 7, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w11, 0, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w11, 1, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8", "x9", "x10", "x11"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmla_f64_VGx2_50(void) {
  // each FMLA operates on 2 pairs of 8-wide fp64 registers, multiplies the pairwise 
  // elements and accumulates the results into 2 ZA tile slices, for the total of 16 FMAs or 32 FLOPS"
  //
  // we need 25 FMLA instructions to output 50 ZA tile slices"
  double flops_per_iteration = 25*32;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "mov x9, #8                                                  \n"
    "mov x10, #16                                                \n"
    "mov x11, #24                                                \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmla za.d[w8, 0, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 1, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 2, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 3, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 4, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 5, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 6, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 7, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 0, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 1, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 2, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 3, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 4, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 5, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 6, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 7, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w10, 0, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w10, 1, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w10, 2, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w10, 3, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w10, 4, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w10, 5, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w10, 6, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w10, 7, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w11, 0, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8", "x9", "x10", "x11"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmla_f64_VGx2_48(void) {
  // each FMLA operates on 2 pairs of 8-wide fp64 registers, multiplies the pairwise 
  // elements and accumulates the results into 2 ZA tile slices, for the total of 16 FMAs or 32 FLOPS"
  //
  // we need 24 FMLA instructions to output 48 ZA tile slices"
  double flops_per_iteration = 24*32;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "mov x9, #8                                                  \n"
    "mov x10, #16                                                \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmla za.d[w8, 0, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 1, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 2, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 3, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 4, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 5, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 6, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 7, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 0, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 1, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 2, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 3, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 4, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 5, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 6, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 7, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w10, 0, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w10, 1, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w10, 2, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w10, 3, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w10, 4, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w10, 5, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w10, 6, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w10, 7, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8", "x9", "x10"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmla_f64_VGx2_46(void) {
  // each FMLA operates on 2 pairs of 8-wide fp64 registers, multiplies the pairwise 
  // elements and accumulates the results into 2 ZA tile slices, for the total of 16 FMAs or 32 FLOPS"
  //
  // we need 23 FMLA instructions to output 46 ZA tile slices"
  double flops_per_iteration = 23*32;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "mov x9, #8                                                  \n"
    "mov x10, #16                                                \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmla za.d[w8, 0, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 1, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 2, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 3, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 4, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 5, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 6, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 7, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 0, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 1, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 2, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 3, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 4, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 5, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 6, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 7, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w10, 0, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w10, 1, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w10, 2, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w10, 3, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w10, 4, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w10, 5, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w10, 6, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8", "x9", "x10"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmla_f64_VGx2_44(void) {
  // each FMLA operates on 2 pairs of 8-wide fp64 registers, multiplies the pairwise 
  // elements and accumulates the results into 2 ZA tile slices, for the total of 16 FMAs or 32 FLOPS"
  //
  // we need 22 FMLA instructions to output 44 ZA tile slices"
  double flops_per_iteration = 22*32;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "mov x9, #8                                                  \n"
    "mov x10, #16                                                \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmla za.d[w8, 0, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 1, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 2, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 3, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 4, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 5, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 6, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 7, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 0, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 1, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 2, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 3, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 4, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 5, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 6, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 7, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w10, 0, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w10, 1, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w10, 2, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w10, 3, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w10, 4, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w10, 5, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8", "x9", "x10"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmla_f64_VGx2_42(void) {
  // each FMLA operates on 2 pairs of 8-wide fp64 registers, multiplies the pairwise 
  // elements and accumulates the results into 2 ZA tile slices, for the total of 16 FMAs or 32 FLOPS"
  //
  // we need 21 FMLA instructions to output 42 ZA tile slices"
  double flops_per_iteration = 21*32;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "mov x9, #8                                                  \n"
    "mov x10, #16                                                \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmla za.d[w8, 0, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 1, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 2, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 3, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 4, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 5, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 6, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 7, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 0, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 1, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 2, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 3, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 4, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 5, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 6, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 7, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w10, 0, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w10, 1, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w10, 2, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w10, 3, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w10, 4, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8", "x9", "x10"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmla_f64_VGx2_40(void) {
  // each FMLA operates on 2 pairs of 8-wide fp64 registers, multiplies the pairwise 
  // elements and accumulates the results into 2 ZA tile slices, for the total of 16 FMAs or 32 FLOPS"
  //
  // we need 20 FMLA instructions to output 40 ZA tile slices"
  double flops_per_iteration = 20*32;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "mov x9, #8                                                  \n"
    "mov x10, #16                                                \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmla za.d[w8, 0, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 1, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 2, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 3, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 4, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 5, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 6, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 7, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 0, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 1, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 2, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 3, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 4, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 5, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 6, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 7, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w10, 0, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w10, 1, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w10, 2, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w10, 3, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8", "x9", "x10"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmla_f64_VGx2_38(void) {
  // each FMLA operates on 2 pairs of 8-wide fp64 registers, multiplies the pairwise 
  // elements and accumulates the results into 2 ZA tile slices, for the total of 16 FMAs or 32 FLOPS"
  //
  // we need 19 FMLA instructions to output 38 ZA tile slices"
  double flops_per_iteration = 19*32;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "mov x9, #8                                                  \n"
    "mov x10, #16                                                \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmla za.d[w8, 0, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 1, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 2, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 3, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 4, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 5, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 6, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 7, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 0, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 1, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 2, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 3, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 4, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 5, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 6, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 7, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w10, 0, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w10, 1, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w10, 2, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8", "x9", "x10"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmla_f64_VGx2_36(void) {
  // each FMLA operates on 2 pairs of 8-wide fp64 registers, multiplies the pairwise 
  // elements and accumulates the results into 2 ZA tile slices, for the total of 16 FMAs or 32 FLOPS"
  //
  // we need 18 FMLA instructions to output 36 ZA tile slices"
  double flops_per_iteration = 18*32;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "mov x9, #8                                                  \n"
    "mov x10, #16                                                \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmla za.d[w8, 0, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 1, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 2, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 3, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 4, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 5, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 6, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 7, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 0, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 1, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 2, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 3, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 4, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 5, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 6, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 7, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w10, 0, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "  fmla za.d[w10, 1, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8", "x9", "x10"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmla_f64_VGx2_34(void) {
  // each FMLA operates on 2 pairs of 8-wide fp64 registers, multiplies the pairwise 
  // elements and accumulates the results into 2 ZA tile slices, for the total of 16 FMAs or 32 FLOPS"
  //
  // we need 17 FMLA instructions to output 34 ZA tile slices"
  double flops_per_iteration = 17*32;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "mov x9, #8                                                  \n"
    "mov x10, #16                                                \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmla za.d[w8, 0, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 1, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 2, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 3, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 4, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 5, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 6, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 7, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 0, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 1, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 2, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 3, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 4, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 5, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 6, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 7, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w10, 0, VGx2], {z0.d-z1.d}, {z4.d-z5.d}         \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8", "x9", "x10"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmla_f64_VGx2_32(void) {
  // each FMLA operates on 2 pairs of 8-wide fp64 registers, multiplies the pairwise 
  // elements and accumulates the results into 2 ZA tile slices, for the total of 16 FMAs or 32 FLOPS"
  //
  // we need 16 FMLA instructions to output 32 ZA tile slices"
  double flops_per_iteration = 16*32;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "mov x9, #8                                                  \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmla za.d[w8, 0, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 1, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 2, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 3, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 4, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 5, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 6, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 7, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 0, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 1, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 2, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 3, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 4, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 5, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 6, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 7, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8", "x9"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmla_f64_VGx2_30(void) {
  // each FMLA operates on 2 pairs of 8-wide fp64 registers, multiplies the pairwise 
  // elements and accumulates the results into 2 ZA tile slices, for the total of 16 FMAs or 32 FLOPS"
  //
  // we need 15 FMLA instructions to output 30 ZA tile slices"
  double flops_per_iteration = 15*32;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "mov x9, #8                                                  \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmla za.d[w8, 0, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 1, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 2, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 3, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 4, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 5, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 6, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 7, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 0, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 1, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 2, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 3, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 4, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 5, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 6, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8", "x9"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmla_f64_VGx2_28(void) {
  // each FMLA operates on 2 pairs of 8-wide fp64 registers, multiplies the pairwise 
  // elements and accumulates the results into 2 ZA tile slices, for the total of 16 FMAs or 32 FLOPS"
  //
  // we need 14 FMLA instructions to output 28 ZA tile slices"
  double flops_per_iteration = 14*32;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "mov x9, #8                                                  \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmla za.d[w8, 0, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 1, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 2, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 3, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 4, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 5, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 6, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 7, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 0, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 1, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 2, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 3, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 4, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 5, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8", "x9"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmla_f64_VGx2_26(void) {
  // each FMLA operates on 2 pairs of 8-wide fp64 registers, multiplies the pairwise 
  // elements and accumulates the results into 2 ZA tile slices, for the total of 16 FMAs or 32 FLOPS"
  //
  // we need 13 FMLA instructions to output 26 ZA tile slices"
  double flops_per_iteration = 13*32;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "mov x9, #8                                                  \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmla za.d[w8, 0, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 1, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 2, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 3, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 4, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 5, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 6, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 7, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 0, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 1, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 2, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 3, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 4, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8", "x9"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmla_f64_VGx2_24(void) {
  // each FMLA operates on 2 pairs of 8-wide fp64 registers, multiplies the pairwise 
  // elements and accumulates the results into 2 ZA tile slices, for the total of 16 FMAs or 32 FLOPS"
  //
  // we need 12 FMLA instructions to output 24 ZA tile slices"
  double flops_per_iteration = 12*32;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "mov x9, #8                                                  \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmla za.d[w8, 0, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 1, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 2, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 3, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 4, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 5, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 6, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 7, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 0, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 1, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 2, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 3, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8", "x9"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmla_f64_VGx2_22(void) {
  // each FMLA operates on 2 pairs of 8-wide fp64 registers, multiplies the pairwise 
  // elements and accumulates the results into 2 ZA tile slices, for the total of 16 FMAs or 32 FLOPS"
  //
  // we need 11 FMLA instructions to output 22 ZA tile slices"
  double flops_per_iteration = 11*32;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "mov x9, #8                                                  \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmla za.d[w8, 0, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 1, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 2, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 3, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 4, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 5, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 6, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 7, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 0, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 1, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 2, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8", "x9"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmla_f64_VGx2_20(void) {
  // each FMLA operates on 2 pairs of 8-wide fp64 registers, multiplies the pairwise 
  // elements and accumulates the results into 2 ZA tile slices, for the total of 16 FMAs or 32 FLOPS"
  //
  // we need 10 FMLA instructions to output 20 ZA tile slices"
  double flops_per_iteration = 10*32;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "mov x9, #8                                                  \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmla za.d[w8, 0, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 1, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 2, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 3, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 4, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 5, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 6, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 7, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 0, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 1, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8", "x9"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmla_f64_VGx2_18(void) {
  // each FMLA operates on 2 pairs of 8-wide fp64 registers, multiplies the pairwise 
  // elements and accumulates the results into 2 ZA tile slices, for the total of 16 FMAs or 32 FLOPS"
  //
  // we need 9 FMLA instructions to output 18 ZA tile slices"
  double flops_per_iteration = 9*32;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "mov x9, #8                                                  \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmla za.d[w8, 0, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 1, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 2, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 3, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 4, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 5, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 6, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 7, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w9, 0, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8", "x9"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmla_f64_VGx2_16(void) {
  // each FMLA operates on 2 pairs of 8-wide fp64 registers, multiplies the pairwise 
  // elements and accumulates the results into 2 ZA tile slices, for the total of 16 FMAs or 32 FLOPS"
  //
  // we need 8 FMLA instructions to output 16 ZA tile slices"
  double flops_per_iteration = 8*32;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmla za.d[w8, 0, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 1, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 2, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 3, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 4, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 5, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 6, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 7, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmla_f64_VGx2_14(void) {
  // each FMLA operates on 2 pairs of 8-wide fp64 registers, multiplies the pairwise 
  // elements and accumulates the results into 2 ZA tile slices, for the total of 16 FMAs or 32 FLOPS"
  //
  // we need 7 FMLA instructions to output 14 ZA tile slices"
  double flops_per_iteration = 7*32;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmla za.d[w8, 0, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 1, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 2, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 3, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 4, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 5, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 6, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmla_f64_VGx2_12(void) {
  // each FMLA operates on 2 pairs of 8-wide fp64 registers, multiplies the pairwise 
  // elements and accumulates the results into 2 ZA tile slices, for the total of 16 FMAs or 32 FLOPS"
  //
  // we need 6 FMLA instructions to output 12 ZA tile slices"
  double flops_per_iteration = 6*32;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmla za.d[w8, 0, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 1, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 2, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 3, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 4, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 5, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmla_f64_VGx2_10(void) {
  // each FMLA operates on 2 pairs of 8-wide fp64 registers, multiplies the pairwise 
  // elements and accumulates the results into 2 ZA tile slices, for the total of 16 FMAs or 32 FLOPS"
  //
  // we need 5 FMLA instructions to output 10 ZA tile slices"
  double flops_per_iteration = 5*32;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmla za.d[w8, 0, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 1, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 2, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 3, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 4, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmla_f64_VGx2_8(void) {
  // each FMLA operates on 2 pairs of 8-wide fp64 registers, multiplies the pairwise 
  // elements and accumulates the results into 2 ZA tile slices, for the total of 16 FMAs or 32 FLOPS"
  //
  // we need 4 FMLA instructions to output 8 ZA tile slices"
  double flops_per_iteration = 4*32;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmla za.d[w8, 0, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 1, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 2, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 3, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmla_f64_VGx2_6(void) {
  // each FMLA operates on 2 pairs of 8-wide fp64 registers, multiplies the pairwise 
  // elements and accumulates the results into 2 ZA tile slices, for the total of 16 FMAs or 32 FLOPS"
  //
  // we need 3 FMLA instructions to output 6 ZA tile slices"
  double flops_per_iteration = 3*32;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmla za.d[w8, 0, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 1, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 2, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmla_f64_VGx2_4(void) {
  // each FMLA operates on 2 pairs of 8-wide fp64 registers, multiplies the pairwise 
  // elements and accumulates the results into 2 ZA tile slices, for the total of 16 FMAs or 32 FLOPS"
  //
  // we need 2 FMLA instructions to output 4 ZA tile slices"
  double flops_per_iteration = 2*32;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmla za.d[w8, 0, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "  fmla za.d[w8, 1, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmla_f64_VGx2_2(void) {
  // each FMLA operates on 2 pairs of 8-wide fp64 registers, multiplies the pairwise 
  // elements and accumulates the results into 2 ZA tile slices, for the total of 16 FMAs or 32 FLOPS"
  //
  // we need 1 FMLA instructions to output 2 ZA tile slices"
  double flops_per_iteration = 1*32;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmla za.d[w8, 0, VGx2], {z0.d-z1.d}, {z4.d-z5.d}          \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}


double sme_fmlal_f16f32_VGx4_64(void) {
  // each FMLAL operates on 4 pairs of 32-wide fp16 registers, widens them to fp32, 
  // multiplies the elements pairwise and accumulates the results into 8 ZA tile slices, 
  // for the total of 128 FMAs or 256 FLOPS
  //
  // we need 8 FMLA instructions to output 64 ZA tile slices"
  double flops_per_iteration = 8*256;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "mov x9, #8                                                  \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmlal za.s[w8, 0:1, VGx4], {z0.h-z3.h}, {z4.h-z7.h}       \n"
    "  fmlal za.s[w8, 2:3, VGx4], {z0.h-z3.h}, {z4.h-z7.h}       \n"
    "  fmlal za.s[w8, 4:5, VGx4], {z0.h-z3.h}, {z4.h-z7.h}       \n"
    "  fmlal za.s[w8, 6:7, VGx4], {z0.h-z3.h}, {z4.h-z7.h}       \n"
    "  fmlal za.s[w9, 0:1, VGx4], {z0.h-z3.h}, {z4.h-z7.h}       \n"
    "  fmlal za.s[w9, 2:3, VGx4], {z0.h-z3.h}, {z4.h-z7.h}       \n"
    "  fmlal za.s[w9, 4:5, VGx4], {z0.h-z3.h}, {z4.h-z7.h}       \n"
    "  fmlal za.s[w9, 6:7, VGx4], {z0.h-z3.h}, {z4.h-z7.h}       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8", "x9"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmlal_f16f32_VGx4_56(void) {
  // each FMLAL operates on 4 pairs of 32-wide fp16 registers, widens them to fp32, 
  // multiplies the elements pairwise and accumulates the results into 8 ZA tile slices, 
  // for the total of 128 FMAs or 256 FLOPS
  //
  // we need 7 FMLA instructions to output 56 ZA tile slices"
  double flops_per_iteration = 7*256;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "mov x9, #8                                                  \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmlal za.s[w8, 0:1, VGx4], {z0.h-z3.h}, {z4.h-z7.h}       \n"
    "  fmlal za.s[w8, 2:3, VGx4], {z0.h-z3.h}, {z4.h-z7.h}       \n"
    "  fmlal za.s[w8, 4:5, VGx4], {z0.h-z3.h}, {z4.h-z7.h}       \n"
    "  fmlal za.s[w8, 6:7, VGx4], {z0.h-z3.h}, {z4.h-z7.h}       \n"
    "  fmlal za.s[w9, 0:1, VGx4], {z0.h-z3.h}, {z4.h-z7.h}       \n"
    "  fmlal za.s[w9, 2:3, VGx4], {z0.h-z3.h}, {z4.h-z7.h}       \n"
    "  fmlal za.s[w9, 4:5, VGx4], {z0.h-z3.h}, {z4.h-z7.h}       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8", "x9"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmlal_f16f32_VGx4_48(void) {
  // each FMLAL operates on 4 pairs of 32-wide fp16 registers, widens them to fp32, 
  // multiplies the elements pairwise and accumulates the results into 8 ZA tile slices, 
  // for the total of 128 FMAs or 256 FLOPS
  //
  // we need 6 FMLA instructions to output 48 ZA tile slices"
  double flops_per_iteration = 6*256;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "mov x9, #8                                                  \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmlal za.s[w8, 0:1, VGx4], {z0.h-z3.h}, {z4.h-z7.h}       \n"
    "  fmlal za.s[w8, 2:3, VGx4], {z0.h-z3.h}, {z4.h-z7.h}       \n"
    "  fmlal za.s[w8, 4:5, VGx4], {z0.h-z3.h}, {z4.h-z7.h}       \n"
    "  fmlal za.s[w8, 6:7, VGx4], {z0.h-z3.h}, {z4.h-z7.h}       \n"
    "  fmlal za.s[w9, 0:1, VGx4], {z0.h-z3.h}, {z4.h-z7.h}       \n"
    "  fmlal za.s[w9, 2:3, VGx4], {z0.h-z3.h}, {z4.h-z7.h}       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8", "x9"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmlal_f16f32_VGx4_40(void) {
  // each FMLAL operates on 4 pairs of 32-wide fp16 registers, widens them to fp32, 
  // multiplies the elements pairwise and accumulates the results into 8 ZA tile slices, 
  // for the total of 128 FMAs or 256 FLOPS
  //
  // we need 5 FMLA instructions to output 40 ZA tile slices"
  double flops_per_iteration = 5*256;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "mov x9, #8                                                  \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmlal za.s[w8, 0:1, VGx4], {z0.h-z3.h}, {z4.h-z7.h}       \n"
    "  fmlal za.s[w8, 2:3, VGx4], {z0.h-z3.h}, {z4.h-z7.h}       \n"
    "  fmlal za.s[w8, 4:5, VGx4], {z0.h-z3.h}, {z4.h-z7.h}       \n"
    "  fmlal za.s[w8, 6:7, VGx4], {z0.h-z3.h}, {z4.h-z7.h}       \n"
    "  fmlal za.s[w9, 0:1, VGx4], {z0.h-z3.h}, {z4.h-z7.h}       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8", "x9"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmlal_f16f32_VGx4_32(void) {
  // each FMLAL operates on 4 pairs of 32-wide fp16 registers, widens them to fp32, 
  // multiplies the elements pairwise and accumulates the results into 8 ZA tile slices, 
  // for the total of 128 FMAs or 256 FLOPS
  //
  // we need 4 FMLA instructions to output 32 ZA tile slices"
  double flops_per_iteration = 4*256;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmlal za.s[w8, 0:1, VGx4], {z0.h-z3.h}, {z4.h-z7.h}       \n"
    "  fmlal za.s[w8, 2:3, VGx4], {z0.h-z3.h}, {z4.h-z7.h}       \n"
    "  fmlal za.s[w8, 4:5, VGx4], {z0.h-z3.h}, {z4.h-z7.h}       \n"
    "  fmlal za.s[w8, 6:7, VGx4], {z0.h-z3.h}, {z4.h-z7.h}       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmlal_f16f32_VGx4_24(void) {
  // each FMLAL operates on 4 pairs of 32-wide fp16 registers, widens them to fp32, 
  // multiplies the elements pairwise and accumulates the results into 8 ZA tile slices, 
  // for the total of 128 FMAs or 256 FLOPS
  //
  // we need 3 FMLA instructions to output 24 ZA tile slices"
  double flops_per_iteration = 3*256;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmlal za.s[w8, 0:1, VGx4], {z0.h-z3.h}, {z4.h-z7.h}       \n"
    "  fmlal za.s[w8, 2:3, VGx4], {z0.h-z3.h}, {z4.h-z7.h}       \n"
    "  fmlal za.s[w8, 4:5, VGx4], {z0.h-z3.h}, {z4.h-z7.h}       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmlal_f16f32_VGx4_16(void) {
  // each FMLAL operates on 4 pairs of 32-wide fp16 registers, widens them to fp32, 
  // multiplies the elements pairwise and accumulates the results into 8 ZA tile slices, 
  // for the total of 128 FMAs or 256 FLOPS
  //
  // we need 2 FMLA instructions to output 16 ZA tile slices"
  double flops_per_iteration = 2*256;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmlal za.s[w8, 0:1, VGx4], {z0.h-z3.h}, {z4.h-z7.h}       \n"
    "  fmlal za.s[w8, 2:3, VGx4], {z0.h-z3.h}, {z4.h-z7.h}       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmlal_f16f32_VGx4_8(void) {
  // each FMLAL operates on 4 pairs of 32-wide fp16 registers, widens them to fp32, 
  // multiplies the elements pairwise and accumulates the results into 8 ZA tile slices, 
  // for the total of 128 FMAs or 256 FLOPS
  //
  // we need 1 FMLA instructions to output 8 ZA tile slices"
  double flops_per_iteration = 1*256;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmlal za.s[w8, 0:1, VGx4], {z0.h-z3.h}, {z4.h-z7.h}       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}


double sme_fmlal_f16f32_VGx2_64(void) {
  // each FMLAL operates on 2 pairs of 32-wide fp16 registers, widens them to fp32, 
  // multiplies the elements pairwise and accumulates the results into 4 ZA tile slices, 
  // for the total of 64 FMAs or 128 FLOPS
  //
  // we need 16 FMLA instructions to output 64 ZA tile slices"
  double flops_per_iteration = 16*128;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "mov x9, #8                                                  \n"
    "mov x10, #16                                                \n"
    "mov x11, #24                                                \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmlal za.s[w8, 0:1, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w8, 2:3, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w8, 4:5, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w8, 6:7, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w9, 0:1, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w9, 2:3, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w9, 4:5, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w9, 6:7, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w10, 0:1, VGx2], {z0.h-z1.h}, {z4.h-z5.h}      \n"
    "  fmlal za.s[w10, 2:3, VGx2], {z0.h-z1.h}, {z4.h-z5.h}      \n"
    "  fmlal za.s[w10, 4:5, VGx2], {z0.h-z1.h}, {z4.h-z5.h}      \n"
    "  fmlal za.s[w10, 6:7, VGx2], {z0.h-z1.h}, {z4.h-z5.h}      \n"
    "  fmlal za.s[w11, 0:1, VGx2], {z0.h-z1.h}, {z4.h-z5.h}      \n"
    "  fmlal za.s[w11, 2:3, VGx2], {z0.h-z1.h}, {z4.h-z5.h}      \n"
    "  fmlal za.s[w11, 4:5, VGx2], {z0.h-z1.h}, {z4.h-z5.h}      \n"
    "  fmlal za.s[w11, 6:7, VGx2], {z0.h-z1.h}, {z4.h-z5.h}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8", "x9", "x10", "x11"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmlal_f16f32_VGx2_60(void) {
  // each FMLAL operates on 2 pairs of 32-wide fp16 registers, widens them to fp32, 
  // multiplies the elements pairwise and accumulates the results into 4 ZA tile slices, 
  // for the total of 64 FMAs or 128 FLOPS
  //
  // we need 15 FMLA instructions to output 60 ZA tile slices"
  double flops_per_iteration = 15*128;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "mov x9, #8                                                  \n"
    "mov x10, #16                                                \n"
    "mov x11, #24                                                \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmlal za.s[w8, 0:1, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w8, 2:3, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w8, 4:5, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w8, 6:7, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w9, 0:1, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w9, 2:3, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w9, 4:5, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w9, 6:7, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w10, 0:1, VGx2], {z0.h-z1.h}, {z4.h-z5.h}      \n"
    "  fmlal za.s[w10, 2:3, VGx2], {z0.h-z1.h}, {z4.h-z5.h}      \n"
    "  fmlal za.s[w10, 4:5, VGx2], {z0.h-z1.h}, {z4.h-z5.h}      \n"
    "  fmlal za.s[w10, 6:7, VGx2], {z0.h-z1.h}, {z4.h-z5.h}      \n"
    "  fmlal za.s[w11, 0:1, VGx2], {z0.h-z1.h}, {z4.h-z5.h}      \n"
    "  fmlal za.s[w11, 2:3, VGx2], {z0.h-z1.h}, {z4.h-z5.h}      \n"
    "  fmlal za.s[w11, 4:5, VGx2], {z0.h-z1.h}, {z4.h-z5.h}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8", "x9", "x10", "x11"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmlal_f16f32_VGx2_56(void) {
  // each FMLAL operates on 2 pairs of 32-wide fp16 registers, widens them to fp32, 
  // multiplies the elements pairwise and accumulates the results into 4 ZA tile slices, 
  // for the total of 64 FMAs or 128 FLOPS
  //
  // we need 14 FMLA instructions to output 56 ZA tile slices"
  double flops_per_iteration = 14*128;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "mov x9, #8                                                  \n"
    "mov x10, #16                                                \n"
    "mov x11, #24                                                \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmlal za.s[w8, 0:1, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w8, 2:3, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w8, 4:5, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w8, 6:7, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w9, 0:1, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w9, 2:3, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w9, 4:5, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w9, 6:7, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w10, 0:1, VGx2], {z0.h-z1.h}, {z4.h-z5.h}      \n"
    "  fmlal za.s[w10, 2:3, VGx2], {z0.h-z1.h}, {z4.h-z5.h}      \n"
    "  fmlal za.s[w10, 4:5, VGx2], {z0.h-z1.h}, {z4.h-z5.h}      \n"
    "  fmlal za.s[w10, 6:7, VGx2], {z0.h-z1.h}, {z4.h-z5.h}      \n"
    "  fmlal za.s[w11, 0:1, VGx2], {z0.h-z1.h}, {z4.h-z5.h}      \n"
    "  fmlal za.s[w11, 2:3, VGx2], {z0.h-z1.h}, {z4.h-z5.h}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8", "x9", "x10", "x11"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmlal_f16f32_VGx2_52(void) {
  // each FMLAL operates on 2 pairs of 32-wide fp16 registers, widens them to fp32, 
  // multiplies the elements pairwise and accumulates the results into 4 ZA tile slices, 
  // for the total of 64 FMAs or 128 FLOPS
  //
  // we need 13 FMLA instructions to output 52 ZA tile slices"
  double flops_per_iteration = 13*128;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "mov x9, #8                                                  \n"
    "mov x10, #16                                                \n"
    "mov x11, #24                                                \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmlal za.s[w8, 0:1, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w8, 2:3, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w8, 4:5, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w8, 6:7, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w9, 0:1, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w9, 2:3, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w9, 4:5, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w9, 6:7, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w10, 0:1, VGx2], {z0.h-z1.h}, {z4.h-z5.h}      \n"
    "  fmlal za.s[w10, 2:3, VGx2], {z0.h-z1.h}, {z4.h-z5.h}      \n"
    "  fmlal za.s[w10, 4:5, VGx2], {z0.h-z1.h}, {z4.h-z5.h}      \n"
    "  fmlal za.s[w10, 6:7, VGx2], {z0.h-z1.h}, {z4.h-z5.h}      \n"
    "  fmlal za.s[w11, 0:1, VGx2], {z0.h-z1.h}, {z4.h-z5.h}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8", "x9", "x10", "x11"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmlal_f16f32_VGx2_48(void) {
  // each FMLAL operates on 2 pairs of 32-wide fp16 registers, widens them to fp32, 
  // multiplies the elements pairwise and accumulates the results into 4 ZA tile slices, 
  // for the total of 64 FMAs or 128 FLOPS
  //
  // we need 12 FMLA instructions to output 48 ZA tile slices"
  double flops_per_iteration = 12*128;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "mov x9, #8                                                  \n"
    "mov x10, #16                                                \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmlal za.s[w8, 0:1, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w8, 2:3, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w8, 4:5, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w8, 6:7, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w9, 0:1, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w9, 2:3, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w9, 4:5, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w9, 6:7, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w10, 0:1, VGx2], {z0.h-z1.h}, {z4.h-z5.h}      \n"
    "  fmlal za.s[w10, 2:3, VGx2], {z0.h-z1.h}, {z4.h-z5.h}      \n"
    "  fmlal za.s[w10, 4:5, VGx2], {z0.h-z1.h}, {z4.h-z5.h}      \n"
    "  fmlal za.s[w10, 6:7, VGx2], {z0.h-z1.h}, {z4.h-z5.h}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8", "x9", "x10"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmlal_f16f32_VGx2_44(void) {
  // each FMLAL operates on 2 pairs of 32-wide fp16 registers, widens them to fp32, 
  // multiplies the elements pairwise and accumulates the results into 4 ZA tile slices, 
  // for the total of 64 FMAs or 128 FLOPS
  //
  // we need 11 FMLA instructions to output 44 ZA tile slices"
  double flops_per_iteration = 11*128;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "mov x9, #8                                                  \n"
    "mov x10, #16                                                \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmlal za.s[w8, 0:1, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w8, 2:3, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w8, 4:5, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w8, 6:7, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w9, 0:1, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w9, 2:3, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w9, 4:5, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w9, 6:7, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w10, 0:1, VGx2], {z0.h-z1.h}, {z4.h-z5.h}      \n"
    "  fmlal za.s[w10, 2:3, VGx2], {z0.h-z1.h}, {z4.h-z5.h}      \n"
    "  fmlal za.s[w10, 4:5, VGx2], {z0.h-z1.h}, {z4.h-z5.h}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8", "x9", "x10"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmlal_f16f32_VGx2_40(void) {
  // each FMLAL operates on 2 pairs of 32-wide fp16 registers, widens them to fp32, 
  // multiplies the elements pairwise and accumulates the results into 4 ZA tile slices, 
  // for the total of 64 FMAs or 128 FLOPS
  //
  // we need 10 FMLA instructions to output 40 ZA tile slices"
  double flops_per_iteration = 10*128;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "mov x9, #8                                                  \n"
    "mov x10, #16                                                \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmlal za.s[w8, 0:1, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w8, 2:3, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w8, 4:5, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w8, 6:7, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w9, 0:1, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w9, 2:3, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w9, 4:5, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w9, 6:7, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w10, 0:1, VGx2], {z0.h-z1.h}, {z4.h-z5.h}      \n"
    "  fmlal za.s[w10, 2:3, VGx2], {z0.h-z1.h}, {z4.h-z5.h}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8", "x9", "x10"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmlal_f16f32_VGx2_36(void) {
  // each FMLAL operates on 2 pairs of 32-wide fp16 registers, widens them to fp32, 
  // multiplies the elements pairwise and accumulates the results into 4 ZA tile slices, 
  // for the total of 64 FMAs or 128 FLOPS
  //
  // we need 9 FMLA instructions to output 36 ZA tile slices"
  double flops_per_iteration = 9*128;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "mov x9, #8                                                  \n"
    "mov x10, #16                                                \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmlal za.s[w8, 0:1, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w8, 2:3, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w8, 4:5, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w8, 6:7, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w9, 0:1, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w9, 2:3, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w9, 4:5, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w9, 6:7, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w10, 0:1, VGx2], {z0.h-z1.h}, {z4.h-z5.h}      \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8", "x9", "x10"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmlal_f16f32_VGx2_32(void) {
  // each FMLAL operates on 2 pairs of 32-wide fp16 registers, widens them to fp32, 
  // multiplies the elements pairwise and accumulates the results into 4 ZA tile slices, 
  // for the total of 64 FMAs or 128 FLOPS
  //
  // we need 8 FMLA instructions to output 32 ZA tile slices"
  double flops_per_iteration = 8*128;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "mov x9, #8                                                  \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmlal za.s[w8, 0:1, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w8, 2:3, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w8, 4:5, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w8, 6:7, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w9, 0:1, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w9, 2:3, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w9, 4:5, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w9, 6:7, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8", "x9"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmlal_f16f32_VGx2_28(void) {
  // each FMLAL operates on 2 pairs of 32-wide fp16 registers, widens them to fp32, 
  // multiplies the elements pairwise and accumulates the results into 4 ZA tile slices, 
  // for the total of 64 FMAs or 128 FLOPS
  //
  // we need 7 FMLA instructions to output 28 ZA tile slices"
  double flops_per_iteration = 7*128;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "mov x9, #8                                                  \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmlal za.s[w8, 0:1, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w8, 2:3, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w8, 4:5, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w8, 6:7, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w9, 0:1, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w9, 2:3, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w9, 4:5, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8", "x9"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmlal_f16f32_VGx2_24(void) {
  // each FMLAL operates on 2 pairs of 32-wide fp16 registers, widens them to fp32, 
  // multiplies the elements pairwise and accumulates the results into 4 ZA tile slices, 
  // for the total of 64 FMAs or 128 FLOPS
  //
  // we need 6 FMLA instructions to output 24 ZA tile slices"
  double flops_per_iteration = 6*128;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "mov x9, #8                                                  \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmlal za.s[w8, 0:1, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w8, 2:3, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w8, 4:5, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w8, 6:7, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w9, 0:1, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w9, 2:3, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8", "x9"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmlal_f16f32_VGx2_20(void) {
  // each FMLAL operates on 2 pairs of 32-wide fp16 registers, widens them to fp32, 
  // multiplies the elements pairwise and accumulates the results into 4 ZA tile slices, 
  // for the total of 64 FMAs or 128 FLOPS
  //
  // we need 5 FMLA instructions to output 20 ZA tile slices"
  double flops_per_iteration = 5*128;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "mov x9, #8                                                  \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmlal za.s[w8, 0:1, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w8, 2:3, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w8, 4:5, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w8, 6:7, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w9, 0:1, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8", "x9"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmlal_f16f32_VGx2_16(void) {
  // each FMLAL operates on 2 pairs of 32-wide fp16 registers, widens them to fp32, 
  // multiplies the elements pairwise and accumulates the results into 4 ZA tile slices, 
  // for the total of 64 FMAs or 128 FLOPS
  //
  // we need 4 FMLA instructions to output 16 ZA tile slices"
  double flops_per_iteration = 4*128;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmlal za.s[w8, 0:1, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w8, 2:3, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w8, 4:5, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w8, 6:7, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmlal_f16f32_VGx2_12(void) {
  // each FMLAL operates on 2 pairs of 32-wide fp16 registers, widens them to fp32, 
  // multiplies the elements pairwise and accumulates the results into 4 ZA tile slices, 
  // for the total of 64 FMAs or 128 FLOPS
  //
  // we need 3 FMLA instructions to output 12 ZA tile slices"
  double flops_per_iteration = 3*128;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmlal za.s[w8, 0:1, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w8, 2:3, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w8, 4:5, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmlal_f16f32_VGx2_8(void) {
  // each FMLAL operates on 2 pairs of 32-wide fp16 registers, widens them to fp32, 
  // multiplies the elements pairwise and accumulates the results into 4 ZA tile slices, 
  // for the total of 64 FMAs or 128 FLOPS
  //
  // we need 2 FMLA instructions to output 8 ZA tile slices"
  double flops_per_iteration = 2*128;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmlal za.s[w8, 0:1, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "  fmlal za.s[w8, 2:3, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmlal_f16f32_VGx2_4(void) {
  // each FMLAL operates on 2 pairs of 32-wide fp16 registers, widens them to fp32, 
  // multiplies the elements pairwise and accumulates the results into 4 ZA tile slices, 
  // for the total of 64 FMAs or 128 FLOPS
  //
  // we need 1 FMLA instructions to output 4 ZA tile slices"
  double flops_per_iteration = 1*128;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "mov x8, #0                                                  \n"
    "smstart                                                     \n"
    "1:                                                          \n"
    "  fmlal za.s[w8, 0:1, VGx2], {z0.h-z1.h}, {z4.h-z5.h}       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0", "x8"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}


// Estimate peak outer product to ZA rates

double sme_fmopa_f32_4(void) {
  // each FMOPA calculates the outer product of two 16-wide fp32 registers and accumulates
  // the results into a 16x16 ZA tile, for the total of 256.0 FMAs or 512.0 FLOPS"
  //
  // we need 4 FMOPA instructions to output 4 ZA tiles"
  double flops_per_iteration = 4*512.0;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "smstart                                                     \n"
    "ptrue p0.s                                                  \n"
    "1:                                                          \n"
    "  fmopa za0.s, p0/m, p0/m, z0.s, z1.s                       \n"
    "  fmopa za1.s, p0/m, p0/m, z2.s, z3.s                       \n"
    "  fmopa za2.s, p0/m, p0/m, z4.s, z5.s                       \n"
    "  fmopa za3.s, p0/m, p0/m, z6.s, z7.s                       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmopa_f32_3(void) {
  // each FMOPA calculates the outer product of two 16-wide fp32 registers and accumulates
  // the results into a 16x16 ZA tile, for the total of 256.0 FMAs or 512.0 FLOPS"
  //
  // we need 3 FMOPA instructions to output 3 ZA tiles"
  double flops_per_iteration = 3*512.0;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "smstart                                                     \n"
    "ptrue p0.s                                                  \n"
    "1:                                                          \n"
    "  fmopa za0.s, p0/m, p0/m, z0.s, z1.s                       \n"
    "  fmopa za1.s, p0/m, p0/m, z2.s, z3.s                       \n"
    "  fmopa za2.s, p0/m, p0/m, z4.s, z5.s                       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmopa_f32_2(void) {
  // each FMOPA calculates the outer product of two 16-wide fp32 registers and accumulates
  // the results into a 16x16 ZA tile, for the total of 256.0 FMAs or 512.0 FLOPS"
  //
  // we need 2 FMOPA instructions to output 2 ZA tiles"
  double flops_per_iteration = 2*512.0;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "smstart                                                     \n"
    "ptrue p0.s                                                  \n"
    "1:                                                          \n"
    "  fmopa za0.s, p0/m, p0/m, z0.s, z1.s                       \n"
    "  fmopa za1.s, p0/m, p0/m, z2.s, z3.s                       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmopa_f32_1(void) {
  // each FMOPA calculates the outer product of two 16-wide fp32 registers and accumulates
  // the results into a 16x16 ZA tile, for the total of 256.0 FMAs or 512.0 FLOPS"
  //
  // we need 1 FMOPA instructions to output 1 ZA tiles"
  double flops_per_iteration = 1*512.0;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "smstart                                                     \n"
    "ptrue p0.s                                                  \n"
    "1:                                                          \n"
    "  fmopa za0.s, p0/m, p0/m, z0.s, z1.s                       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}


double sme_fmopa_f64_8(void) {
  // each FMOPA calculates the outer product of two 8-wide fp64 registers and accumulates
  // the results into a 8x8 ZA tile, for the total of 64.0 FMAs or 128.0 FLOPS"
  //
  // we need 8 FMOPA instructions to output 8 ZA tiles"
  double flops_per_iteration = 8*128.0;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "smstart                                                     \n"
    "ptrue p0.d                                                  \n"
    "1:                                                          \n"
    "  fmopa za0.d, p0/m, p0/m, z0.d, z1.d                       \n"
    "  fmopa za1.d, p0/m, p0/m, z2.d, z3.d                       \n"
    "  fmopa za2.d, p0/m, p0/m, z4.d, z5.d                       \n"
    "  fmopa za3.d, p0/m, p0/m, z6.d, z7.d                       \n"
    "  fmopa za4.d, p0/m, p0/m, z8.d, z9.d                       \n"
    "  fmopa za5.d, p0/m, p0/m, z10.d, z11.d                     \n"
    "  fmopa za6.d, p0/m, p0/m, z12.d, z13.d                     \n"
    "  fmopa za7.d, p0/m, p0/m, z14.d, z15.d                     \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmopa_f64_7(void) {
  // each FMOPA calculates the outer product of two 8-wide fp64 registers and accumulates
  // the results into a 8x8 ZA tile, for the total of 64.0 FMAs or 128.0 FLOPS"
  //
  // we need 7 FMOPA instructions to output 7 ZA tiles"
  double flops_per_iteration = 7*128.0;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "smstart                                                     \n"
    "ptrue p0.d                                                  \n"
    "1:                                                          \n"
    "  fmopa za0.d, p0/m, p0/m, z0.d, z1.d                       \n"
    "  fmopa za1.d, p0/m, p0/m, z2.d, z3.d                       \n"
    "  fmopa za2.d, p0/m, p0/m, z4.d, z5.d                       \n"
    "  fmopa za3.d, p0/m, p0/m, z6.d, z7.d                       \n"
    "  fmopa za4.d, p0/m, p0/m, z8.d, z9.d                       \n"
    "  fmopa za5.d, p0/m, p0/m, z10.d, z11.d                     \n"
    "  fmopa za6.d, p0/m, p0/m, z12.d, z13.d                     \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmopa_f64_6(void) {
  // each FMOPA calculates the outer product of two 8-wide fp64 registers and accumulates
  // the results into a 8x8 ZA tile, for the total of 64.0 FMAs or 128.0 FLOPS"
  //
  // we need 6 FMOPA instructions to output 6 ZA tiles"
  double flops_per_iteration = 6*128.0;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "smstart                                                     \n"
    "ptrue p0.d                                                  \n"
    "1:                                                          \n"
    "  fmopa za0.d, p0/m, p0/m, z0.d, z1.d                       \n"
    "  fmopa za1.d, p0/m, p0/m, z2.d, z3.d                       \n"
    "  fmopa za2.d, p0/m, p0/m, z4.d, z5.d                       \n"
    "  fmopa za3.d, p0/m, p0/m, z6.d, z7.d                       \n"
    "  fmopa za4.d, p0/m, p0/m, z8.d, z9.d                       \n"
    "  fmopa za5.d, p0/m, p0/m, z10.d, z11.d                     \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmopa_f64_5(void) {
  // each FMOPA calculates the outer product of two 8-wide fp64 registers and accumulates
  // the results into a 8x8 ZA tile, for the total of 64.0 FMAs or 128.0 FLOPS"
  //
  // we need 5 FMOPA instructions to output 5 ZA tiles"
  double flops_per_iteration = 5*128.0;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "smstart                                                     \n"
    "ptrue p0.d                                                  \n"
    "1:                                                          \n"
    "  fmopa za0.d, p0/m, p0/m, z0.d, z1.d                       \n"
    "  fmopa za1.d, p0/m, p0/m, z2.d, z3.d                       \n"
    "  fmopa za2.d, p0/m, p0/m, z4.d, z5.d                       \n"
    "  fmopa za3.d, p0/m, p0/m, z6.d, z7.d                       \n"
    "  fmopa za4.d, p0/m, p0/m, z8.d, z9.d                       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmopa_f64_4(void) {
  // each FMOPA calculates the outer product of two 8-wide fp64 registers and accumulates
  // the results into a 8x8 ZA tile, for the total of 64.0 FMAs or 128.0 FLOPS"
  //
  // we need 4 FMOPA instructions to output 4 ZA tiles"
  double flops_per_iteration = 4*128.0;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "smstart                                                     \n"
    "ptrue p0.d                                                  \n"
    "1:                                                          \n"
    "  fmopa za0.d, p0/m, p0/m, z0.d, z1.d                       \n"
    "  fmopa za1.d, p0/m, p0/m, z2.d, z3.d                       \n"
    "  fmopa za2.d, p0/m, p0/m, z4.d, z5.d                       \n"
    "  fmopa za3.d, p0/m, p0/m, z6.d, z7.d                       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmopa_f64_3(void) {
  // each FMOPA calculates the outer product of two 8-wide fp64 registers and accumulates
  // the results into a 8x8 ZA tile, for the total of 64.0 FMAs or 128.0 FLOPS"
  //
  // we need 3 FMOPA instructions to output 3 ZA tiles"
  double flops_per_iteration = 3*128.0;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "smstart                                                     \n"
    "ptrue p0.d                                                  \n"
    "1:                                                          \n"
    "  fmopa za0.d, p0/m, p0/m, z0.d, z1.d                       \n"
    "  fmopa za1.d, p0/m, p0/m, z2.d, z3.d                       \n"
    "  fmopa za2.d, p0/m, p0/m, z4.d, z5.d                       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmopa_f64_2(void) {
  // each FMOPA calculates the outer product of two 8-wide fp64 registers and accumulates
  // the results into a 8x8 ZA tile, for the total of 64.0 FMAs or 128.0 FLOPS"
  //
  // we need 2 FMOPA instructions to output 2 ZA tiles"
  double flops_per_iteration = 2*128.0;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "smstart                                                     \n"
    "ptrue p0.d                                                  \n"
    "1:                                                          \n"
    "  fmopa za0.d, p0/m, p0/m, z0.d, z1.d                       \n"
    "  fmopa za1.d, p0/m, p0/m, z2.d, z3.d                       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmopa_f64_1(void) {
  // each FMOPA calculates the outer product of two 8-wide fp64 registers and accumulates
  // the results into a 8x8 ZA tile, for the total of 64.0 FMAs or 128.0 FLOPS"
  //
  // we need 1 FMOPA instructions to output 1 ZA tiles"
  double flops_per_iteration = 1*128.0;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "smstart                                                     \n"
    "ptrue p0.d                                                  \n"
    "1:                                                          \n"
    "  fmopa za0.d, p0/m, p0/m, z0.d, z1.d                       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}


double sme_fmopa_f16f32_4(void) {
  // each FMOPA calculates the matrix product of 16x2 matrices contained in two 
  // 32-wide fp16 registers and accumulates the widened result into the 32x32 ZA tile,
  // for the total of 1024.0 FMAs or 2048.0 FLOPS"
  //
  // widening FMOPA is equivalent to performing dot product and accumulate
  //
  // we need 4 FMOPA instructions to output 4 ZA tiles"
  double flops_per_iteration = 4*2048.0;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "smstart                                                     \n"
    "ptrue p0.h                                                  \n"
    "1:                                                          \n"
    "  fmopa za0.s, p0/m, p0/m, z0.h, z1.h                       \n"
    "  fmopa za1.s, p0/m, p0/m, z2.h, z3.h                       \n"
    "  fmopa za2.s, p0/m, p0/m, z4.h, z5.h                       \n"
    "  fmopa za3.s, p0/m, p0/m, z6.h, z7.h                       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmopa_f16f32_3(void) {
  // each FMOPA calculates the matrix product of 16x2 matrices contained in two 
  // 32-wide fp16 registers and accumulates the widened result into the 32x32 ZA tile,
  // for the total of 1024.0 FMAs or 2048.0 FLOPS"
  //
  // widening FMOPA is equivalent to performing dot product and accumulate
  //
  // we need 3 FMOPA instructions to output 3 ZA tiles"
  double flops_per_iteration = 3*2048.0;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "smstart                                                     \n"
    "ptrue p0.h                                                  \n"
    "1:                                                          \n"
    "  fmopa za0.s, p0/m, p0/m, z0.h, z1.h                       \n"
    "  fmopa za1.s, p0/m, p0/m, z2.h, z3.h                       \n"
    "  fmopa za2.s, p0/m, p0/m, z4.h, z5.h                       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmopa_f16f32_2(void) {
  // each FMOPA calculates the matrix product of 16x2 matrices contained in two 
  // 32-wide fp16 registers and accumulates the widened result into the 32x32 ZA tile,
  // for the total of 1024.0 FMAs or 2048.0 FLOPS"
  //
  // widening FMOPA is equivalent to performing dot product and accumulate
  //
  // we need 2 FMOPA instructions to output 2 ZA tiles"
  double flops_per_iteration = 2*2048.0;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "smstart                                                     \n"
    "ptrue p0.h                                                  \n"
    "1:                                                          \n"
    "  fmopa za0.s, p0/m, p0/m, z0.h, z1.h                       \n"
    "  fmopa za1.s, p0/m, p0/m, z2.h, z3.h                       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_fmopa_f16f32_1(void) {
  // each FMOPA calculates the matrix product of 16x2 matrices contained in two 
  // 32-wide fp16 registers and accumulates the widened result into the 32x32 ZA tile,
  // for the total of 1024.0 FMAs or 2048.0 FLOPS"
  //
  // widening FMOPA is equivalent to performing dot product and accumulate
  //
  // we need 1 FMOPA instructions to output 1 ZA tiles"
  double flops_per_iteration = 1*2048.0;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "smstart                                                     \n"
    "ptrue p0.h                                                  \n"
    "1:                                                          \n"
    "  fmopa za0.s, p0/m, p0/m, z0.h, z1.h                       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}


double sme_smopa_i16i32_4(void) {
  // each SMOPA calculates the matrix product of 16x2 matrices contained in two 
  // 32-wide i16 registers and accumulates the widened result into the 32x32 ZA tile,
  // for the total of 1024.0 FMAs or 2048.0 FLOPS (technically integer ops)"
  //
  // widening SMOPA is equivalent to performing dot product and accumulate
  //
  // we need 4 SMOPA instructions to output 4 ZA tiles"
  double flops_per_iteration = 4*2048.0;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "smstart                                                     \n"
    "ptrue p0.h                                                  \n"
    "1:                                                          \n"
    "  smopa za0.s, p0/m, p0/m, z0.h, z1.h                       \n"
    "  smopa za1.s, p0/m, p0/m, z2.h, z3.h                       \n"
    "  smopa za2.s, p0/m, p0/m, z4.h, z5.h                       \n"
    "  smopa za3.s, p0/m, p0/m, z6.h, z7.h                       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_smopa_i16i32_3(void) {
  // each SMOPA calculates the matrix product of 16x2 matrices contained in two 
  // 32-wide i16 registers and accumulates the widened result into the 32x32 ZA tile,
  // for the total of 1024.0 FMAs or 2048.0 FLOPS (technically integer ops)"
  //
  // widening SMOPA is equivalent to performing dot product and accumulate
  //
  // we need 3 SMOPA instructions to output 3 ZA tiles"
  double flops_per_iteration = 3*2048.0;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "smstart                                                     \n"
    "ptrue p0.h                                                  \n"
    "1:                                                          \n"
    "  smopa za0.s, p0/m, p0/m, z0.h, z1.h                       \n"
    "  smopa za1.s, p0/m, p0/m, z2.h, z3.h                       \n"
    "  smopa za2.s, p0/m, p0/m, z4.h, z5.h                       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_smopa_i16i32_2(void) {
  // each SMOPA calculates the matrix product of 16x2 matrices contained in two 
  // 32-wide i16 registers and accumulates the widened result into the 32x32 ZA tile,
  // for the total of 1024.0 FMAs or 2048.0 FLOPS (technically integer ops)"
  //
  // widening SMOPA is equivalent to performing dot product and accumulate
  //
  // we need 2 SMOPA instructions to output 2 ZA tiles"
  double flops_per_iteration = 2*2048.0;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "smstart                                                     \n"
    "ptrue p0.h                                                  \n"
    "1:                                                          \n"
    "  smopa za0.s, p0/m, p0/m, z0.h, z1.h                       \n"
    "  smopa za1.s, p0/m, p0/m, z2.h, z3.h                       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_smopa_i16i32_1(void) {
  // each SMOPA calculates the matrix product of 16x2 matrices contained in two 
  // 32-wide i16 registers and accumulates the widened result into the 32x32 ZA tile,
  // for the total of 1024.0 FMAs or 2048.0 FLOPS (technically integer ops)"
  //
  // widening SMOPA is equivalent to performing dot product and accumulate
  //
  // we need 1 SMOPA instructions to output 1 ZA tiles"
  double flops_per_iteration = 1*2048.0;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "smstart                                                     \n"
    "ptrue p0.h                                                  \n"
    "1:                                                          \n"
    "  smopa za0.s, p0/m, p0/m, z0.h, z1.h                       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}


double sme_smopa_i8i32_4(void) {
  // each SMOPA calculates the matrix product of 16x2 matrices contained in two 
  // 64-wide i8 registers and accumulates the widened result into the 64x64 ZA tile,
  // for the total of 4096.0 FMAs or 8192.0 FLOPS (technically integer ops)"
  //
  // widening SMOPA is equivalent to performing dot product and accumulate
  //
  // we need 4 SMOPA instructions to output 4 ZA tiles"
  double flops_per_iteration = 4*8192.0;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "smstart                                                     \n"
    "ptrue p0.b                                                  \n"
    "1:                                                          \n"
    "  smopa za0.s, p0/m, p0/m, z0.b, z1.b                       \n"
    "  smopa za1.s, p0/m, p0/m, z2.b, z3.b                       \n"
    "  smopa za2.s, p0/m, p0/m, z4.b, z5.b                       \n"
    "  smopa za3.s, p0/m, p0/m, z6.b, z7.b                       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_smopa_i8i32_3(void) {
  // each SMOPA calculates the matrix product of 16x2 matrices contained in two 
  // 64-wide i8 registers and accumulates the widened result into the 64x64 ZA tile,
  // for the total of 4096.0 FMAs or 8192.0 FLOPS (technically integer ops)"
  //
  // widening SMOPA is equivalent to performing dot product and accumulate
  //
  // we need 3 SMOPA instructions to output 3 ZA tiles"
  double flops_per_iteration = 3*8192.0;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "smstart                                                     \n"
    "ptrue p0.b                                                  \n"
    "1:                                                          \n"
    "  smopa za0.s, p0/m, p0/m, z0.b, z1.b                       \n"
    "  smopa za1.s, p0/m, p0/m, z2.b, z3.b                       \n"
    "  smopa za2.s, p0/m, p0/m, z4.b, z5.b                       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_smopa_i8i32_2(void) {
  // each SMOPA calculates the matrix product of 16x2 matrices contained in two 
  // 64-wide i8 registers and accumulates the widened result into the 64x64 ZA tile,
  // for the total of 4096.0 FMAs or 8192.0 FLOPS (technically integer ops)"
  //
  // widening SMOPA is equivalent to performing dot product and accumulate
  //
  // we need 2 SMOPA instructions to output 2 ZA tiles"
  double flops_per_iteration = 2*8192.0;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "smstart                                                     \n"
    "ptrue p0.b                                                  \n"
    "1:                                                          \n"
    "  smopa za0.s, p0/m, p0/m, z0.b, z1.b                       \n"
    "  smopa za1.s, p0/m, p0/m, z2.b, z3.b                       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}

double sme_smopa_i8i32_1(void) {
  // each SMOPA calculates the matrix product of 16x2 matrices contained in two 
  // 64-wide i8 registers and accumulates the widened result into the 64x64 ZA tile,
  // for the total of 4096.0 FMAs or 8192.0 FLOPS (technically integer ops)"
  //
  // widening SMOPA is equivalent to performing dot product and accumulate
  //
  // we need 1 SMOPA instructions to output 1 ZA tiles"
  double flops_per_iteration = 1*8192.0;

  int64_t t0 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);
  __asm__ __volatile__ (
    "mov x0, %[n]                                                \n"
    "smstart                                                     \n"
    "ptrue p0.b                                                  \n"
    "1:                                                          \n"
    "  smopa za0.s, p0/m, p0/m, z0.b, z1.b                       \n"
    "                                                            \n"
    "  subs x0, x0, #1                                           \n"
    "  b.ne  1b                                                  \n"
    "smstop                                                      \n"
    : // no outputs
    : [n] "r" (N_ITERATIONS)
    : "x0"
  );
  uint64_t t1 = clock_gettime_nsec_np(CLOCK_UPTIME_RAW);

  // compute the rate
  double elapsed = (double)(t1 - t0)/1e9;
  double gflops  = flops_per_iteration*N_ITERATIONS/elapsed/1e9;

  return gflops;
}


